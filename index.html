<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
	<link rel="manifest" href="site.webmanifest">

	<title>Hex Kings</title>

	<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

	<script src="config.js"></script> <!-- LOCAL=false on public, true on local pc -->

<script>
	
/*

game logic:
click next turn:
savings = savings + (income - wages)

initially: (1 peasant (wage 3))

savings: 21
income: 5
wages: -3
balance: 23

click buy knight (cost 20, wage 8) ->
savings: 1
income: 5
wages: -11
balance: -5

place knight: (1 peasant, 1 knight)
*all units dies*
savings: 0
income: 5
wages: 0
balance: 5

makes little sense to allow placing unit if the result is everyone dying. 
unless you claim new hex which increases your income by 1, and makes income-wages zero. 
or if joining two pools together to get the balance positive.


*/
//////////////////////////////////////////////
//
//  force to public server here for quick testing:
//
//window.APP_CONFIG.LOCAL = false; // this is true on my pc by default. on release version false.


// set debug mode, without debug there will be no console.log/warn at all.
let DEBUGMODE = 1;

// Save originals ONCE
const _log = console.log.bind(console);
const _warn = console.warn.bind(console);

function debugMode(onoff = -1){
	if(onoff == -1){
		DEBUGMODE = !DEBUGMODE;
	}else{
		DEBUGMODE = onoff;
	}
	if (!DEBUGMODE) {
		console.log = function() {};
		console.warn = function() {};
	} else {
		console.log = _log;
		console.warn = _warn;
	}
}

// enable/disable debug:
debugMode(DEBUGMODE);




</script>



    
<style>

:root {
	--bg-color: #000000;
	--text-color: #eee;
	--border-color: #444;
	--input-bg: #1d1d1d;
	--btn-bg: #1d1d1d;
	--btn-hover-bg: #2a2a2a;
	--danger-color: #ff3b30;
	--warn-color: #ffcc00;
	--spec-color: #ffffff;
	--unclaimed-color: #555;
	--water-color: #003366;
	--land-color: #224422;
}

* {
	box-sizing: border-box;
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
	---user-select: none;
}

html, body {
	margin: 0;
	padding: 0;
	width: 100%;
	----height: 100%;
	----overflow: hidden;
	background-color: var(--bg-color);
	color: var(--text-color);
}

.page {
	display: none;
	width: 100%;
	height: 100%;
	----padding: 20px;
	overflow-y: auto;
	flex-direction: column;
	align-items: center;
	justify-content: center;
}

.page.active {
	display: flex;
}

.container {
	width: 100%;
	max-width: 410px;
	padding: 8px;
	---background: #1a1a1a;
	---border-radius: 8px;
	---border: 1px solid var(--border-color);
}

h1, h2, h3 {
	margin-top: 0;
	margin-bottom:2px;
	text-align: center;
	font-weight: 500;
}

input[type="text"], input[type="number"], select {
	width: 100%;
	padding: 12px;
	margin-bottom: 10px;
	background: var(--input-bg);
	border: 1px solid var(--border-color);
	color: var(--text-color);
	border-radius: 6px;
	font-size: 16px;
	height: 48px;
}

input[disabled], select[disabled] {
	filter: brightness(0.5);
}

input[type="range"] {
	width:100%;
}


button {
	width: 100%;
	padding: 12px;
	margin-bottom: 10px;
	background: var(--btn-bg);
	color: var(--text-color);
	border: none;
	border-radius: 6px;
	font-size: 16px;
	font-weight: 600;
	cursor: pointer;
}

button[disabled] {
	filter: brightness(0.5);
}


.lobbybutton {
	background-position: center;
	background-repeat: no-repeat;
	background-size: contain;
}
	
.gamebutton {
	padding:4px;
	
	padding-top: 2px;

	font-size: 15px;
	height: 44px;

	background-position: center;
	background-repeat: no-repeat;
	background-size: contain;
}

.largefont {
	font-size:27px;
}

.gamebutton.active {
	background-color:#45723d;
}

.tab-button {
	padding:4px;
	
	padding-top: 2px;

	font-size: 15px;
	height: 44px;

	background-position: center;
	background-repeat: no-repeat;
	background-size: contain;
	
	border-bottom-left-radius: 0;
	border-bottom-right-radius: 0;
}
.tab-button.active {
	background-color:#45723d;
}

.tab {
    display: none;
}

.tab.active {
    display: block;
}

.inline {
	display:inline-block;
}


#build-soldier-btn,
#build-castle-btn,
#build-other-btn {
	/* prevents annoying ghosting of hover effect that is visible under the build menu for a short time */
	-webkit-tap-highlight-color: transparent;
}

#build-soldier-btn.cancel,
#build-castle-btn.cancel,
#build-other-btn.cancel {
	background:#d03535;
}

#build-soldier-btn.cancel::after,
#build-castle-btn.cancel::after,
#build-other-btn.cancel::after {
	content: "Cancel";
	color: white;
}

	
button:hover {
	background-color: var(--btn-hover-bg);
}



button.primary {
	background-color: #00428e;
	color: white;
}

button.primary:hover {
	background-color: #1155cc;
}

button.danger {
	background-color: var(--danger-color);
	color: white;
}

button.toggle-btn.active {
	background-color: var(--warn-color);
	color: #000;
}

label {
	display: block;
	margin-bottom: 5px;
	font-size: 14px;
	color: #aaa;
}

.label {
	display: block;
	margin-bottom: 5px;
	font-size: 14px;
	color: #aaa;
}

.input-group {
	display: flex;
	gap: 10px;
	margin-bottom: 7px;
}

.input-group-nogap {
	display: flex;
	margin-bottom: 7px;
}

.input-group-tabs {
	display: flex;
	gap:1px;
	margin-bottom: 7px;
}


.input-group > div {
	flex: 1;
}

.input-group-slim {
	display: flex;
	gap: 10px;
}

.input-group-slim > div {
	flex: 1;
}

.settings-title {
	margin-bottom:5px;
}
.settings-title-nopad {
	margin-bottom:0;
}

.player-list {
	width: 100%;
	---padding: 10px;
	background: #000000;
	border:1px solid #333333;
	border-radius: 6px;
	height: 115px;
	overflow-y:auto;
	----margin-top: 15px;
}

.lobby-player-list {
	width: 100%;
	---padding: 10px;
	background: #000000;
	border:1px solid #333333;
	border-radius: 6px;
	height: 160px;
	overflow-y:auto;
	----margin-top: 15px;
}

.player-list-item {
	padding: 5px;
	border-bottom: 1px solid var(--border-color);
	word-break: break-all;
}

.player-list-item:last-child {
	border-bottom: none;
}

.ai-player-item {
	cursor: pointer;
}
.ai-player-item:hover::after {
	content: " (kick)";
	color: white;
}


.color-picker {
	display: flex;
	flex-wrap: wrap;
	gap: 7px;
	margin-bottom: 15px;
}

.color-box {
	width: 34px;
	height: 34px;
	border-radius: 50%;
	cursor: pointer;
	---border: 2px solid transparent;
	position: relative;
	display: inline-block;
}

.color-box.selected {
	border-color: white;
	box-shadow: 0 0 8px white;
}

.color-box.disabled {
	cursor: not-allowed;
	
	background: repeating-linear-gradient(
		45deg, /* angle of the stripes */
		rgba(0, 0, 0, 0.5), /* dark stripe color with transparency */
		rgba(0, 0, 0, 0.6) 4px,
		transparent 4px,
		transparent 7px
	);
}



.loaded-game-info {
	font-size: 14px;
	background: var(--input-bg);
	padding: 10px;
	border-radius: 4px;
	margin-bottom: 10px;
}

.loaded-player {
	cursor: pointer;
}
.loaded-player:hover {
	text-decoration: underline;
}
.loaded-player.taken {
	cursor: not-allowed;
	opacity: 0.5;
	text-decoration: line-through;
}

/* --- GAME PAGE --- */
#game-page {
	padding: 0;
	margin: 0;
	width: 100%;
	height: 100%;
	background: #000;
	user-select: none;
}

#game-canvas {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
}

#game-ui {
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	pointer-events: none;
	display: flex;
	justify-content: space-between;
	padding: 0px;
}

.ui-panel {
	pointer-events: auto;
	background: rgba(0, 0, 0, 0.8);
	---backdrop-filter: blur(5px);
	padding: 2px 6px 2px 6px;
	---max-height: 90vh;
	overflow-y: auto;
}

.ui-panel-trans {
	pointer-events: auto;
	----padding: 2px 6px 2px 6px;
	---max-height: 90vh;
	---overflow-y: auto;
}

#debug-ui {
	pointer-events: none;
	padding-right: 6px;
	position: absolute;
	top: 20px;
	right: 20px;
	text-align: right;
}

#ui-left {
	display: none; /*flex when visible*/
	flex-direction: column;
	gap: 0px;
	width: 200px;
}

#ui-right {
	position:absolute;
	bottom:0;
	right:0;
	overflow-y: hidden;
}

/* Top row: texts side by side */

#ui-right .top-row {
	display: flex;
	flex-direction: column; /* keep stats stacked vertically */
	---justify-content: flex-start; /* avoid pushing things to far right */
	justify-content: space-between;
	align-items: flex-end; /* if you want the numbers aligned right inside left panel */
	gap: 0px;
	padding-right: 10px;
	---margin-bottom: 10px;
	min-width: 0;
	height:100%;
	min-height:0;
	line-height: 24px;
}


.ui-panel-controls {
	display: flex;
	flex-direction: row;
	gap: 8px;
	align-items: flex-start; /* don't stretch vertically */
	box-sizing: border-box;
	width: 100%;
	border-top-left-radius: 10px;
	padding-top: 7px;
	height:100%;
}

.info-item {

}

.ui-number {
	color: #FFFF00;
}

.ui-number.yellow {
	color: #FFFF00;
}
.ui-number.red {
	color: #FF2222;
}
.ui-number.gray {
	color: #888888;
}
.ui-number.white {
	color: #FFFFFF;
}




.ui-panel-controls > .info-left {
	flex: 0 0 auto;     /* don't grow, don't shrink below content size */
	width: auto;
	min-width: 0;       /* allow shrinking in tight containers */
	display: block;
	padding-left:5px;
	height:100%;
	----padding-bottom:10px;
}

.ui-panel-controls > .info-right {
	flex: 1 1 auto;     /* grow to fill remaining space */
	min-width: 0;       /* allows flex children to shrink correctly */
	display: block;
	width:282px;
}

.info-editor {
	flex: 1 1 auto;     /* grow to fill remaining space */
	min-width: 0;       /* allows flex children to shrink correctly */
	display: block;
	width:390px;
}

.info-editor > .button-row {
    flex-direction: row;
    display: flex;
    gap: 5px;
}

#ui-editor {
    position: absolute;
    right: 0;
    top: 0;
}




/* Optional: style buttons as a row */

#ui-right .button-row {
	display: flex;
	flex-direction: row;
	gap: 5px;
	width: 100%;
	box-sizing: border-box;
}


/* Make buttons stretch evenly */

#ui-right .button-row button {
	flex: 1 1 0;                /* equal width buttons that can shrink/grow */
	display: flex;              /* make button a flex container */
	align-items: center;        /* vertical center */
	justify-content: center;    /* horizontal center */
	padding: 6px;               /* adjust as needed */
	box-sizing: border-box;
	min-width: 0;               /* important for flex shrink */
	height: 44px;               /* optional: keep consistent height */
}


.ui-menu {
	
}

.ui-menu .input-group {
	margin-bottom:0;
}


#player-ui-list {
	max-height: 68px;

	border-top: 1px solid #3e3e3e;
	border-bottom: 1px solid #3e3e3e;
}

#player-ui-list .player-list-item {
	display: flex;
	justify-content: space-between;
	align-items: center;
}

.player-turn-indicator {
	display: inline-block;
	width: 10px;
	height: 10px;
	border-radius: 50%;
	background: var(--warn-color);
	margin-right: 5px;
	visibility: hidden;
}

.player-list-item.current-turn .player-turn-indicator {
	visibility: visible;
}

#chat-ui {
	display: flex;
	flex-direction: column;
	height: 145px;

	border-bottom-right-radius: 8px;

	---padding: 0 0 0 4px;
}

#chat-messages {
	flex-grow: 1;
	overflow-y: auto;
	font-size: 13px;
	padding: 5px;
	background: rgba(0,0,0,0.2);
	border-radius: 4px;
	margin-bottom: 5px;
	margin-top: 3px;
	user-select: text !important;
	overflow-wrap: anywhere;
}

.msgfromtext, .msgtext {
	user-select: text !important;
}

#chat-input {
	width: 100%;
	padding: 8px;
	font-size: 14px;
	margin-bottom: 4px;
}

.smalltitle {
	text-align:center;
	margin-bottom:5px;
	font-size:18px;
}


.lobby-chat-messages {
	flex-grow: 1;
	overflow-y: auto;
	font-size: 13px;
	padding: 5px;
	user-select: text !important;
	overflow-wrap: anywhere;
	border: 1px solid gray;
	border-radius: 5px;
	max-height: 48px;
}

.lobby-chat-input {
	width:32% !important;
}


#build-popup-close {
	margin-top: 5px;
	width: 100%;
	height: 42px;
	padding: 5px 4px 5px 4px;
}

#build-popup {
	position: absolute;
	bottom: 0;
	right: 0;
	z-index: 100;
	pointer-events: auto;
	width: 294px;
	background-color:black;

	border-top-left-radius: 12px;
}

.build-item {
	display: flex;
	justify-content: space-between;
	
	padding: 2px 10px 2px 10px;
	background: var(--btn-bg);
	border-radius: 4px;
	margin-bottom: 5px;
	cursor: pointer;
}

.build-item:hover {
	background: var(--btn-hover-bg);
}

.build-item.disabled {
	opacity: 0.4;
	cursor: not-allowed;
	background: #222;
}

.build-item .cost {
	color: var(--warn-color);
	padding-top: 5px;
}

.build-item .elem-left {
	flex:1;
    text-align:left;
}
.build-item .elem-center {
	flex:1.7;
    text-align:left;
}
.build-item .elem-count {
	flex:0.5;
    text-align:left;
}
.build-item .elem-right {
	flex:1.2;
    text-align:right;
}


button.redbutton {
	background-color: #d03535;
}

button.redbutton:hover {
	background-color: #ca4747;
}

.savedgames-popup-overlay {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0,0,0,0.5);
	z-index: 1000;
	justify-content: center;
	align-items: center;
}

.savedgames-popup {
	background: black;
	border-radius: 12px;
	width: 100%;

	max-height: 100%;
	height: 100%;
	overflow-y: auto;
	position: relative;
	padding: 3px;
	box-shadow: 0 5px 20px rgba(0,0,0,0.2);
	----animation: fadeIn 0.2s ease;

	padding-top: 63px;
}

.savedgames-item {
	border-radius: 8px;
	text-align: center;
	cursor: pointer;
	---transition: 0.15s;

	margin-bottom: 8px;
	padding-top: 5px;
	padding-bottom: 5px;
}

.savedgames-item:hover {
	background: #333333;
	---transform: scale(1.03);
}

.savedgames-item img {
	width: 95%;
	border-radius: 6px;
}

.savedgames-list {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(156px, 1fr));
	gap: 0px;
}



/* NOTE: display: flex with fullscreen overlay causes chrome to add dashed borders around the overlay !!! */
.turn-popup-overlay {
	display: none;
	position: absolute;
	top: 0;
	z-index: 9999;
	width: 100%;
}

.turn-popup {
	padding: 5px;
	background: rgba(0, 0, 0, 0.5);
	width: 100%;
}

.turn-popup-text {
	font: 45px sans-serif;
	color: #FFFFFF;
	text-align: center;
}





/* Popup backdrop */
.popup-overlay {
	display: none;
	position: fixed;
	inset: 0;
	background: rgba(0,0,0,0.5);
	z-index: 1000;
	justify-content: center;
	align-items: center;
}

/* Popup box */
.popup {
	background: black;
	border-radius: 12px;
	width: 100%;

	max-height: 100%;
	height: 100%;
	overflow-y: auto;
	position: relative;
	padding: 3px;
	box-shadow: 0 5px 20px rgba(0,0,0,0.2);
	---animation: fadeIn 0.2s ease;

	padding-top: 104px;
}

@keyframes fadeIn {
	from { opacity: 0; transform: scale(0.95); }
	to { opacity: 1; transform: scale(1); }
}


.popup-top-bar {
	position: fixed;
	top: 0;

	border: none;
	font-size: 29px;

	width: 100%;
	padding: 0;

	background-color:rgba(0,0,0, 1);
}

.popup-title {
	font-size:24px;
	text-align:center;
	padding:10px;
}

/* Close (X) button */
.popup-close {
	position: absolute;
	right: 0;
	width: 50px;
	height: 43px;
	font-size: 34px;
	line-height: 21px;
	padding-top: 6px;
}

/* Category buttons */
.category-tabs {
	display: inline-flex;
	gap: 8px;
	---margin-bottom: 16px;
	---margin-top: 15px;
}

.category-btn {
	padding: 8px 16px;
	border: 1px solid #333;
	background: #338;
	cursor: pointer;
	border-radius: 8px;
	font-weight: bold;
	color: #c5bef1;
}

.category-btn:hover {
	background: #66B;
}

.category-btn.active {
	background: #007bff;
	color: white;
	border-color: #007bff;
}

/* Map list */

.map-item {
	border-radius: 8px;
	text-align: center;
	cursor: pointer;
	---transition: 0.15s;

	margin-bottom: 8px;
	padding-top: 5px;
	padding-bottom: 5px;

}

.map-item:hover {
	background: #333333;
	---transform: scale(1.03);
}

.map-item img {
	width: 95%;
	border-radius: 6px;
}

.map-list {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(156px, 1fr));
	gap: 0px;
}


#loaded-map {
	border: 1px solid #ccc;
	border-radius: 6px;
}


#game-settings-ui-wrapper {
	display: flex;
	flex-direction: column;
	align-items: center;
	width:100%;
	height:100%;
}

#game-settings-ui-wrapper2 {
	height:100%;
}

/* Popup container */
#game-settings-ui {
	position: fixed;
	inset: 0;
	display: none;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	---background: rgba(0, 0, 0, 0.7);
	z-index: 9999;
}

/* Visible state */
#game-settings-ui.active {
	display: flex;
}






#endgame-popup-ui-wrapper {
	display: flex;
	flex-direction: column;
	align-items: center;
	width:100%;
	---height:50%;
}

#endgame-popup-ui-wrapper2 {
	height:100%;
	background-color: rgba(0, 0, 0, 0.8);
	border-radius: 37px;
}

/* Popup container */
#endgame-popup-ui {
	position: fixed;
	inset: 0;
	display: none;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	---background: rgba(0, 0, 0, 0.7);
	z-index: 9999;
	user-select: none;
}

/* Visible state */
#endgame-popup-ui.active {
	display: flex;
}

#close-endgame-popup-btn {
	border-radius: 27px;
	margin-bottom: 0;
	border-top-left-radius: 0;
	border-top-right-radius: 0;
}

#endgame-popup-message {
	text-align: center;
	margin-top: 10px;
	font-size: 20px;
	margin-bottom: 20px;
}
#endgame-popup-title {
	text-align: center;
	color: yellow;
	padding: 0 0 10px 0;
	font-size: 52px;
	font-weight:bold;
}

#endgame-popup-stats {
	margin-bottom:35px;
}



.yellow {
	color: yellow;
}




#move-confirmation-wrapper {
	display: flex;
	flex-direction: column;
	align-items: center;
	width:100%;
}
#move-confirmation-wrapper2 {
	box-shadow: 15px 15px 23px rgba(0, 0, 0, 1);
	width:90%;
	max-width:400px;
}


/* Popup container */
#move-confirmation-popup {
	position: fixed;
	inset: 0;
	display: none;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background: rgba(0, 0, 0, 0.7);
	z-index: 9999;
}

/* Visible state */
#move-confirmation-popup.active {
	display: flex;
}



#music-volume {
	width: 100%;
}
#music-volume2 {
	width: 100%;
}
.music-volume-wrapper {
	padding:0;
}



#close-game-settings-btn {
    padding-bottom: 10px;
    line-height: 30px;
	font-size:36px;
}

.settings-panel {
	width: 100%;
	max-width: 400px;
	border: 1px solid #454545;
	border-radius: 8px;
	padding: 10px;
	background-color: black;
}

.settings-panel.trans {
	background-color: rgba(0, 0, 0, 0.5);
}


#top-float-ui {
	display: none;
	flex-direction: column;
	padding-left: 4px;
	position: absolute;
	top: 0;
	left: 0;
	width: 100%;
	font-size: 18px;
	line-height: 20px;      /* your chosen line height */
	----height: calc(3 * 20px);   /* 3 lines tall */
	pointer-events: none;
	overflow-wrap: anywhere;
}

#top-float-ui-messages {
	flex-grow: 1;
	overflow-y: hidden;
	text-shadow: 2px 2px 1px rgba(0, 0, 0, 1), 0px 0px 2px rgba(0, 0, 0, 1), 0px 0px 4px rgba(0, 0, 0, 1);
	color:white;
	padding-bottom: 4px;
}




input.disabled {
	cursor: not-allowed;
}


/* Popup container */
#image-popup {
	position: fixed;
	inset: 0;
	display: none;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background: rgba(0, 0, 0, 0.7);
	z-index: 9999;
}

/* Visible state */
#image-popup.active {
	display: flex;
}

/* Enlarged image style */
#image-popup img {
	width: 90vw;          /* take up 90% of viewport width */
	height: auto;         /* maintain aspect ratio */
	max-height: 90vh;     /* prevent overflowing vertically */
	object-fit: contain;  /* ensures the image scales proportionally */
	border-radius: 8px;
}


.input-group-icons {
	display: flex;
	gap: 10px;
	line-height: 26px;
}
.input-group-center {
	display: flex;
	gap: 10px;
	margin-bottom: 7px;
	align-items: center;
}

.no-select {
	user-select: none;
	-webkit-user-select: none; /* Safari */
	-ms-user-select: none;     /* old Edge */
}


.poolinfo {
	padding:0px;

	font-size: 15px;
	width: 18px;
	height: 26px;

	background-position: center;
	background-repeat: no-repeat;
	background-size: contain;
	
	display:flex;
}

.ui-savings {
	background-image: url('images/ui/savings.png');
}
.ui-income {
	background-image: url('images/ui/income.png');
}
.ui-wages {
	background-image: url('images/ui/wages.png');
}
.ui-balance {
	background-image: url('images/ui/balance.png');
}


.scrollable {
	scrollbar-width: thin;
	scrollbar-color: #555 #1e1e1e;
}

.scrollable::-webkit-scrollbar {
	width: 10px;
}

.scrollable::-webkit-scrollbar-track {
	background: #1e1e1e;
}

.scrollable::-webkit-scrollbar-thumb {
	background-color: #555;
	border-radius: 6px;
	border: 2px solid #1e1e1e;
}


.game-logo {
	background-image: url('images/logo256_2.png');
	background-position: center;
	background-repeat: no-repeat;
	background-size: contain;
	width:100%;
	height:40px;
}

.image {
	background-position: center;
	background-repeat: no-repeat;
	background-size: contain;
	padding:0px;
	display:flex;
}
.settings-image {
	width: 54px;
	height: 54px;
}
.settings-image-elem {
	flex: 0 0 54px; /* fixed width, other elems will take all space */
}
.settings-percent-input {
	margin:0 !important;
	padding-right: 0 !important;
	height:32px !important;
	padding-left: 7px !important;
}

.settings-musicplayer-elem {
	flex: 0 0 54px; /* fixed width, other elems will take all space */
}


.image-tree {
	background-image: url('images/orig-scaled/128x128/tree.png');
}
.image-tree.winter {
	background-image: url('images/orig-scaled/128x128/winter/tree.png');
}

.image-rock {
	background-image: url('images/orig-scaled/128x128/rock2c.png');
}
.image-rock.winter {
	background-image: url('images/orig-scaled/128x128/winter/rock.png');
}

.image-grass {
	background-image: url('images/orig-scaled/128x128/grass.png');
}
.image-grass.winter {
	background-image: url('images/orig-scaled/128x128/winter/grass.png');
}

.image-mine {
	background-image: url('images/orig-scaled/128x128/mine1.png');
}
.image-mine.winter {
	background-image: url('images/orig-scaled/128x128/winter/mine.png');
}

.image-landmine {
	background-image: url('images/orig-scaled/128x128/landmine1.png');
}
.image-landmine.winter {
	background-image: url('images/orig-scaled/128x128/winter/landmine.png');
}

.image-soldier {
	background-image: url('images/orig-scaled/128x128/soldier1.png');
}
.image-castle {
	background-image: url('images/orig-scaled/128x128/castle1.png');
}
.image-boat {
	background-image: url('images/orig-scaled/128x128/sailboat.png');
}

.image-dead {
	background-image: url('images/orig-scaled/128x128/dead.png');
}
.image-dead.winter {
	background-image: url('images/orig-scaled/128x128/winter/dead.png');
}




#build-soldier-btn {
	background-image: url('images/orig-scaled/128x128/soldier1.png');
}
#build-soldier-btn.disabled {
	filter: brightness(0.5);
}
#build-soldier-btn[disabled] {
	filter: brightness(0.5);
}


#build-castle-btn {
	background-image: url('images/orig-scaled/128x128/castle1.png');
}
#build-castle-btn.disabled {
	filter: brightness(0.5);
}
#build-castle-btn[disabled] {
	filter: brightness(0.5);
}


#undo-btn {
	background-image: url('images/ui/undo.png');
}
#undo-btn.disabled {
	background-color:var(--btn-bg);
	filter: brightness(0.5);
}
#undo-btn[disabled] {
	background-color:var(--btn-bg);
	filter: brightness(0.5);
}


.btn-settings {
	background-image: url('images/ui/settings-icon.png');
}


#toggle-ui-btn {
	background-image: url('images/ui/chat.png');
}

#settings-btn {
	background-image: url('images/ui/settings-icon.png');
}

#game-settings-btn,
#game-settings-btn2,
#lobby-game-settings-btn {
	background-image: url('images/ui/settings-icon.png');
}

.music-previous-btn {
	background-image: url('images/ui/music-previous.png');
}
.music-next-btn {
	background-image: url('images/ui/music-next.png');
}
.music-play-btn {
	background-image: url('images/ui/music-play.png');
}
.music-pause-btn {
	background-image: url('images/ui/music-pause.png');
}
.music-unmute-btn {
	background-image: url('images/ui/music-mute.png');
}
.music-mute-btn {
	background-image: url('images/ui/music-unmute.png');
}

#rotate-left-btn {
	background-image: url('images/ui/rotate-left.png');
}
#rotate-reset-btn {
	background-image: url('images/ui/rotate-reset.png');
}
#rotate-right-btn {
	background-image: url('images/ui/rotate-right.png');
}





#quick-settings-btn {
	background-image: url('images/ui/settings-icon.png');
}


#build-other-btn {
	background-image: url('images/ui/build.png');
}
#build-other-btn.disabled {
	filter: brightness(0.5);
}
#build-other-btn[disabled] {
	filter: brightness(0.5);
}


#sell-unit-btn {
	background-image: url('images/ui/sell.png');
}
#sell-unit-btn.disabled {
	filter: brightness(0.5);
}
#sell-unit-btn[disabled] {
	filter: brightness(0.5);
}


#end-turn-btn {
	background-image: url('images/ui/endturn.png');
}
#end-turn-btn[disabled] {
	background-color:var(--btn-bg);
	filter: brightness(0.5);
}




#next-unit-btn {
	background-image: url('images/ui/next.png');
}
#next-unit-btn[disabled] {
	background-color:var(--btn-bg);
	filter: brightness(0.5);
}

#previous-unit-btn {
	background-image: url('images/ui/previous.png');
}
#previous-unit-btn[disabled] {
	background-color:var(--btn-bg);
	filter: brightness(0.5);
}





#spectate-btn[disabled] {
	filter: brightness(0.5);
}
#join-btn[disabled] {
	filter: brightness(0.5);
}




#picker-wrapper {
	display: flex;
	flex-direction: column;
	align-items: center;
	width:100%;
	max-width: 400px;
	background-color: black;
	border: 1px solid #454545;
	border-radius: 8px;
	padding-top: 20px;
}

/* Popup container */
#picker-popup {
	position: fixed;
	inset: 0;
	display: none;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background: rgba(0, 0, 0, 0.7);
	z-index: 9999;
}

/* Visible state */
#picker-popup.active {
	display: flex;
}


.picker {
	position: relative;
	width: 100%;
    max-width: 300px;
	height: 150px;
	background: linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);
	cursor: crosshair;
	touch-action: none;
	border: 1px solid #ccc;
	overflow: hidden;
}

.picker::after {
	content: '';
	position: absolute;
	inset: 0;
	background: linear-gradient(to top, #808080, transparent);
}

.indicator {
	position: absolute;
	width: 12px;
	height: 12px;
	border: 2px solid #fff;
	border-radius: 50%;
	pointer-events: none;
	transform: translate(-50%, -50%);
	box-shadow: 0 0 2px #000;
}

#lightness {
	margin-top: 20px;
	margin-bottom: 20px;

	width: 100%;
	max-width: 300px;
}



#preview {
	---margin-top: 20px;
	width: 50px;
	height: 50px;
	border: 1px solid #000;
}

.hidden {
	display:none;
}


</style>
</head>
<body>



<input type="hidden" id="dirty-flag">

<div id="turn-popup-overlay" class="turn-popup-overlay">
	<div class="turn-popup" id="turn-popup">
		<div class="turn-popup-text" id="turn-popup-text">
			YOUR TURN
		</div>
	</div>
</div>

<div id="map-popup-overlay" class="popup-overlay">
	<div class="popup" id="map-popup">
		
		<div class="popup-top-bar">
			<div class="input-group-slim">
				<div class="popup-title">Load map</div>
				<button class="popup-close" id="popup-close">&times;</button>
			</div>
			<div class="category-tabs">
				<button class="category-btn active" data-category="all">All</button>
				<button class="category-btn" data-category="small">Small</button>
				<button class="category-btn" data-category="normal">Normal</button>
				<button class="category-btn" data-category="custom">Custom</button>
			</div>
			
		</div>
		<div class="map-list" id="map-list"></div>
	</div>
</div>

<div id="savedgames-popup-overlay" class="savedgames-popup-overlay">
	<div class="savedgames-popup" id="savedgames-popup">
		
		<div class="popup-top-bar">
			<div class="input-group">
				<div class="popup-title">Load game</div>
				<button class="popup-close" id="savedgames-popup-close">&times;</button>
			</div>
		</div>
		<div class="savedgames-list" id="savedgames-list"></div>
	</div>
</div>


<div id="picker-popup">
	<div id="picker-wrapper" class="no-select">
		<div class="picker" id="picker">
			<div class="indicator" id="indicator"></div>
		</div>
		<input type="range" id="lightness" min="0" max="100" value="50">
		<div class="input-group-center">
			<button style="flex: 1" class="picker-popup-select primary" id="picker-popup-select">Select</button>
			<div id="picker-preview-tile-wrapper">
				<canvas id="picker-preview-tile" style="width:90px; height:90px"></canvas>
			</div>
			<button style="flex: 1" class="picker-popup-cancel" id="picker-popup-cancel">Cancel</button>
		</div>
	</div>
</div>


<div id="move-confirmation-popup" hidden>
	<div id="move-confirmation-wrapper">
		<div id="move-confirmation-wrapper2" class="ui-menu ui-panel settings-panel">
			<p style="color:#FFFF00">Note: Undo is no longer possible after claiming an enemy tile.</p>

			<label class="inline">
				<input type="checkbox" id="move-confirmation-popup-dont-show-again">
				Do not show this again
			</label>

			<button id="move-confirmation-popup-confirm-button">OK</button>
		</div>
	</div>
</div>



<!-- endgame popup -->
<div id="endgame-popup-ui">
	<div id="endgame-popup-ui-wrapper">
		<div id="endgame-popup-ui-wrapper2" class="ui-menu ui-panel settings-panel scrollable">

			<div style="display: flex; flex-direction: column; height:100%">
				<div class="input-group">
					<div id="endgame-popup-title">
						Game over!
					</div>
				</div>
				
				<div id="endgame-popup-message">
					You have won the game!
				</div>
				
				
				<ul id="endgame-popup-stats">
					<li>Total hexes: <span id="endgame-popup-stats-hexes" class="yellow">100</span></li>
					<li>Total soldiers: <span id="endgame-popup-stats-soldiers" class="yellow">100</span></li>
					<li>Total wages: <span id="endgame-popup-stats-wages" class="yellow">100</span></li>
					<li>Total money: <span id="endgame-popup-stats-money" class="yellow">100</span></li>
				</ul>
				
				
				<div class="input-group" style="margin-top: auto;">
					<div style="flex: 1;">
						<button id="close-endgame-popup-btn" class="gamebutton largefont">Close</button>
					</div>
				</div>
			</div>
		</div>
	</div>
</div>

<!-- lobby settings -->
<div id="game-settings-ui">
	<div id="game-settings-ui-wrapper">
		<div id="game-settings-ui-wrapper2" class="ui-menu ui-panel settings-panel scrollable">

			<div class="input-group">
				<div style="flex: 4; padding: 10px 0 10px 0; font-size: 20px; font-weight:bold">
					Settings
				</div>
				<div style="flex: 3;" class="ingame-class hidden">
					<button id="save-game-btn" class="gamebutton">Save game</button>
				</div>
				<div style="flex: 3;" class="ingame-class hidden">
					<button id="quit-game-btn" class="gamebutton redbutton">Quit game</button>
				</div>
				<div style="flex: 1;">
					<button id="close-game-settings-btn" class="gamebutton largefont">Ã—</button>
				</div>
			</div>
			
			
			<div class="input-group-tabs">
				<div style="flex: 1;">
					<button data-tabclass="tab-game" class="tab-game-settings tab-button active">Game</button>
				</div>
				<div style="flex: 1;">
					<button data-tabclass="tab-audio" class="tab-game-settings tab-button">Audio</button>
				</div>
				<div style="flex: 1;">
					<button data-tabclass="tab-graphics" class="tab-game-settings tab-button">Graphics</button>
				</div>
				<div style="flex: 1;">
					<button data-tabclass="tab-other" class="tab-game-settings tab-button">Other</button>
				</div>
				<div style="flex: 1;">
					<button data-tabclass="tab-keys" class="tab-game-settings tab-button">Keys</button>
				</div>
			</div>
			
			<!-- not used yet, supposed to show this class when prompting user with confirmation, for-settings should be the visible class -->
			<div class="for-confirmation">
				Press accept settings for host to start game:
				<button id="confirm-game-settings-btn" class="gamebutton">Accept Settings</button>
			</div>
			
			
			<div class="tab tab-keys">
				<div class="settings-title">
					Keyboard shortcuts:
				</div>
				<div><span style="color:yellow">Q</span> = Rotate counterclockwise</div>
				<div><span style="color:yellow">E</span> = Rotate clockwise</div>
				<div><span style="color:yellow">W</span> = Reset rotation</div>
				<div><span style="color:yellow">Space</span> = Show previous moves of soldiers</div>
				<div><span style="color:yellow">Right Click</span> = Cancel selections</div>
				
			</div>
			
			
			<div class="tab tab-other">
				<div class="settings-title">
					Autosave (at end of day):
				</div>
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-autosave" checked>
						Enable
					</label>
				</div>
				
				<div class="settings-title">
					Editor:
				</div>
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-editor">
						Enable
					</label>
				</div>
			</div>
			
			
			<div class="tab tab-graphics">
				
				<div id="map-theme-override-wrapper">
					<div class="input-group">
						<div style="flex: 1;">
							<div class="settings-title">
								Theme:
							</div>
							<select id="map-theme-override">
								<option value="0">Default</option>
								<option value="1">Summer</option>
								<option value="2">Winter</option>
							</select>
						</div>
						<div style="flex: 1;">
							
						</div>
					</div>
				</div>
				
				<div class="settings-title">
					Render:
				</div>

				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-shading-land" checked>
						Land shading
					</label>
				</div>
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-shading-land3d" checked>
						Elevated land
					</label>
				</div>
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-shading-shore" checked>
						Shores shading
					</label>
				</div>

				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-shading-pooledges" checked>
						Unselected pool edges
					</label>
				</div>
				
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-particles" checked>
						Particles
					</label>
				</div>
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-water" checked>
						Water
					</label>
				</div>
				
				<div>
					<label class="inline">
						<input type="checkbox" id="game-settings-gfx-pointers" checked>
						Onscreen pointers
					</label>
				</div>
				
				
			</div>
			
			<div class="tab tab-audio">

				<div class="settings-title">
					Music player:
				</div>
				<div class="music-volume-wrapper">
					<div class="input-group-nogap" style="align-items: center; gap:5px">
						<div class="settings-musicplayer-elem">
							<button id="music-pause-btn2" class="music-pause-btn gamebutton" style="display:none"></button>
							<button id="music-play-btn2" class="music-play-btn gamebutton"></button>
						</div>
						<div class="settings-musicplayer-elem">
							<button id="music-mute-btn2" class="music-mute-btn gamebutton" title="Mute"></button>
							<button id="music-unmute-btn2" class="music-unmute-btn gamebutton" title="Unmute" style="display:none"></button>
						</div>
						<div class="settings-musicplayer-elem">
							<button id="music-previous-btn2" class="music-previous-btn gamebutton"></button>
						</div>
						<div style="flex: 1;">
							<input type="range" id="music-volume2" min="0" max="200" value="1">
						</div>
						<div class="settings-musicplayer-elem">
							<button id="music-next-btn2" class="music-next-btn gamebutton"></button>
						</div>
					</div>
				</div>
				<br>

			</div>
			
			<div class="tab tab-game active">
				<div>
					<div class="settings-title">
						<span style="color:yellow">Undo is disabled if:</span> Unit dies on a mine, Enemy tile is claimed, Unit is unloaded from boat.<br>
						<br>
					</div>
				</div>
				
				<div>
					<div class="input-group">
						<div style="flex: 1;">
							<div class="settings-title">
								Start money per hex:
							</div>
							<input type="number" id="start-money-per-hex" step="any" disabled>
						</div>
						<div style="flex: 1;">
							<div class="settings-title">
								Theme:
							</div>
							<select id="map-theme" disabled>
								<option value="1">Summer</option>
								<option value="2">Winter</option>
							</select>
						</div>
					</div>
				</div>
				
				
				<br>
				<div>
					<div class="settings-title">
						Game end rule:
					</div>
					<div class="input-group">
						<select id="game-end-rule" disabled>
							<option value="0">Lose all warriors & Cannot buy anything</option>
							<option value="1">Lose all warriors</option>
						</select>
					</div>
				</div>

				
				<div class="settings-title">
					Units:
				</div>
				<div>
					<label>
						<input type="checkbox" id="game-settings-use-boats" checked>
						Boats
					</label>
					<div class="input-group">
						<div style="flex: 0.5;">
							Cost: <input type="number" id="game-settings-boat-cost" value="1">
						</div>
						<div style="flex: 0.6;">
							Start with: <input type="number" id="game-settings-initial-boats" value="1">
						</div>
						<div style="flex: 0.9;">
							Add per week: <input type="number" id="game-settings-boats-add" value="1">
						</div>
						<div style="flex: 0.5;">
							Limit: <input type="number" id="game-settings-max-boats" value="10">
						</div>
					</div>
					<label>
						<input type="checkbox" id="game-settings-use-landmines" checked>
						Landmines
					</label>
					<div class="input-group">
						<div style="flex: 0.5;">
							Cost: <input type="number" id="game-settings-mine-cost" value="1">
						</div>
						<div style="flex: 0.6;">
							Start with: <input type="number" id="game-settings-initial-mines" value="1">
						</div>
						<div style="flex: 0.9;">
							Add per week: <input type="number" id="game-settings-mines-add" value="1">
						</div>
						<div style="flex: 0.5;">
							Limit: <input type="number" id="game-settings-max-mines" value="10">
						</div>
					</div>
				</div>
		
				
				<br>
				<div>
					<div class="input-group-nogap">
						<div class="settings-image-elem">
							<div class="image settings-image image-tree"></div>
						</div>
						<div style="flex: 1;">
							<div class="settings-title-nopad">
								Trees chance per tile:
							</div>
							<div class="input-group" style="align-items:center">
								<div style="flex: 4;">
									<input type="range" id="tree-percent" min="0" max="100" value="15" disabled>
								</div>
								<div style="flex: 1;">
									<input type="text" id="tree-percent-text" class="settings-percent-input" disabled>
								</div>
							</div>
						</div>
					</div>

					<div class="input-group-nogap">
						<div class="settings-image-elem">
							<div class="image settings-image image-rock"></div>
						</div>
						<div style="flex: 1;">
							<div class="settings-title-nopad">
								Rocks chance per tile:
							</div>
							<div class="input-group" style="align-items:center">
								<div style="flex: 4;">
									<input type="range" id="rock-percent" min="0" max="100" value="15" disabled>
								</div>
								<div style="flex: 1;">
									<input type="text" id="rock-percent-text" class="settings-percent-input" disabled>
								</div>
							</div>
						</div>
					</div>
					
					<div class="input-group-nogap">
						<div class="settings-image-elem">
							<div class="image settings-image image-mine"></div>
						</div>
						<div style="flex: 1;">
							<div class="settings-title-nopad">
								Mines chance per tile:
							</div>
							<div class="input-group" style="align-items:center">
								<div style="flex: 4;">
									<input type="range" id="mine-percent" min="0" max="100" value="15" disabled>
								</div>
								<div style="flex: 1;">
									<input type="text" id="mine-percent-text" class="settings-percent-input" disabled>
								</div>
							</div>
						</div>
					</div>
					
			
				</div>
			
			</div>

		</div>
	</div>
</div>


<div id="image-popup">
	<div style="padding:5px">Map preview</div>
	<img id="popup-img" src="" alt="Enlarged view">
</div>


<div id="start-page" class="page active">
	<div class="container">
		<div class="game-logo">
		</div>
		<!-- <h1 style="color:yellow">ðŸ‘‘ Hex Kings ðŸ‘‘</h1> -->
		<label for="player-name">Your Name:</label>
		
		<div class="input-group">
			<input type="text" id="player-name" value="" style="flex: 3">
			<button id="random-name-btn" style="flex: 1">Random</button>
		</div>
		
		<label for="game-name-input">Game Room Name:</label>
		<input type="text" id="game-name-input" value="default-room">
		<div class="input-group" style="display: flex; gap: 10px; align-items: center; margin-top: 7px;">
			<label for="server-name-input">Server:</label>
			<select id="server-name-input">
			
			</select>
		</div>
		<div class="input-group" style="display: flex; gap: 10px; align-items: center;">
			<label for="games-list-input">Gamelist:</label>
			<select id="games-list-input">
			
			</select>
		</div>
		<button id="host-btn" class="primary">Host Game</button>
		<button id="join-btn" disabled>Join Game</button>
		<button id="spectate-btn" disabled>Join as Spectator</button>
		<div id="connection-status" style="text-align: center; margin-top: 10px; font-size: 14px;">Initializing...</div>
	</div>
</div>




<div id="host-page" class="page">
	<div class="container">
		<h2 id="host-room-name-title">Hosting: default-room</h2>
		
		<label for="host-room-player-name">Your Name:</label>
		<div class="input-group">
			<input type="text" id="host-room-player-name" value="" style="flex: 3">
			<button id="spectate-host-btn" class="toggle-btn" style="flex: 1">Spectate</button>
		</div>
		

		<div class="input-group">
			<div style="flex:1">
				<span class="label">Select Color:</span>
				<div id="host-room-color-picker" class="color-picker"></div>
				<div id="host-room-color-picker-msg" style="display:none"><i>Not available.</i></div>
			</div>
			<div style="flex:1">
				<span class="label">Custom Color:</span>
				<div id="host-preview-tile-wrapper">
					<canvas id="host-preview-tile" style="width:90px; height:90px"></canvas>
					<div id="host-preview-tile-msg" style="display:none"><i>Not available.</i></div>
				</div>
				
				<span class="label">Texture:</span>
				<!-- land-c1... landTextures -->
				<div id="host-texture-type-wrapper">
					<select id="host-texture-type">
						<option value="0">Grass</option>
						<option value="1">Granite</option>
						<option value="2">Sand</option>
						<option value="3">Quartz</option>
						<option value="4">Brick</option>
						<option value="5">Triangular</option>
						<option value="6">Emerald</option>
						<option value="7">Crystal</option>
						<option value="8">Mercury</option>
					</select>
					<div id="host-texture-type-msg" style="display:none"><i>Not available.</i></div>
				</div>

			</div>
			<div style="flex:1">
				<span class="label joined-players-text">Players:</span>
				<div id="host-player-list" class="player-list scrollable"></div>
				
				<div class="input-group">
					<button id="add-ai-btn">Add AI</button>
				</div>
			</div>
			
		</div>
		
		<!-- todo: later when random map generator is added, or map editor, then enable these inputs: -->
		<div class="input-group" style="display:none">
			<div>
				<label for="map-width">Map Width</label>
				<input type="number" id="map-width" value="24">
			</div>
			<div>
				<label for="map-height">Map Height</label>
				<input type="number" id="map-height" value="24">
			</div>
		</div>
		<div style="display:none">
			<label for="start-money">Starting Money</label>
			<input type="number" id="start-money" value="1000">
		</div>
		
		<div id="lobby-chat-ui" class="lobby-ui-panel">
			<div>
				<div class="input-group" style="flex-direction: row !important;">
					<div id="lobby-chat-messages" class="lobby-chat-messages"></div>
					<input type="text" inputmode="text" id="lobby-chat-input" class="lobby-chat-input" maxlength="200" placeholder="Type message">
				</div>
			</div>
		</div>
		

		<div class="input-group">
			<div style="width:110px; flex:0 0 auto;">
				<span class="label">Loaded map:</span>
				<img id="loaded-map" src="" width="100" height="100">
			</div>
			
			<div>
				<div class="input-group" style="flex-direction: row !important;">
					<label for="map-scale">Map scale:</label>
					<!-- <input type="number" id="map-scale" value="1" min="1" max="4"> -->
					<select id="map-scale">
						<option value="1">1x</option>
						<option value="2">2x</option>
						<option value="3">3x</option>
						<option value="4">4x</option>
					</select>
					<button id="game-settings-btn" class="lobbybutton" title="More Settings"></button>
				</div>
				<div class="input-group" style="flex-direction: row !important;">
					<label for="start-player-list">Start player:</label>
					<select id="start-player-list">
					</select>
				</div>
			</div>
		</div>

		<div class="input-group">
			<button id="load-map-btn">Select Map</button>
			<button id="load-random-map-btn">Random map</button>
			<button id="load-game-btn" style="display:block">Load Game</button>
		</div>

		<button id="start-game-check-btn" style="display:none">Start Check</button>
		<button id="start-game-btn" class="primary">Start Game</button>
		<button id="start-replay-btn" class="primary" style="display:none">Start Replay</button>
		
		<div id="loaded-game-info-container" class="loaded-game-info" style="display: none;">
			<p><strong>Saved Game:</strong> <span id="load-game-date"></span></p>
			<p><strong>Players:</strong></p>
			<ul id="load-game-players"></ul>
		</div>
	</div>
</div>


<div id="lobby-page" class="page">
	<div class="container">
		<h2 id="lobby-room-name-title">Joined: </h2>
		

		<label for="lobby-player-name">Your Name:</label>
		<input type="text" id="lobby-player-name" value="">
		
		<div class="input-group">
			<div style="flex:1">
				<span class="label">Select Color:</span>
				<div id="lobby-color-picker" class="color-picker"></div>
				<div id="lobby-color-picker-msg" style="display:none"><i>Not available.</i></div>
			</div>
			<div style="flex:1">
				<span class="label">Custom Color:</span>
				<div id="lobby-preview-tile-wrapper">
					<canvas id="lobby-preview-tile" style="width:90px; height:90px"></canvas>
					<div id="lobby-preview-tile-msg" style="display:none"><i>Not available.</i></div>
				</div>

				<span class="label">Texture:</span>
				<!-- land-c1... landTextures -->
				<div id="lobby-texture-type-wrapper">
					<select id="lobby-texture-type">
						<option value="0">Grass</option>
						<option value="1">Granite</option>
						<option value="2">Sand</option>
						<option value="3">Quartz</option>
						<option value="4">Brick</option>
						<option value="5">Triangular</option>
						<option value="6">Emerald</option>
						<option value="7">Crystal</option>
						<option value="8">Mercury</option>
					</select>
					<div id="lobby-texture-type-msg" style="display:none"><i>Not available.</i></div>
				</div>
				
			</div>
			<div style="flex:1">
				<span class="label joined-players-text">Players:</span>
				<div id="lobby-player-list" class="lobby-player-list scrollable"></div>
			</div>
		</div>
		
		<div id="lobby-game-settings" style="display:none">
			<p><strong>Map:</strong> <span id="lobby-map-size">...</span></p>
			<p><strong>Money:</strong> <span id="lobby-start-money">...</span></p>
		</div>
		
		<div id="client-lobby-chat-ui" class="lobby-ui-panel">
			<div>
				<div class="input-group" style="flex-direction: row !important;">
					<div id="client-lobby-chat-messages" class="lobby-chat-messages"></div>
					<input type="text" inputmode="text" id="client-lobby-chat-input" class="lobby-chat-input" maxlength="200" placeholder="Type message">
				</div>
			</div>
		</div>
		
		<div class="input-group">
			<div style="width:110px; flex:0 0 auto;">
				<span class="label">Loaded map:</span>
				<img id="lobby-loaded-map" src="" width="100" height="100">
			</div>
			
			<div>
				<div class="input-group" style="flex-direction: row !important;">
					<label for="lobby-map-scale">Map scale:</label>
					<!-- <input type="number" id="lobby-map-scale" class="disabled" value="1" max="4" disabled> -->
					<select id="lobby-map-scale" disabled>
						<option value="1">1x</option>
						<option value="2">2x</option>
						<option value="3">3x</option>
						<option value="4">4x</option>
					</select>
					<button id="lobby-game-settings-btn" class="lobbybutton" title="More Settings"></button>
				</div>
				<div class="input-group" style="flex-direction: row !important;">
					<label for="lobby-start-player-list">Start player:</label>
					<select id="lobby-start-player-list" disabled>
					</select>
				</div>
			</div>
			

		</div>
		
		
		
		<p id="lobby-status" style="text-align: center;">Waiting for host to start...</p>
	</div>
</div>




<div id="game-page" class="page">
	<canvas id="game-canvas"></canvas>
	
	<div id="top-float-ui">
		<div id="top-float-ui-messages"></div>
	</div>
	
	
	
	
	<div id="game-ui">
		<div id="ui-left">
			<div class="ui-menu ui-panel">
				
				
			
				<div class="input-group">
					<div style="flex: 1;">
						<button id="rotate-left-btn" class="gamebutton largefont" title="Rotate Anticlockwise"></button>
					</div>
					<div style="flex: 1;">
						<button id="rotate-reset-btn" class="gamebutton largefont" title="Reset Rotation"></button>
					</div>
					<div style="flex: 1;">
						<button id="rotate-right-btn" class="gamebutton largefont" title="Rotate Clockwise"></button>
					</div>
				</div>
			</div>
			
			<div id="player-ui-list" class="ui-panel scrollable"></div>
			<div id="chat-ui" class="ui-panel">
				<div id="chat-messages" class="scrollable"></div>
				<input type="text" inputmode="text" id="chat-input" maxlength="200" placeholder="Type message...">
			</div>
			
			<div id="debug-ui">
				<div id="turn-info"></div>
				<div id="fps-info"></div>
				<div id="tiles-drawn-info"></div>
				<div id="objects-drawn-info"></div>
				<div id="particles-drawn-info"></div>
			</div>
		</div>
		
		<div id="ui-right">
			<div id="endgame-stats-wrapper" style="display: none; flex-direction: column; align-items: flex-end; gap: 0; ">
				<button id="endgame-stats-btn" style="width: 60px; margin: 0; pointer-events:auto;">Stats</button>
			</div>
			<div class="ui-panel ui-panel-controls">
				<div class="info-left" id="info-left" style="display:none">
					<div class="top-row" id="ui-right-top-row-id">
						
						<div class="info-item" title="Savings">
							<div class="input-group-icons">
								<div style="flex: 1;">
									<span id="player-savings" class="ui-number">0</span>
								</div>
								<div style="flex: 1;">
									<span class="poolinfo ui-savings"></span>
								</div>
							</div>
						</div>
						<div class="info-item" title="Income">
							<div class="input-group-icons">
								<div style="flex: 1;">
									<span id="player-income" class="ui-number">0</span>
								</div>
								<div style="flex: 1;">
									<span class="poolinfo ui-income"></span>
								</div>
							</div>
						</div>
						<div class="info-item" title="Wages">
							<div class="input-group-icons">
								<div style="flex: 1;">
									<span id="player-wages" class="ui-number">0</span>
								</div>
								<div style="flex: 1;">
									<span class="poolinfo ui-wages"></span>
								</div>
							</div>
						</div>
						<div class="info-item" title="Balance (savings+income-wages)">
							<div class="input-group-icons">
								<div style="flex: 1;">
									<span id="player-balance" class="ui-number">0</span>
								</div>
								<div style="flex: 1;">
									<span class="poolinfo ui-balance"></span>
								</div>
							</div>
						</div>
						
					</div>
				</div>
				<div class="info-right" id="info-right">
					<div class="button-row" id="ui-right-button-row1-id">
						<button id="sell-unit-btn" class="gamebutton" title="Sell warrior"></button>
						<button id="build-other-btn" class="gamebutton" title="Build item"></button>
						<button id="build-soldier-btn" class="gamebutton" title="Recruit warrior"></button>
						<button id="build-castle-btn" class="gamebutton" title="Build castle"></button>
						<button id="undo-btn" class="gamebutton redbutton" title="Undo"></button>
					</div>
					<div class="button-row" id="ui-right-button-row2-id">
						<button id="end-turn-btn" class="gamebutton primary" title="End turn"></button>
						<button id="previous-unit-btn" class="gamebutton" title="Previous unit"></button>
						<button id="next-unit-btn" class="gamebutton" title="Next unit"></button>
						
						<button id="game-settings-btn2" class="gamebutton" title="Settings"></button>
						<button id="quick-settings-btn" class="gamebutton" title="Settings" style="display:none"></button>
						<button id="toggle-ui-btn" class="gamebutton" title="Open chat"></button>
					</div>
				</div>
			</div>
		</div>
		
		
		
		<div id="ui-editor" style="display:none">
			<div class="ui-panel ui-panel-controls" style="border-top-left-radius: 0; border-bottom-left-radius: 10px;">
				
				<div class="info-editor" id="info-editor">
					<div class="button-row">
						<select id="editor-land-owner" style="padding: 0; height: 44px;">
							<option>No player</option>
							<option>PL1</option>
							<option>PL2</option>
							<option>PL3</option>
							<option>PL4</option>
							<option>PL5</option>
							<option>PL6</option>
						</select>
						
						<button id="editor-btn12" class="gamebutton" title="" style="background-color: #45723d">Land</button>
						<button id="editor-btn11" class="gamebutton primary" title="">Water</button>
						<button id="editor-btn13" class="gamebutton redbutton" title="">Cliff</button>
						
						<select id="editor-brush-size" style="padding: 0; height: 44px;">
							<option>Size</option>
							<option>1</option>
							<option>2</option>
							<option>3</option>
							<option>4</option>
							<option>5</option>
							<option>6</option>
							<option>12</option>
							<option>16</option>
							<option>32</option>
							<option>64</option>
							<option>128</option>
							<option>256</option>
							<option>512</option>
						</select>
					</div>
					<div class="button-row">
						<button id="editor-btn14" class="gamebutton" title="">Rock</button>
						<button id="editor-btn15" class="gamebutton" title="">Mine</button>
						<button id="editor-btn16" class="gamebutton" title="">Tree</button>
						
						<button id="editor-btn25" class="gamebutton btn-settings" title=""></button>
						<button id="editor-btn25" class="gamebutton" title="">Move</button>
				
					</div>
					<div class="button-row">
						<button id="editor-btn26" class="gamebutton" title="">Soldier</button>
						<select id="editor-soldier-type" style="padding: 0; height: 44px;">
							<option>Peasant</option>
							<option>Knight</option>
							<option>Horse</option>
							<option>Dragon</option>
						</select>
						<button id="editor-btn26" class="gamebutton" title="">Castle</button>
						<select id="editor-castle-type" style="padding: 0; height: 44px;">
							<option>Hut</option>
							<option>Castle</option>
							<option>Fortress</option>
						</select>
						<button id="editor-btn26" class="gamebutton" title="">Boat</button>
						
					</div>
				</div>
			</div>
		</div>
		
	</div>
	
	<div id="build-popup" class="ui-panel" style="display: none;">
		<div id="build-popup-title" class="smalltitle"></div>
		<div id="build-popup-list"></div>
		<button id="build-popup-close" class="redbutton">Cancel</button>
	</div>
</div>



<script>
"use strict";



// FireworksOverlay Class
// Creates a screen-space overlay for particle effects.
class FireworksOverlay {
    constructor() {
        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        // CSS to ensure it overlays the game but doesn't block clicks
        this.canvas.style.position = 'fixed';
        this.canvas.style.top = '0';
        this.canvas.style.left = '0';
        this.canvas.style.width = '100%';
        this.canvas.style.height = '100%';
        this.canvas.style.pointerEvents = 'none'; // Lets clicks pass through to game
        this.canvas.style.zIndex = '9999'; // Ensure it's on top
        
        document.body.appendChild(this.canvas);
        
        this.particles = [];
        this.fireworks = [];
        this.isRunning = false;
        
        // Bind resize to handle window changes
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    // Generate a random number within a range
    random(min, max) {
        return Math.random() * (max - min) + min;
    }

    // Create a new firework launching from bottom
    launchFirework() {
        const x = this.random(this.canvas.width * 0.1, this.canvas.width * 0.9);
        const targetY = this.random(this.canvas.height * 0.1, this.canvas.height * 0.4);
        
        // Hue determines color (0-360)
        const hue = this.random(0, 360);
        
        this.fireworks.push({
            x: x,
            y: this.canvas.height,
            sx: x, // start x
            sy: this.canvas.height, // start y
            tx: x, // target x (straight up for simplicity, can be angled)
            ty: targetY,
            distanceToTarget: this.canvas.height - targetY,
            distanceTraveled: 0,
            coordinates: [],
            angle: -Math.PI / 2,
            speed: 2,
            acceleration: 1.05,
            hue: hue,
            brightness: this.random(50, 70)
        });
    }

    createParticles(x, y, hue) {
        // Create an explosion of particles
        const particleCount = 100; // Increase for denser explosions
        for (let i = 0; i < particleCount; i++) {
            const angle = this.random(0, Math.PI * 2);
            const speed = this.random(10, 20);
            const friction = 0.95;
            const gravity = 1;

            this.particles.push({
                x: x,
                y: y,
                coordinates: [], // Store past positions for trails
                angle: angle,
                speed: speed,
                friction: friction,
                gravity: gravity,
                hue: hue + this.random(-20, 20), // Slight color variation
                brightness: this.random(50, 80),
                alpha: 1,
                decay: this.random(0.005, 0.01) // How fast they fade
            });
        }
    }

    update() {
        if (!this.isRunning) return;

        requestAnimationFrame(() => this.update());

        // Create trails effect
        // Instead of clearRect, we draw a semi-transparent black rect
        // This makes moving particles leave a trail behind them
        this.ctx.globalCompositeOperation = 'destination-out';
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Reset composite for drawing
        this.ctx.globalCompositeOperation = 'lighter';

        // 1. Logic to launch new fireworks randomly
        if (this.random(0, 100) < 5) { // 5% chance per frame
            this.launchFirework();
        }

        // 2. Update and Draw Fireworks (The rockets going up)
        let i = this.fireworks.length;
        while(i--) {
            const f = this.fireworks[i];
            
            this.ctx.beginPath();
            // Move to last coordinate or current position
            const prevX = f.coordinates.length > 0 ? f.coordinates[f.coordinates.length - 1][0] : f.x;
            const prevY = f.coordinates.length > 0 ? f.coordinates[f.coordinates.length - 1][1] : f.y;
            
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(f.x, f.y);
			this.ctx.lineWidth = 5;
            this.ctx.strokeStyle = `hsl(${f.hue}, 100%, ${f.brightness}%)`;
            this.ctx.stroke();

            // Track past coordinates
            f.coordinates.push([f.x, f.y]);
            if(f.coordinates.length > 3) f.coordinates.shift();

            // Physics
            f.speed *= f.acceleration;
            const vx = Math.cos(f.angle) * f.speed;
            const vy = Math.sin(f.angle) * f.speed;
            f.distanceTraveled = Math.sqrt(Math.pow(f.sx - f.x, 2) + Math.pow(f.sy - f.y, 2));

            // If reached target, explode
            if (f.distanceTraveled >= f.distanceToTarget) {
                this.createParticles(f.x, f.y, f.hue);
                this.fireworks.splice(i, 1);
            } else {
                f.x += vx;
                f.y += vy;
            }
        }

        // 3. Update and Draw Particles (The explosion)
        let j = this.particles.length;
        while(j--) {
            const p = this.particles[j];
            
            this.ctx.beginPath();
            // Move to last coordinate
            const prevX = p.coordinates.length > 0 ? p.coordinates[p.coordinates.length - 1][0] : p.x;
            const prevY = p.coordinates.length > 0 ? p.coordinates[p.coordinates.length - 1][1] : p.y;
            
            this.ctx.moveTo(prevX, prevY);
            this.ctx.lineTo(p.x, p.y);
            this.ctx.strokeStyle = `hsla(${p.hue}, 100%, ${p.brightness}%, ${p.alpha})`;
            this.ctx.stroke();

            p.coordinates.push([p.x, p.y]);
            if(p.coordinates.length > 5) p.coordinates.shift();

            // Physics
            p.speed *= p.friction;
            p.x += Math.cos(p.angle) * p.speed;
            p.y += Math.sin(p.angle) * p.speed + p.gravity;
            p.alpha -= p.decay;

            // Remove dead particles
            if (p.alpha <= p.decay) {
                this.particles.splice(j, 1);
            }
        }
    }

    start() {
        if (this.isRunning) return;
        this.isRunning = true;
        this.update();
    }

    stop() {
        this.isRunning = false;
        // Optional: Clear canvas immediately
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.fireworks = [];
        this.particles = [];
    }
}

// Initialize
const fireworks = new FireworksOverlay();





// for random function mulberry32()
function getRandomSeed(){
	const seedArray = new Uint32Array(1);
	crypto.getRandomValues(seedArray);
	return seedArray[0];
}

const RANDOM_SEED = getRandomSeed();
console.log("seed = "+RANDOM_SEED);


let CURRENT_PAGE = "start";
let popupOpen = false;

function mulberry32(seed) {
	return function() {
		seed |= 0;
		seed = seed + 0x6D2B79F5 | 0;
		let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
		t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
		return ((t ^ t >>> 14) >>> 0) / 4294967296;
	}
}


let randomFunc = mulberry32(RANDOM_SEED);

//const randomFunc = Math.random;

//const points = poissonDiskSampler(32, 32, 2, randomFunc);
//console.log(points);




let APP_NAME = "hexkings"; // needed to filter these games from open rooms list. minesweeper is also on same peerjs server.

let selectedServerIndex = 1; // default to render.com

// select local server if local server is forced in config:
if(window.APP_CONFIG.LOCAL == true){
	selectedServerIndex = 0;
}


// cache angle calculations:
const HEX_CORNERS = [];
for (let i = 0; i < 7; i++) { // 7 because i+1 is called, so it gets back to the first item.
	const angle = 2 * Math.PI / 6 * (i + 1); // +0.5 instead of +1 for pointy top
	HEX_CORNERS.push({
		x: Math.cos(angle),
		y: Math.sin(angle)
	});
}


// onlyLocal = only visible if window.APP_CONFIG.LOCAL = true
// serverlist
let serversList = [
	{name: "local", onlyLocal: true, serverListEnabled: true, 
		fetchUrl: "http://localhost:9000",
		config: {
			host: 'localhost',
			port: 9000,
			path: '/peerjs',
			secure: false,
			debug: 2,
	}}, // dont show this if testing locally.
	{name: "render.com", onlyLocal: false, serverListEnabled: true, 
		fetchUrl: "https://peerjs-server-j9al.onrender.com",
		config: {
			host: 'peerjs-server-j9al.onrender.com',
			path: '/peerjs',
			secure: true,
			debug: 2,
	}},
	{name: "peerjs.com", onlyLocal: false, serverListEnabled: false, config: {
		debug: 2
	}},
];


let eventSource = null;

function connectToServer(serverUrl) {
	// 1. Close existing EventSource if any
	if (eventSource) {
		eventSource.close(); // stops listening and frees resources
		console.log('Closed previous EventSource');
	}

	// 2. Create new EventSource
	eventSource = new EventSource(`${serverUrl}/events`);

	// 3. Listen for messages
	eventSource.onmessage = (event) => {
		if (event.data === 'games_updated') {
			console.log('Games updated â€” reloading list...');
			fetchOpenGames(selectedServerIndex); // or your own function
		}
	};

	eventSource.onerror = (err) => {
		console.error('EventSource error', err);
	};

	console.log('Connected to EventSource at', serverUrl);
}






const gamesListInput = document.getElementById("games-list-input");

gamesListInput.addEventListener("change", function() {
	const selectedValue = this.value;
	console.log("Selected game:", selectedValue);
	gameNameInput.value = selectedValue;
});


async function fetchOpenGames(serverIndex) {
	let server = serversList[serverIndex];

	if (!server.serverListEnabled) return;

	try {
		const res = await fetch(`${server.fetchUrl}/games`);

		// Check for HTTP errors (non-2xx responses)
		if (!res.ok) {
			throw new Error(`Server returned ${res.status} ${res.statusText}`);
		}

		const games = await res.json();
		let totalGames = 0;//Object.keys(games).length;
		for (const key in games) {
			if (games.hasOwnProperty(key)) {
				let appName = games[key].appName;
				// only display this game app rooms:
				if(appName === APP_NAME){
					totalGames++;
				}
			}
		}
		console.log('Open games:');
		console.log(games);

		// Clear existing options
		gamesListInput.innerHTML = '';

		// Add header option
		const defaultOption = document.createElement("option");
		defaultOption.value = "";
		defaultOption.textContent = `-- Select game (${totalGames}) --`;
		gamesListInput.appendChild(defaultOption);

		// Add each game
		for (const key in games) {
			if (games.hasOwnProperty(key)) {
				let gameName = games[key].name;
				let appName = games[key].appName;
				// only display this game app rooms:
				if(appName === APP_NAME){
					const option = document.createElement("option");
					option.value = gameName;
					option.textContent = gameName;
					gamesListInput.appendChild(option);
				}
			}
		}
	} catch (error) {
		console.error("Failed to fetch open games:", error);

		// If any error occurs, modify select list
		gamesListInput.innerHTML = '';

		const errorOption = document.createElement("option");
		errorOption.value = "";
		errorOption.textContent = "-- Server down --";
		gamesListInput.appendChild(errorOption);
	}
}






const serverNameInput = document.getElementById("server-name-input");
serverNameInput.value = selectedServerIndex;

serverNameInput.addEventListener("change", function() {
	const selectedValue = this.value;
	console.log("Selected server:", selectedValue);
	selectedServerIndex = selectedValue;
	
	let server = serversList[selectedServerIndex];
	if(server.serverListEnabled){
		connectToServer(server.fetchUrl);
		fetchOpenGames(selectedValue);
	}else{
		gamesListInput.innerHTML = '';
		const option = document.createElement("option");
		option.value = "";  // value attribute
		option.textContent = "-- Not available --";  // visible text
		gamesListInput.appendChild(option);
	}
});


function initServerOpen(){
	let server = serversList[selectedServerIndex];
	if(server.serverListEnabled){
		fetchOpenGames(selectedServerIndex);
		connectToServer(server.fetchUrl);
	}
}

initServerOpen();

serversList.forEach((server, index) => {
	// if onlyLocal is false or config local is true, then add line:
	if(!server.onlyLocal || window.APP_CONFIG.LOCAL){
		const option = document.createElement("option");
		option.value = index;  // value attribute
		option.textContent = server.name;  // visible text
		serverNameInput.appendChild(option);
	}
});


function getSelectedServer(){
	selectedServerIndex = parseInt(serverNameInput.value, 10);
	return serversList[selectedServerIndex];
}





function getLocalStorageItem(name){
	return localStorage.getItem(APP_NAME+"_"+name);
}
function setLocalStorageItem(name, value){
	return localStorage.setItem(APP_NAME+"_"+name, value);
}


const playerNameInput = document.getElementById('player-name');
const hostRoomPlayerNameInput = document.getElementById('host-room-player-name');
const lobbyPlayerNameInput = document.getElementById('lobby-player-name');

const randomNameBtn = document.getElementById('random-name-btn');

function giveRandomName(){
	playerNameInput.value = randomPlayerName();
}

// set random nick on first start:
playerNameInput.value = getLocalStorageItem("playerName") || randomPlayerName();



function isValidName(name){
	return (name.trim().length > 0);
}


// if player types own nick, it will remember it:
playerNameInput.addEventListener("input", () => {
	if(isValidName(playerNameInput.value)){
		setLocalStorageItem("playerName", playerNameInput.value.trim());
	}
});
hostRoomPlayerNameInput.addEventListener("input", () => {
	if(isValidName(hostRoomPlayerNameInput.value)){
		setLocalStorageItem("playerName", hostRoomPlayerNameInput.value.trim());
	}
});
lobbyPlayerNameInput.addEventListener("input", () => {
	if(isValidName(lobbyPlayerNameInput.value)){
		setLocalStorageItem("playerName", lobbyPlayerNameInput.value.trim());
	}
});






const popupOverlay = document.getElementById('map-popup-overlay');
const turnPopupOverlay = document.getElementById('turn-popup-overlay');


const popup = document.getElementById('map-popup');


const savedGamesPopupOverlay = document.getElementById('savedgames-popup-overlay');
const savedGamesPopup = document.getElementById('savedgames-popup');


const loadRandomBtn = document.getElementById('load-random-map-btn');
const closeBtn = document.getElementById('popup-close');


const savedGamesCloseBtn = document.getElementById('savedgames-popup-close');



const mapList = document.getElementById('map-list');
const savedGamesList = document.getElementById('savedgames-list');



const categoryBtns = document.querySelectorAll('.category-btn');
const loadedMapImg = document.getElementById('loaded-map');
const lobbyLoadedMapImg = document.getElementById('lobby-loaded-map');



// color picker:
const pickerPopup = document.getElementById('picker-popup');
const pickerPopupSelect = document.getElementById('picker-popup-select');
const pickerPopupCancel = document.getElementById('picker-popup-cancel');

const pickerWrapper = document.getElementById('picker-wrapper');



const picker = document.getElementById('picker');
const indicator = document.getElementById('indicator');
const lightnessSlider = document.getElementById('lightness');
//const preview = document.getElementById('preview');


//const hostCustomColorPicker = document.getElementById("host-custom-color-input");
//const lobbyCustomColorPicker = document.getElementById("lobby-custom-color-input");

const pickerPreviewTile = document.getElementById("picker-preview-tile");

const hostPreviewTile = document.getElementById("host-preview-tile");
const lobbyPreviewTile = document.getElementById("lobby-preview-tile");

const hostPreviewTileMsg = document.getElementById("host-preview-tile-msg");
const lobbyPreviewTileMsg = document.getElementById("lobby-preview-tile-msg");

let currentColor = "#FFFFFF";

pickerPopupSelect.addEventListener("click", () => {
	closeColorPicker();
	let color = currentColor;
	let textColor = getPlayerTextColor(color);
	updatePlayerColor(color, textColor);
	if(isHost()){
		updateHostPreviewTile(color);
	}else{
		updateLobbyPreviewTile(color);
	}
});


pickerPopupCancel.addEventListener("click", () => {
	closeColorPicker();
});


function closeColorPicker(){
	removePopupState(pickerPopup);
	
	pickerPopup.style.display = "none";
}


function launchColorPicker(){
	addPopupState(pickerPopup);
	
	let color = hexToRgb(getMyPlayer().color);
	let hsl = rgbToHsl(color[0], color[1], color[2]);
	hue = hsl.h;
	saturation = hsl.s;
	lightness = hsl.l;
	
	pickerPopup.style.display = "flex";
	
	// update colors/indicator AFTER popup is set visible:
	updateColorPreview();
	updateIndicator();
}

hostPreviewTile.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	launchColorPicker();
});

lobbyPreviewTile.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	launchColorPicker();
});



/*
hostCustomColorPicker.addEventListener('input', (e) => {
	console.log("Live color:", e.target.value);
	updateHostPreviewTile(e.target.value);
});
lobbyCustomColorPicker.addEventListener('input', (e) => {
	console.log("Live color:", e.target.value);
	updateLobbyPreviewTile(e.target.value);
});
*/

/*
hostCustomColorPicker.addEventListener('change', (e) => {
	console.log("Final color:", e.target.value);
	let color = e.target.value;
	let textColor = getPlayerTextColor(color);
	updatePlayerColor(color, textColor);
	updateHostPreviewTile(e.target.value);
});

lobbyCustomColorPicker.addEventListener('change', (e) => {
	console.log("Final color:", e.target.value);
	let color = e.target.value;
	let textColor = getPlayerTextColor(color);
	updatePlayerColor(color, textColor);
	updateLobbyPreviewTile(e.target.value);
});
*/











const imagePopup = document.getElementById('image-popup');
const popupImg = document.getElementById('popup-img');

const loadMapBtn = document.getElementById('load-map-btn');
const loadGameBtn = document.getElementById('load-game-btn');


function openMapPreviewPopup(){
	
	addPopupState(imagePopup);
	
	console.warn("openMapPreviewPopup");
	
	imagePopup.classList.add('active');
}

function closeMapPreviewPopup(){
	//console.warn("popupopen: ", popupOpen);
	removePopupState(imagePopup);
	
	imagePopup.classList.remove('active');
}

// Show popup on click
loadedMapImg.addEventListener('click', (e) => {
	e.preventDefault();
	console.warn("popupopen: ", popupOpen);
	popupImg.src = loadedMapImg.src;
	openMapPreviewPopup();
	console.warn("popupopen: ", popupOpen);
});

// Show popup on click
lobbyLoadedMapImg.addEventListener('click', (e) => {
	e.preventDefault();
	popupImg.src = lobbyLoadedMapImg.src;
	openMapPreviewPopup();
});

// Hide popup on click
imagePopup.addEventListener('click', (e) => {
	e.preventDefault();
	closeMapPreviewPopup();
});




const mapScale = document.getElementById('map-scale');




function loadRandomMap(){
	loadMap(((random(0,1) == 0) ? "normal" : "small"), random(0,39));
}

loadRandomBtn.addEventListener('click', () => {
	loadRandomMap();
});




function showTurnPopup(){
	turnPopupOverlay.style.display = 'block';
}
function hideTurnPopup(){
	// stop zooming:
	zoomingStartTime = 0;
	if(turnPopupOverlay.style.display !== 'none'){
		turnPopupOverlay.style.display = 'none';
	}
}




// Open popup
loadMapBtn.addEventListener('click', () => {
	popupOverlay.style.display = 'flex';
	renderMapList(currentCategory);
});

// Close popup (X or outside click)
closeBtn.addEventListener('click', closePopup);
	popupOverlay.addEventListener('click', (e) => {
	if (e.target === popupOverlay) closePopup();
});

function closePopup() {
	removePopupState(popup);
	
	popupOverlay.style.display = 'none';
}

// Render map list
async function renderMapList(category) {
	addPopupState(popup);
	
	mapList.innerHTML = '';
	
	if(category !== 'custom'){
		const maps = customMaps[category];

		maps.forEach((map, index) => {
			const div = document.createElement('div');
			div.className = 'map-item';
			div.innerHTML = `
				<img src="${map.imageData}" alt="${map.name}" title="${map.name}: ${map.width} x ${map.height}">
				<div>Land tiles: ${map.tileCount}</div>
			`;
			// <div>${map.width} x ${map.height}</div>
			div.addEventListener('click', () => {
				loadMap(category, index);
				console.log("map loaded: "+category+index);

				closePopup();
			});
			mapList.appendChild(div);
		});
	}else{
		let savedMaps = await getAllSavedMaps();
		
	}
}

// Handle category switching
categoryBtns.forEach(btn => {
	btn.addEventListener('click', () => {
		categoryBtns.forEach(b => b.classList.remove('active'));
		btn.classList.add('active');
		currentCategory = btn.dataset.category;
		renderMapList(currentCategory);
	});
});

  
  

// Open popup
loadGameBtn.addEventListener('click', async () => {
	if(loadedGameState){
		loadSavedGame(null); // will unload the saved game.
	}else{
		savedGamesPopupOverlay.style.display = 'flex';
		let savedGames = await getAllSavedGames();
		
		renderSavedGamesList(savedGames);
		
		
	}
});


// Close popup (X or outside click)
savedGamesCloseBtn.addEventListener('click', closeSavedGamesPopup);
savedGamesPopupOverlay.addEventListener('click', (e) => {
	if (e.target === savedGamesPopupOverlay) closeSavedGamesPopup();
});

function closeSavedGamesPopup() {
	removePopupState(savedGamesPopup);
	
	savedGamesPopupOverlay.style.display = 'none';
}

// Render map list
function renderSavedGamesList(savedGames) {
	addPopupState(savedGamesPopup);
	
	savedGamesList.innerHTML = '';

	for(let i = 0; i < savedGames.length; i++){
		let map = savedGames[i].gameState.map;
		let roomKey = getSaveRoomKey(savedGames[i].roomName);
		let date = formatReadableDate(savedGames[i].saveDate);
		
		let style = "";
		if(i == 0){
			style = "color:yellow; font-weight:bold";
		}

		const div = document.createElement('div');
		div.className = 'savedgames-item';
		div.innerHTML = `
			<img src="${map.imageData}" alt="${map.name}" title="${map.name}: ${map.width} x ${map.height}">
			<div style="${style}">${date}</div>
		`;
		div.addEventListener('click', () => {
			loadSavedGame(roomKey);
			console.log("game loaded: "+roomKey);

			closeSavedGamesPopup();
		});
		savedGamesList.appendChild(div);
	}
}



let useimages = 1;
let GS = 1.16; // hex texture size multi

const MIN_ZOOM = 0.05; // smaller value = more zoomed out
const MAX_ZOOM = 20;   // bigger value = more zoomed in
let zoomMipLevel = 0;


function delay(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}

function hexToHSL(hex) {
	// Remove '#' if present
	hex = hex.replace(/^#/, '');

	// Parse r, g, b values
	let bigint = parseInt(hex, 16);
	let r = (bigint >> 16) & 255;
	let g = (bigint >> 8) & 255;
	let b = bigint & 255;

	// Convert RGB to 0..1
	r /= 255;
	g /= 255;
	b /= 255;

	let max = Math.max(r, g, b);
	let min = Math.min(r, g, b);
	let h, s, l = (max + min) / 2;

	if (max === min) {
		h = s = 0; // achromatic
	} else {
		let d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r: h = (g - b) / d + (g < b ? 6 : 0); break;
			case g: h = (b - r) / d + 2; break;
			case b: h = (r - g) / d + 4; break;
		}
		h /= 6;
	}

	return {
		h: Math.round(h * 360), // 0 - 360 degrees
		s: parseFloat(s.toFixed(3)), // 0 - 1
		l: parseFloat(l.toFixed(3))  // 0 - 1
	};
}


let gameRules = {
	tileIncome: 1,
};

// sounds =
let gameSounds = {
	moveunit:     {filename: "sounds/down.mp3",    gain: 1,   filter: false},
	startmove:    {filename: "sounds/up.mp3",      gain: 1,   filter: false},
	info:         {filename: "sounds/info.mp3",    gain: 1,   filter: false},
	kill:         {filename: "sounds/kill.mp3",    gain: 1,   filter: false},
	//destroy:      {filename: "sounds/kill.mp3",    gain: 1,   filter: false},
	move:         {filename: "sounds/move.mp3",    gain: 0.4,   filter: false},
	protect:      {filename: "sounds/protect.mp3", gain: 0.2, filter: false},
	sea:          {filename: "sounds/sea.mp3",     gain: 1,   filter: false},
	
	// system sounds:
	victory:      {filename: "sounds/victory.mp3", gain: 0.15,   filter: false},
	defeat:       {filename: "sounds/defeat.mp3",  gain: 0.4,   filter: false},
	join:         {filename: "sounds/join.mp3",    gain: 0.6,   filter: false},
	quit:         {filename: "sounds/quit.mp3",    gain: 0.6,   filter: false},
	message:      {filename: "sounds/message.mp3", gain: 0.6,   filter: false},
	
	// need one sound per castle level so the explosion animation gets chosen correctly.
	build1:        {filename: "sounds/build.mp3",    gain: 0.4,   filter: false},
	build2:        {filename: "sounds/build.mp3",    gain: 0.4,   filter: false},
	build3:        {filename: "sounds/build.mp3",    gain: 0.4,   filter: false},

	sell:         {filename: "sounds/sell.mp3",    gain: 0.15,   filter: false},
	claimGrass:   {filename: "sounds/claim-grass.mp3",     gain: 0.4,   filter: false},
	claimTree:    {filename: "sounds/claim-tree.mp3",      gain: 0.1,   filter: false},
	claimRock:    {filename: "sounds/kill-castle-short.mp3",     gain: 0.2,   filter: false},
	claimMine:    {filename: "sounds/mine-explosion.mp3",     gain: 0.2,   filter: false},
	
	// used for: soldier kills castle.
	killCastle:   {filename: "sounds/kill-castle-short.mp3",     gain: 0.2,   filter: false},
	killBoat:     {filename: "sounds/mine-explosion.mp3",        gain: 0.2,   filter: false},
	
	// used for: knight kills peasant, horse kills knight.
	swordKill:    {filename: "sounds/sword-kill.mp3",      gain: 1,   filter: false},

	diedByStarving: {filename: "sounds/died-by-starving.mp3",  gain: 0.6,   filter: false},
};

/*
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const soundBuffers = {}; // store multiple decoded sounds

// Master buses
const musicGain = audioCtx.createGain();
musicGain.gain.value = 1.0;
musicGain.connect(audioCtx.destination);

const sfxGain = audioCtx.createGain();
sfxGain.gain.value = 1.0;
sfxGain.connect(audioCtx.destination);


async function preloadAllSounds() {
	const promises = Object.values(gameSounds).map(sound =>
		fetch(sound.filename)
			.then(res => res.arrayBuffer())
			.then(data => audioCtx.decodeAudioData(data))
			.then(decoded => {
				soundBuffers[sound.filename] = decoded;
			})
	);

	await Promise.all(promises);
	console.log("All sounds loaded");
}
preloadAllSounds().then(() => {
	console.log("All sounds loaded. Ready to play sounds");
});


function playSound(key) {
	const sound = gameSounds[key];
	if (!sound) {
		console.error("Sound not found:", key);
		return;
	}

	const buffer = soundBuffers[sound.filename];
	if (!buffer) return;

	const source = audioCtx.createBufferSource();
	source.buffer = buffer;

	// Per-instance gain (cheap)
	const gainNode = audioCtx.createGain();
	gainNode.gain.value = sound.gain ?? 1.0;

	let lastNode = source;

	// Optional per-instance filter
	if (sound.filter) {
		const filter = audioCtx.createBiquadFilter();
		filter.type = "lowpass";
		filter.frequency.value = sound.filterFrequency ?? 3000;
		lastNode.connect(filter);
		lastNode = filter;
	}

	lastNode.connect(gainNode);
	gainNode.connect(sfxGain);

	source.start();
}

*/



const musicPlaylist = [
	'music/game_test1_ver1.mp3',
	'music/game_test3_ver1.mp3',
	'music/game_test5_ver1.mp3',
	'music/Kate Z. - Tusker (Gurning 64 mix).mp3',
	'music/Kate Z. - Tusker (Into the Heart of Darkness Radio Edit).mp3',
	'music/tsr - Tusker - Desert track (tsr remix).mp3',
	'music/tsr - Tusker - Jungle track (tsr remix).mp3',
];

let musicMuted = getLocalStorageItem("musicMuted") === "true";



let musicVolumeInput2 = document.getElementById('music-volume2');

let currentTrackIndex = random(0, musicPlaylist.length-1);
let audio = null;
let isPaused = true;
let defaultMusicVolume = 0.04;
let maxMusicVolumeInputValue = 200; // volume input max value.
let musicVolumePower = 2.5; // power curve

let currentMusicVolume = defaultMusicVolume;

musicVolumeInput2.value = volumeToSlider(defaultMusicVolume, musicVolumeInput2);


function volumeToSlider(volume, slider) {
	const min = Number(slider.min) || 0;
	const max = Number(slider.max);

	const normalized = Math.pow(volume, 1 / musicVolumePower);

	return min + normalized * (max - min);
}

function sliderToVolume(slider) {
	const min = Number(slider.min) || 0;
	const max = Number(slider.max);

	const normalized = (slider.value - min) / (max - min);

	return Math.pow(normalized, musicVolumePower);
}


// used with other sliders as well to get better precision for lower values.
function valueToSlider(volume, slider) {
	return volumeToSlider(volume, slider);
}
function sliderToValue(slider) {
	return sliderToVolume(slider);
}



musicVolumeInput2.addEventListener('input', e => {
	let adjustedValue = sliderToVolume(e.target);
	setMusicVolume(adjustedValue);
});


function playMusic() {
	if (musicPlaylist.length === 0) return;
	
	if (!audio) {
		audio = new Audio(musicPlaylist[currentTrackIndex]);
		audio.volume = currentMusicVolume;
		audio.preload = 'auto';
		
		musicVolumeInput2.value = volumeToSlider(audio.volume, musicVolumeInput2);
		
		audio.addEventListener('ended', playNextTrack);
	}

	if (isPaused) {
		audio.play().catch(err => console.error(err));
		isPaused = false;
	}
}

function playNextTrack() {
	if (musicPlaylist.length === 0) return;
	if(!audio){
		playMusic();
	}
	currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;

	audio.src = musicPlaylist[currentTrackIndex];
	audio.load();
	audio.play();
	isPaused = false;
}

function playPreviousTrack() {
	if (musicPlaylist.length === 0) return;
	if(!audio){
		playMusic();
	}
	
	currentTrackIndex = (currentTrackIndex - 1 + musicPlaylist.length) % musicPlaylist.length;

	audio.src = musicPlaylist[currentTrackIndex];
	audio.load();
	audio.play();
	isPaused = false;
}



function pauseMusic() {
	if (audio && !isPaused) {
		audio.pause();
		isPaused = true;
	}
}


function restartMusic() {
	if (musicPlaylist.length === 0) return;
	currentTrackIndex = 0;
	
	if (!audio) return;
	audio.src = musicPlaylist[0];
	audio.load();
	audio.play();
	isPaused = false;
}

function randomTrack() {
	if (musicPlaylist.length === 0) return;
	currentTrackIndex = random(0, musicPlaylist.length-1);
	
	if (!audio) return;
	audio.src = musicPlaylist[currentTrackIndex];
	audio.load();
	audio.play();
	isPaused = false;
}

function setMusicVolume(value) {
	currentMusicVolume = Math.max(0, Math.min(1, value));
	if (audio) {
		audio.volume = currentMusicVolume;
	}
}





const soundContext = new (window.AudioContext || window.webkitAudioContext)();
const soundBuffers = {}; // store multiple decoded sounds




// Add gainNode (and optionally filterNode) to each sound object
for (const key in gameSounds) {
	const sound = gameSounds[key];
	sound.gainNode = soundContext.createGain();
	sound.gainNode.gain.value = sound.gain; // 1.0 = 100%, 0.5 = 50%, etc.
	sound.gainNode.connect(soundContext.destination);

	if (sound.filter) {
		const filter = soundContext.createBiquadFilter();
		filter.type = "lowpass";
		filter.frequency.value = 3000; // let only frequencies below ~3kHz pass
		filter.connect(sound.gainNode);
		sound.filterNode = filter;
	}
}

// Preload all sounds load sounds loadsounds
async function preloadAllSounds() {
	const promises = Object.values(gameSounds).map(sound =>
		fetch(sound.filename)
			.then(res => res.arrayBuffer())
			.then(data => soundContext.decodeAudioData(data))
			.then(decoded => {
				soundBuffers[sound.filename] = decoded;
			})
	);
	await Promise.all(promises);
}

preloadAllSounds().then(() => {
	console.log("All sounds loaded. Ready to play sounds");
});




// Play a sound
function playSound(key) {
	const sound = gameSounds[key];
	if (!sound) {
		console.warn("Sound not found:", key);
		return;
	}
	//console.warn("playSound: "+key);

	const buffer = soundBuffers[sound.filename];
	if (!buffer) return; // not loaded yet

	const source = soundContext.createBufferSource();
	source.buffer = buffer;

	// Connect to filterNode if it exists, otherwise to gainNode
	if (sound.filterNode) {
		source.connect(sound.filterNode); // use filter,
		sound.filterNode.connect(sound.gainNode); // then volume change. (doesnt matter in performance if gain is 1 always).
	} else {
		source.connect(sound.gainNode); // no filter, just volume effect.
	}

	source.start();
}




// --- Prevent default touch behavior for scrolling/zooming ---
document.body.addEventListener('touchstart', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });

document.body.addEventListener('touchmove', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });

document.body.addEventListener('touchend', e => {
	if (e.target.id === 'game-canvas') e.preventDefault();
}, { passive: false });



// --- CONSTANTS ---
const DB_NAME = 'HexWarlordsDB';
const DB_VERSION_NUMBER = 2;
const DB_STORE_NAME = 'savedGames';
const DB_STORE_NAME_MAPS = 'savedMaps';

const PLAYER_COLORS_ARR = [
	'#FF2222',
	'#FFFF00', 
	'#4444dd', 
	'#FF9500', 
	'#30B0C7', 
	'#339500',
	'#34C759', 
	'#FF2D55', 
	'#ff22dd', 
	'#A2845E', 
	'#eeeeee', 
	'#444444', 
];

// build player colors list with precomputed text colors:
let PLAYER_COLORS = [];
for(let i = 0; i < PLAYER_COLORS_ARR.length; i++){
	let color = PLAYER_COLORS_ARR[i];
	let textColor = getPlayerTextColor(color);
	PLAYER_COLORS.push({color:color, textColor:textColor});
}

function getPlayerTextColor(color){
	return lightenHexColor(color, 0.3);
}



function randomColor() {
	const h = Math.floor(randomFunc() * 360);
	const s = Math.floor(randomFunc() * 41) + 60; // 60â€“100%
	const l = Math.floor(randomFunc() * 51) + 50; // 50â€“100%

	// Convert HSL â†’ RGB â†’ HEX
	const a = s * Math.min(l / 100, 1 - l / 100) / 100;
	const f = n => {
		const k = (n + h / 30) % 12;
		const color = l / 100 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
		return Math.round(255 * color).toString(16).padStart(2, '0');
	};

	return `#${f(0)}${f(8)}${f(4)}`;
}


function getNextFreeColors(player = null){
	let usedColors = [];
	for(let i = 0; i < gameState.players.length; i++){
		let p = gameState.players[i];
		if(!player || p.id !== player.id){
			if(!p.quitted && !p.isSpectator){
				usedColors.push(p.color);
			}
		}
	}
	
	for(let i = 0; i < PLAYER_COLORS.length; i++){
		if(!usedColors.includes(PLAYER_COLORS[i].color)){
			return PLAYER_COLORS[i];
		}
	}
	console.log("random color returned");
	let newcolor = randomColor();
	return {color:newcolor, textColor:getPlayerTextColor(newcolor)};
}

function getNextFreeTextColor(player = null){
	return getNextFreeColors(player).textColor;
}

function getNextFreeColor(player = null){
	return getNextFreeColors(player).color;
}



function poissonDiskSampler(width, height, radii, rand) {
	if (!Array.isArray(radii)) {
		radii = [radii];
	}
	const k = 30; // attempts per active point
	const minRadius = Math.min(...radii);
	const cellSize = minRadius / Math.SQRT2;
	const gridWidth = Math.ceil(width / cellSize);
	const gridHeight = Math.ceil(height / cellSize);

	const grid = Array(gridWidth * gridHeight).fill(null);
	const active = [];
	const samples = [];

	function insert(p) {
		samples.push(p);
		const gx = Math.floor(p.x / cellSize);
		const gy = Math.floor(p.y / cellSize);
		grid[gy * gridWidth + gx] = p;
		active.push(p);
	}

	function distanceOk(p, radius) {
		const gx = Math.floor(p.x / cellSize);
		const gy = Math.floor(p.y / cellSize);
		for (let i = -2; i <= 2; i++) {
			for (let j = -2; j <= 2; j++) {
				const nx = gx + i, ny = gy + j;
				if (nx < 0 || ny < 0 || nx >= gridWidth || ny >= gridHeight) continue;
				const neighbor = grid[ny * gridWidth + nx];
				if (!neighbor) continue;
				const dx = neighbor.x - p.x;
				const dy = neighbor.y - p.y;
				if (dx*dx + dy*dy < radius*radius) return false;
			}
		}
		return true;
	}
	function pickRadius(radii, rand) {
		// simple example: weight smaller radius higher
		const weights = radii.map(r => 1/r); 
		const sum = weights.reduce((a,b)=>a+b,0);
		let x = rand()*sum;
		for (let i=0;i<radii.length;i++){
			if (x < weights[i]) return radii[i];
			x -= weights[i];
		}
		return radii[radii.length-1];
	}

	// first point
	insert({x: rand() * width, y: rand() * height, radius: radii[Math.floor(rand() * radii.length)]});

	while (active.length) {
		const idx = Math.floor(rand() * active.length);
		const point = active[idx];
		let found = false;

		for (let i = 0; i < k; i++) {
			const radius = pickRadius(radii, rand)*0.8;//radii[Math.floor(rand() * radii.length)];
			const a = 2 * Math.PI * rand();
			const r = radius * (1 + rand());
			const p = {x: point.x + r * Math.cos(a), y: point.y + r * Math.sin(a), radius};

			if (p.x < 0 || p.y < 0 || p.x >= width || p.y >= height) continue;
			if (distanceOk(p, radius)) {
				insert(p);
				found = true;
				break;
			}
		}

		if (!found) active.splice(idx, 1);
	}

	return samples;
}


// radii = [2,3,4] etc, uses random radius from that list.
function poissonDiskSampler1(width, height, radii, rand) {
	if (!Array.isArray(radii)) {
		radii = [radii];
	}

	const k = 30; // max attempts per active point
	//const cellSize = radius / Math.SQRT2;

	const cellSize = Math.min(...radii)/Math.SQRT2;
	const radius = radii[Math.floor(rand() * radii.length)];

	const gridWidth = Math.ceil(width / cellSize);
	const gridHeight = Math.ceil(height / cellSize);

	const grid = Array(gridWidth * gridHeight).fill(null);
	const active = [];
	const samples = [];

	function insert(p) {
		samples.push(p);
		const gx = Math.floor(p.x / cellSize);
		const gy = Math.floor(p.y / cellSize);
		grid[gy * gridWidth + gx] = p;
		active.push(p);
	}

	function distanceOk(p) {
		const gx = Math.floor(p.x / cellSize);
		const gy = Math.floor(p.y / cellSize);
		for (let i = -2; i <= 2; i++) {
			for (let j = -2; j <= 2; j++) {
				const nx = gx + i, ny = gy + j;
				if (nx < 0 || ny < 0 || nx >= gridWidth || ny >= gridHeight) continue;
				const neighbor = grid[ny * gridWidth + nx];
				if (!neighbor) continue;
				const dx = neighbor.x - p.x;
				const dy = neighbor.y - p.y;
				if (dx*dx + dy*dy < radius*radius) return false;
			}
		}
		return true;
	}

	insert({x: rand()*width, y: rand()*height});

	while (active.length) {
		const idx = Math.floor(rand() * active.length);
		const point = active[idx];
		let found = false;

		for (let i = 0; i < k; i++) {
			const a = 2 * Math.PI * rand();
			const r = radius * (1 + rand());
			const p = {x: point.x + r * Math.cos(a), y: point.y + r * Math.sin(a)};
			if (p.x < 0 || p.y < 0 || p.x >= width || p.y >= height) continue;
			if (distanceOk(p)) {
				insert(p);
				found = true;
				break;
			}
		}

		if (!found) active.splice(idx, 1);
	}

	return samples;
}







/////////////////////////////
// GLOBALS:





const SPECTATOR_COLOR = '#FFFFFF';
const UNCLAIMED_COLOR = '#555555';
const WATER_COLOR = '#003366';
const LAND_COLOR = '#224422'; // Unclaimed land
const HEX_SIZE = 40; // Radius of hexagon
const SQRT3 = Math.sqrt(3);

let HEX_LINE_MULTI = 0.958; // 3px wide. used to draw inside hex so the thick line wont get outside of hex.
let HEX_LINE_MULTI2 = 0.971; // 2px wide line.
let PULSE_SPEED = 0.005; // used for pulsating effects.

let NETWORK_HISTORY = []; // stores all network action messages and sounds. {updates, sounds}
let INITIAL_STATE = {}; // gameState during game start. used for replays.
let GAME_START_TIME = 0;
let REPLAY_ENABLED = 0;

let MAX_MESSAGE_LEN = 200;
let MAX_LOBBY_MESSAGE_LEN = 100;



// list of messages sent to clients:
// let action = let actions = const actions =
const ACTION = {
	// handleHostData: (client receives these)
	'ping': 100, 				// ACTION.ping
	'multiple_actions': 101, 	// ACTION.multiple_actions
	'game_start': 102, 			// ACTION.game_start
	'replay_start': 103, 		// ACTION.replay_start
	'full_state': 104, 			// ACTION.full_state
	'lobby_update': 105,		// ACTION.lobby_update
	'map_update': 106, 			// ACTION.map_update
	'system_message': 107, 		// ACTION.system_message
	'undo_counter': 108, 		// ACTION.undo_counter
	'tile_changed': 109, 		// ACTION.tile_changed
	'object_changed': 110, 		// ACTION.object_changed
	'unit_added': 111, 			// ACTION.unit_added
	'unit_removed': 112, 		// ACTION.unit_removed
	'player_killed': 113, 		// ACTION.player_killed
	'unit_move_reset': 114, 	// ACTION.unit_move_reset
	'unit_moved': 115, 			// ACTION.unit_moved
	'turn_changed': 116, 		// ACTION.turn_changed
	'sound': 117, 				// ACTION.sound
	'savings_update': 118, 		// ACTION.savings_update
	'start_game_check': 119,	// ACTION.start_game_check
	'unit_loaded': 120,			// ACTION.unit_loaded
	'unit_unloaded': 121,		// ACTION.unit_unloaded
	'unit_load_reset': 122,		// ACTION.unit_load_reset
	'tile_edited': 123,			// ACTION.tile_edited
	'settings_update': 124,		// ACTION.settings_update
	'player_changed': 125,		// ACTION.player_changed
	'game_over': 126,			// ACTION.game_over
	'player_kicked': 127,		// ACTION.player_kicked

	// handleClientData: (host receives these)
	'pong': 200, 				// ACTION.pong
	'join': 201, 				// ACTION.join
	'player_update': 202, 		// ACTION.player_update
	'host_quit': 203, 			// ACTION.host_quit
	'action_sell': 204, 		// ACTION.action_sell
	'action_move': 205, 		// ACTION.action_move
	'action_build': 206, 		// ACTION.action_build
	'action_undo': 207, 		// ACTION.action_undo
	'action_end_turn': 208, 	// ACTION.action_end_turn
	'action_build_object': 209, // ACTION.action_build_object
	'action_load_unit': 210,	// ACTION.action_load_unit
	'action_unload_unit': 211,	// ACTION.action_unload_unit
	'action_edit_tile': 212,	// ACTION.action_edit_tile
	
	// handleHostData & handleClientData:
	'check_balance': 300, 		// ACTION.check_balance
	'chat': 301, 				// ACTION.chat
	'lobby_chat': 302, 			// ACTION.lobby_chat
	
	
};




// compress some actions into smaller format:
// replay can read array or object format, so all actions doesnt have to be compressed.
function compressAction(data){
	switch(data.type){
		case ACTION.unit_moved: {
			if(data.wasUndo !== undefined){
				return [data.type, data._T, data.unitId, data.q, data.r, data.hasMoved, data.wasUndo];
			}else{
				return [data.type, data._T, data.unitId, data.q, data.r, data.hasMoved];
			}
		}
		break;
		case ACTION.turn_changed: {
			return [data.type, data._T, data.currentPlayerIndex, data.turnNumber];
		}
		break;
		case ACTION.sound: {
			return [data.type, data._T, data.name, data.q, data.r, data.playerIndex, data.action];
		}
		break;
		/*
		// removed for now since its getting more complex.
		case ACTION.tile_changed: {
			let FText = data.FText ?? 0;
			if(data.ownerIndex !== undefined && data.object !== undefined){
				return [data.type, data._T, data.q, data.r, FText, data.ownerIndex, data.object];
				
			}else if(data.ownerIndex !== undefined && data.object === undefined){
				return [data.type, data._T, data.q, data.r, FText, data.ownerIndex];
				
			}else if(data.ownerIndex === undefined && data.object !== undefined){
				return [data.type, data._T, data.q, data.r, FText, null, data.object];
				
			}else if(data.ownerIndex === undefined && data.object === undefined){
				return [data.type, data._T, data.q, data.r, FText];
			}
		}
		break;
		*/
		case ACTION.object_changed: {
			if(data.animationStyle !== undefined && data.object !== undefined){
				return [data.type, data._T, data.q, data.r, data.animationStyle, data.object];
				
			}else if(data.animationStyle !== undefined && data.object === undefined){
				return [data.type, data._T, data.q, data.r, data.animationStyle];
				
			}else if(data.animationStyle === undefined && data.object !== undefined){
				return [data.type, data._T, data.q, data.r, null, data.object];
				
			}else if(data.animationStyle === undefined && data.object === undefined){
				return [data.type, data._T, data.q, data.r];
				
			}
		}
		break;
		/*
		// removed since it doesnt have consistent parameters amounts
		case ACTION.unit_removed: {
			let FText = data.FText ?? 0;
			return [data.type, data._T, data.unitId, FText];
		}
		break;
		*/
	}
	return data; // no handler made yet, just return uncompressed format.
}



// decompress some actions into smaller format:
// replay can read array or object format.
function deCompressAction(arr){
	if(!Array.isArray(arr)){
		return arr; // already decompressed format (object).
	}
	// these are always the same for array format:
	let type = arr[0];
	let _T = arr[1];
	
	switch(type){
		case ACTION.unit_moved: {
			let base = {
				type: arr[0], 
				_T: arr[1], 
				unitId: arr[2], 
				q: arr[3], 
				r: arr[4], 
				hasMoved: arr[5],
			};
			if(arr[6] !== undefined){
				base.wasUndo = arr[6];
			}
			return base;
		}
		break;
		case ACTION.turn_changed: {
			return {
				type: arr[0], 
				_T: arr[1], 
				currentPlayerIndex: arr[2], 
				turnNumber: arr[3], 
			};
		}
		break;
		case ACTION.sound: {
			return {
				type: arr[0], 
				_T: arr[1], 
				name: arr[2], 
				q: arr[3], 
				r: arr[4], 
				playerIndex: arr[5], 
				action: arr[6], 
			};
		}
		break;
		/*
		// removed for now since its getting more complex.
		case ACTION.tile_changed: {
			let base = {
				type: arr[0], 
				_T: arr[1], 
				q: arr[2], 
				r: arr[3], 
				FText: arr[4], 
			};
			if(arr[5] !== undefined && arr[5] !== null){
				base.ownerIndex = arr[5];
			}
			if(arr[6] !== undefined){
				base.object = arr[6];
			}
			return base;
		}
		break;
		*/
		case ACTION.object_changed: {
			let base = {
				type: arr[0], 
				_T: arr[1], 
				q: arr[2], 
				r: arr[3], 
			};
			if(arr[4] !== undefined && arr[4] !== null){
				base.animationStyle = arr[4];
			}
			if(arr[5] !== undefined){
				base.object = arr[5];
			}
			return base;
		}
		break;
		/*
		// removed since it doesnt have consistent parameters amounts
		case ACTION.unit_removed: {
			return {
				type: arr[0], 
				_T: arr[1], 
				unitId: arr[2], 
				FText: arr[3], 
			};
		}
		break;
		*/
	}
	console.error("ERROR: no handler found in deCompressAction for action: ");
	console.error(arr);
}

function addNetworkHistory(data){
	if(REPLAY_ENABLED) return;
	if(getMyPlayer().isSpectator) return;
	
	// add timestamp for when the action was received, will make replays more realistic feeling.
	NETWORK_HISTORY.push(compressAction({
		...data, // {type: tile_changed, ...} etc.
		_T: msNowFloor()-GAME_START_TIME, // milliseconds from start of game.
	}));
}




let use_fill = 0;

// soldiers soldier_units 
// cost,wage,sell values checked from original gameplay.
const SOLDIER_DATA = {
	// listed in this order.
	// visibleName = text shown to user.
	// name = internal name, same as the key (maybe useful later).
	// defaultImage = imageAssets key for the unit image first animation frame (default image).
	"dragon":  { canMove: 1, frames: 2, visibleName: "Dragon",  name: "dragon",  type:"soldier", defaultImage: "soldier4", level: 4, cost: 40, wage: 54, sell: 20 },
	"horse":   { canMove: 1, frames: 2, visibleName: "Horse",   name: "horse",   type:"soldier", defaultImage: "soldier3", level: 3, cost: 30, wage: 18, sell: 15 },
	"knight":  { canMove: 1, frames: 2, visibleName: "Knight",  name: "knight",  type:"soldier", defaultImage: "soldier2", level: 2, cost: 20, wage: 8, sell: 10 },
	"peasant": { canMove: 1, frames: 2, visibleName: "Peasant", name: "peasant", type:"soldier", defaultImage: "soldier1", level: 1, cost: 10, wage: 3, sell: 5 },
};

// castles castle_units
// cost values checked from original gameplay.
const CASTLE_DATA = {
	// listed in this order.
	"fortress": { canMove: 0, frames: 1, visibleName: "Fortress",name: "fortress", type:"castle", defaultImage: "castle3", level: 3, cost: 200 },
	"castle":   { canMove: 0, frames: 1, visibleName: "Castle",  name: "castle",   type:"castle", defaultImage: "castle2", level: 2, cost: 40 },
	"hut":      { canMove: 0, frames: 1, visibleName: "Hut",     name: "hut",      type:"castle", defaultImage: "castle1", level: 1, cost: 10 },
};


const OTHER_UNITS_DATA = {
	// listed in this order.
	
	// need to think where would the wage be taken if the boat has wage... 
	// probably best if no wages and the unit can just "teleport" to the shore land from the ship.
	// also should probably have timer until the boat dies, so you cant stockpile units on the sea with boats
	// which would allow big army surprise attacks.
	// so maybe boats could live only for like 4 days until they explode and you lose the unit inside it.
	// boat units needs to have unit.cargo key set to describe what is inside it.
	// also when your unit moves to the boat, the unit.onBoat = boatUnitIndex should be set,
	// and that unit wont be rendered or affected at all. perhaps set q,r to -1 both.
	
	// so the plan is:
	// - soldier must be next to water and selected before building a boat.
	// - depending on unit cost, the boat cost = cost+20, so the costs are in order: 30, 40, 50, 60
	// - when you build the boat, the unit will instantly convert into a boat unit on the water tile.
	//   set unit.type = 'boat', unit.timer = 5, unit.hasMoved = true, unit.cargo = 'peasant' (building unit type) and q,r changes to the boat position.
	// - next turn you can move the boat for 5 hexes.
	// - you have 5 days time until the boat explodes (sinks).
	// - probably should have different image for different stages of timer, so it first loses its sail, and in the end looks almost sank.
	
	// unit.daysLeft = BOAT_MOVE_DAYS, explodes after 7 days.
	"sailboat": { canMove: 1, frames: 1, visibleName: "Sailboat", name: "sailboat", type:"boat", defaultImage: "sailboat1", level: 1, cost: 1, wage: 0, sell: 0 },
	
	//"cannon": { canMove: 1, frames: 1, visibleName: "Cannon", name: "cannon", type:"cannon", defaultImage: "cannon", level: 1, cost: 1, wage: 0, sell: 0 },
	
	"landmine": { canMove: 0, frames: 1, visibleName: "Landmine", name: "landmine", type:"mine", isObject: true, isInvisible: true, defaultImage: "landmine", level: 0, cost: 1, wage: 0, sell: 0 },
	
	// experimental, could buy airships that are kinda like boats but can fly anywhere.
	// should also explode after a time.
	// could unload the unit inside it to the ground, or make a kamikaze.
	// unit.cargo = 'peasant', unit.bombs = 1 (you could buy bomb optionally).
	//"airship":  { visibleName: "Airship", name: "airship", type:"airship", level: 1, cost: 40, wage: 0, sell: 0 },
	
	// experimental, could buy cannons that can be used to shoot enemy units.
	// each unit should have life for this to work, or make each bullet cost a lot, or make it imprecise.
	//"cannon":  { visibleName: "Cannon", name: "cannon", type:"cannon", level: 1, cost: 40, wage: 0, sell: 0 },
};


// todo: use this array instead of 2 separate arrays for soldiers and castles.
// let units = 
const UNITS = {
	ALL: {
		...SOLDIER_DATA,
		...CASTLE_DATA,
		...OTHER_UNITS_DATA, // disabled here for now or getCheapestCost wont work.
	},
	soldier: { // this should be unit type, which can be used directly as reference here.
		...SOLDIER_DATA
	},
	castle: {
		...CASTLE_DATA
	},
	other: {
		...OTHER_UNITS_DATA
	},
	object: {
		
	},
};


console.warn("UNITS");
console.warn(UNITS);


const EPSILON = 0.000001; // The margin of error for buying units etc.

let unitTypeIsObject = buildObjectsList(UNITS.ALL);
let unitTypeIsInvisibleObject = buildInvisibleObjectsList(UNITS.ALL);

// check if unitType is supposed to be object instead of unit. 
//   should use tile_changed message instead of unit_added.
function isUnitTypeObject(unitType){
	return unitTypeIsObject[unitType] ?? false;
}
function isUnitTypeInvisibleObject(unitType){
	return unitTypeIsInvisibleObject[unitType] ?? false;
}

// to know which buildable unit type is actually an object.
function buildObjectsList(data){
	let obj = {};
	for (const key in data) {
		const entry = data[key];
		if (entry.isObject) {
			obj[entry.name] = true;
		}
	}
	return obj;
}
function buildInvisibleObjectsList(data){
	let obj = {};
	for (const key in data) {
		const entry = data[key];
		if (entry.isObject && entry.isInvisible) {
			obj[entry.name] = true;
		}
	}
	return obj;
}

function getCheapestCost(data) {
	let cheapest = null;
	for (const key in data) {
		const entry = data[key];
		if (!cheapest || entry.cost < cheapest.cost) {
			cheapest = entry;
		}
	}
	return cheapest.cost;
}

// used to check if can afford any castle or soldier:
let minCastleCost = getCheapestCost(UNITS.castle);
let minSoldierCost = getCheapestCost(UNITS.soldier);
let minOtherCost = getCheapestCost(UNITS.other);



function canBuyAnything(totalSavings){
	for (const key in UNITS.ALL) {
		const entry = UNITS.ALL[key];
		if(totalSavings >= entry.cost) {
			return true;
		}
	}
	return false;
}

function unitTypeAnimationFramesCount(type){
	return getUnitInfo(type).frames;
}

function unitTypeCanMove(type){
	return getUnitInfo(type).canMove;
}

function unitCanBeSelected(unit){
	if(unitTypeCanMove(unit.type)){
		if(!unit.hasMoved && unit.ownerIndex === localPlayer.playerIndex){
			return true;
		}
	}
	return false;
}

function getUnitLevel(type){
	return getUnitInfo(type).level;
	//return CASTLE_DATA[type].level;
}


// --- GLOBAL STATE ---
let peer = null;
let myPeerId = null;
let hostPeerId = null;
let connections = new Map(); // key: peerId, value: DataConnection
let localPlayer = {
	id: null,
	playerIndex: -1,
	name: 'Player',
	color: "#888888", // debug color
	textColor: "#888888", // debug color
	isSpectator: false,
	isHost: false,
	isDead: false,
	disconnected: false, // true if player was timed out or quitted the game. if quitted is false, then its just timed out.
	quitted: false, // true if player intentionally quitted the game.
	isAI: false,
	undoCounter: 0, // will be updated in undo_counter message and used to determine if there are any undoing left.
	totalMines: 0, // how many mines can be built atm. will be set at startGame()
	totalBoats: 0, // how many boats can be built atm. will be set at startGame()
};

function gameStarted(){
	return gameState.settings.gameStarted;
}

function isHost(){
	return localPlayer.isHost;
}


let localPlayerPools = []; // economy pools for local player.

let db = null;
let loadedGameState = null;
let loadedGameStateInitial = null;

// rule constants:
const ENDRULE_NO_SOLDIERS_NO_MONEY = 0;
const ENDRULE_NO_SOLDIERS = 1;



// --- GAME STATE (synced by host) ---
let gameState = {
	settings: {
		gameStarted: false,
		gameOver: false,
		mapWidth: 50, // default input values for map generation on ui
		mapHeight: 50,
		mapScale: 1,
		startingMoney: 1000, // default 0 actually. for testing 1000.
		roomName: 'default-room',
		startPlayerId: -1, // -1 = random starting player.
		treePercent: 0.15,
		rockPercent: 0.05,
		minePercent: 0.05,
		gameEndRule: ENDRULE_NO_SOLDIERS_NO_MONEY,
		startMoneyPerHex: 0,
		mapTheme: 1, // 1 = summer, 2 = winter
		editorEnabled: 0,
		useBoats: true,
		useLandmines: true,
		initialMines: 4, // how many mines can be built at the start of game
		initialBoats: 2, // how many boats can be built at the start of game
		minesPerWeek: 2, // how many mines can be built at the start of game
		boatsPerWeek: 5, // how many boats can be built at the start of game
		maxMines: 10,
		maxBoats: 10,
		mineCost: 5,
		boatCost: 5,
	},
	players: [], // { id, name, color, isSpectator, isAI }

	map: { // Using axial coordinates (q, r)
		// tiles[`${q},${r}`] = { type: 'land'/'water', ownerId: null, object: 'tree'/'grass'/'dead'/null, savings: 0 }
		// these are initialized when map is generated:
		width: 0,
		height: 0,
		imageData: "",
		name: "",
		bounds: {},
		tiles: {}, 
		tilesData: [
			// {
			//   tileIndex: this tile array index
			//   neighbours: {tileIndex, neighbourIndex, q, r} neighbour tiles indexes that are not water.
			// }
		], 
	},
	units: [], // { id, type: 'Peasant', ownerId, level, q, r, hasMoved }
	turn: {
		currentPlayerIndex: 0,
		startPlayerIndex: 0,
		turnNumber: 1,
	},
	// Economy pools are calculated, not stored directly
};

// changeable render settings, in the settings popup:
let gameSettings = {
	drawShoresShading: true,
	drawWaterShading: true,
	drawLandShading: true,
	drawParticles: true,
	drawPoolEdges: true,
	drawPointers: true,
	drawWater: true,
	
	autosave: true,
	
	mapThemeOverride: 0, // 0 = no override, 1 = summer, 2 = winter
};



//clientSettings: {
//	mapThemeOverride: 0, // 0 = no override, 1 = summer, 2 = winter
//},


function resetGameState(){
	// TODO:
	// todo: causes weird bugs when the client player goes to start page and starts hosting his own room.
	
	// reset only required stuff, keep map intact so it can be reused.
	gameState.settings.gameStarted = false;
	gameState.settings.gameOver = false;
	gameState.players = [];
	gameState.units = [];
	gameState.turn.currentPlayerIndex = 0;
	gameState.turn.turnNumber = 1;
	
	// only reset map data that is generated on game start:
	gameState.map.bounds = {};
	gameState.map.tiles = {};
	gameState.map.tilesData = [];
	
	// reset only required stuff for the player:
	localPlayer.isSpectator = false;
	localPlayer.isHost = false;
	localPlayer.isDead = false;
	localPlayer.isAI = false;
}






function getPlayer(playerId) {
	return gameState.players.find(p => p.id === playerId);
}

function getPlayerByIndex(playerIndex) {
	// -1 is no-owner.
	if(playerIndex !== -1 && gameState.players[playerIndex]){
		return gameState.players[playerIndex];
	}else{
		return null;
	}
}

function getPlayerIndex(playerId) {
	// will return -1 if not found any.
	return gameState.players.findIndex(p => p.id === playerId);
}

function getPlayerId(playerIndex){
	if(playerIndex !== undefined && playerIndex !== -1){
		return gameState.players[playerIndex].id;
	}
	console.error("getPlayerId returned null: playerIndex '"+playerIndex+"' is invalid.");
	return null;
}


function getMyPlayer() {
	return getPlayer(localPlayer.id);
}


function getPlayerStats(playerIndex = -1){
	let stats = {
		hexes: 0,
		soldiers: 0,
		wages: 0,
		money: 0,
	};
	if(playerIndex === -1){
		playerIndex = getMyPlayer().playerIndex;
	}
	
	let pools = findEconomyPools(playerIndex);
	
	if(pools){
		for(let i = 0; i < pools.length; i++){
			let pool = pools[i];
			stats.hexes += pool.hexes.length;
			stats.soldiers += pool.soldiers.length;
			stats.wages += pool.totalWages;
			stats.money += pool.totalSavings;
		}
	}

	return stats;
}




function isSummer(){
	if(gameSettings.mapThemeOverride){
		return gameSettings.mapThemeOverride === 1;
	}
	return gameState.settings.mapTheme === 1; // gameState.settings.mapTheme === 'summer'
}

function getDirtTileName(){
	return isSummer() ? 'dirt' : 'snow';
}





let startMoneyPerHexInput = document.getElementById('start-money-per-hex');
startMoneyPerHexInput.value = gameState.settings.startMoneyPerHex;

startMoneyPerHexInput.addEventListener('change', e => {
	gameState.settings.startMoneyPerHex = Number(e.target.value);
	broadcastSettings();
});


/////////////
// unsynced setting for map theme change for localplayer
//
let mapThemeOverrideList = document.getElementById('map-theme-override');
let mapThemeOverrideWrapper = document.getElementById('map-theme-override-wrapper');


mapThemeOverrideList.value = gameSettings.mapThemeOverride;

mapThemeOverrideList.addEventListener('change', e => {
	gameSettings.mapThemeOverride = Number(e.target.value);
	
	updateSettingsImages();
});


/////////////
// synced setting for map theme for start of game:
//
let mapThemeList = document.getElementById('map-theme');
mapThemeList.value = gameState.settings.mapTheme;


function isStartPage(pageId){
	return pageId === "host" || pageId === "lobby";
}

function switchSettings(pageId){
	console.warn("switchSettings: "+pageId);
	
	if(isStartPage(pageId)){
		mapThemeOverrideWrapper.style.display = "none";
		console.warn("pThemeOverrideWrapper.style.display ");
		mapThemeList.disabled = false;
		
		// hide ingame buttons:
		document.querySelectorAll(".ingame-class").forEach(el => {
			el.classList.add("hidden");
		});
		
		// enable all settings inputs in game tab:
		document.querySelectorAll('.tab-game input, .tab-game select, .tab-game range').forEach(el => el.disabled = false);
	}
	if(pageId === 'lobby'){
		
		// disable all settings inputs in game tab:
		document.querySelectorAll('.tab-game input, .tab-game select, .tab-game range').forEach(el => el.disabled = true);
	}
	
	if(pageId === 'game'){
		mapThemeOverrideWrapper.style.display = "block";
		mapThemeList.disabled = true;
		
		// show ingame buttons:
		document.querySelectorAll(".ingame-class").forEach(el => {
			el.classList.remove("hidden");
		});
		
		// disable all settings inputs in game tab:
		document.querySelectorAll('.tab-game input, .tab-game select, .tab-game range').forEach(el => el.disabled = true);
	}
	
}



function updateSettingInputValue(id){
	let setting = settingsElems[id];
	let refArr = null;
	let refKey = null;
	
	// update input value from the gameState key:
	if(setting.gameStateKey !== undefined){
		refArr = gameState.settings;
		refKey = setting.gameStateKey;
	}else{
		refArr = gameSettings;
		refKey = setting.key;
	}

	if(setting.type === 'checkbox'){
		setting.elem.checked = refArr[refKey];
	}else if(setting.type === 'number'){
		setting.elem.value = Number(refArr[refKey]);
	}else{
		setting.elem.value = refArr[refKey];
	}
}



function updateSettingsInputs(){
	treePercentSlider.value = valueToSlider(gameState.settings.treePercent, treePercentSlider);
	rockPercentSlider.value = valueToSlider(gameState.settings.rockPercent, rockPercentSlider);
	minePercentSlider.value = valueToSlider(gameState.settings.minePercent, minePercentSlider);
	
	treePercentText.value = percent2Decimals(gameState.settings.treePercent)+"%";
	rockPercentText.value = percent2Decimals(gameState.settings.rockPercent)+"%";
	minePercentText.value = percent2Decimals(gameState.settings.minePercent)+"%";
	
	gameEndRuleList.value = gameState.settings.gameEndRule;
	
	mapThemeList.value = gameState.settings.mapTheme;
	updateSettingsImages();
	
	startMoneyPerHexInput.value = gameState.settings.startMoneyPerHex;
	
	// update all gameStateKey inputs in settingsElems:
	Object.keys(settingsElems).forEach(id => {
		let setting = settingsElems[id];	
		if(setting.gameStateKey !== undefined){
			updateSettingInputValue(id);
		}
	});
	
}

function updateSettingsImages(){
	document.querySelectorAll('.settings-image').forEach(el => {
		if(isSummer()){
			el.classList.remove('winter');
		}else{
			el.classList.add('winter');
		}
	});
}
mapThemeList.addEventListener('change', e => {
	gameState.settings.mapTheme = Number(e.target.value);
	
	updateSettingsImages();

	broadcastSettings();
});




let gameEndRuleList = document.getElementById('game-end-rule');
gameEndRuleList.value = gameState.settings.gameEndRule;
	
gameEndRuleList.addEventListener('change', e => {
	gameState.settings.gameEndRule = Number(e.target.value);

	broadcastSettings();
});


let treePercentSlider = document.getElementById('tree-percent');
let rockPercentSlider = document.getElementById('rock-percent');
let minePercentSlider = document.getElementById('mine-percent');

let treePercentText = document.getElementById('tree-percent-text');
let rockPercentText = document.getElementById('rock-percent-text');
let minePercentText = document.getElementById('mine-percent-text');


treePercentSlider.value = valueToSlider(gameState.settings.treePercent, treePercentSlider);
rockPercentSlider.value = valueToSlider(gameState.settings.rockPercent, rockPercentSlider);
minePercentSlider.value = valueToSlider(gameState.settings.minePercent, minePercentSlider);

treePercentText.value = percent2Decimals(gameState.settings.treePercent)+"%";
rockPercentText.value = percent2Decimals(gameState.settings.rockPercent)+"%";
minePercentText.value = percent2Decimals(gameState.settings.minePercent)+"%";




function percent2Decimals(val){
	return (Math.round(val*10000)/100);
}


treePercentSlider.addEventListener('change', e => {
	let adjustedValue = sliderToValue(e.target); // 0...1 value
	treePercentText.value = percent2Decimals(adjustedValue)+"%";
	
	gameState.settings.treePercent = adjustedValue;
	
	broadcastLobbyState();
});
rockPercentSlider.addEventListener('change', e => {
	let adjustedValue = sliderToValue(e.target); // 0...1 value
	rockPercentText.value = percent2Decimals(adjustedValue)+"%";
	
	gameState.settings.rockPercent = adjustedValue;
	
	broadcastLobbyState();
});
minePercentSlider.addEventListener('change', e => {
	let adjustedValue = sliderToValue(e.target); // 0...1 value
	minePercentText.value = percent2Decimals(adjustedValue)+"%";
	
	gameState.settings.minePercent = adjustedValue;
	
	broadcastLobbyState();
});

treePercentSlider.addEventListener('input', e => {
	let adjustedValue = sliderToValue(e.target); // 0...1 value
	treePercentText.value = percent2Decimals(adjustedValue)+"%";
});
rockPercentSlider.addEventListener('input', e => {
	let adjustedValue = sliderToValue(e.target); // 0...1 value
	rockPercentText.value = percent2Decimals(adjustedValue)+"%";
});
minePercentSlider.addEventListener('input', e => {
	let adjustedValue = sliderToValue(e.target); // 0...1 value
	minePercentText.value = percent2Decimals(adjustedValue)+"%";
});



// --- CLIENT-SIDE STATE (not synced) ---
let canvas, ctx;
let viewport = { x: 0, y: 0, zoom: 1, rotation: 0};
let dragStart = null;
let isDragging = false;
let selectedHex = null; // {q, r}
let focusedHex = null;
let focusedPoint = null;
let selectedUnit = null;
let placingUnit = null; // e.g., { type: 'Peasant', cost: 100 }
let currentTurnActions = []; // For undo
let actionForUndo = null;
let undoDisabled = false;

// prevents further undo after called.
function preventUndo(){
	undoDisabled = true;
	actionForUndo = null;
	currentTurnActions = [];
}

function deselectHex(){
	//console.log("deselectHex");
	selectedHex = null;
}
function deselectUnit(){
	//console.log("deselectUnit");
	selectedUnit = null;
	sellUnitBtn.disabled = true;
	updateHighlights(); // makes sure validSeaMoveHexes will not be set.
}

let shakingUnits = []; // { id, endTime }
let highlightedPool = []; // [{q, r}] for highlighting connected hexes
let enemyHighlightedPool = []; // [{q, r}] for highlighting connected hexes
let validMoveHexes = []; // [{q, r}] for green move highlight
let invalidMoveHexes = []; // [{q, r}] for red move highlight
let selectedPool = [];

let myCurrentSavings = 0; // Client-side savings








// --- IMAGE CACHING ---
let imageCache = {};
let imageAssets;


function buildImageName(unitInfo){
	return `${unitInfo.type}${unitInfo.level}`; // soldier1
}

function getImagePath(unitInfo){
	return imageAssets[unitInfo.defaultImage].path;
	//return imageAssets[buildImageName(unitData)].path;
}



let waterAnimData = {
	width: 416,
	height: 32,
	tileWidth: 32,
	tileHeight: 32,
	frames: [
		{"x":0,"y":0},{"x":32,"y":0},{"x":64,"y":0},{"x":96,"y":0},
		{"x":128,"y":0},{"x":160,"y":0},{"x":192,"y":0},{"x":224,"y":0},
		{"x":256,"y":0},{"x":288,"y":0},{"x":320,"y":0},{"x":352,"y":0},
		{"x":384,"y":0}
	]
};


let use_homm3 = 0;
let pathPrefix = "";
let unitScales = [];
let unitOffsets = [];
if(use_homm3){
	pathPrefix = "homm3";
	unitScales = [1.45, 1.6, 1.6,   2.6, 2.2, 2.2, 1.9];
	unitOffsets = [{x:0,y:0}, {x:0,y:0}, {x:0,y:0},   {x:0,y:5}, {x:0,y:5}, {x:0,y:2}, {x:0,y:2}];
}else{
	pathPrefix = "orig-scaled/128x128";
	unitScales = [1.8, 1.8, 1.8,   1.8, 1.8, 1.8, 1.8];
	unitOffsets = [{x:0,y:0}, {x:0,y:0}, {x:0,y:0},   {x:0,y:0}, {x:0,y:0}, {x:0,y:0}, {x:0,y:3}];
}

// host-texture-type select list values link to this array indexes.
let landTextures = ['land', 'land-c1', 'land-c2', 'land-c3', 'land-c4', 'land-c5', 'land-c6', 'land-c7', 'land-c8'];

// images =
imageAssets = {
	// for preloading images:
	'ui-sell':           {path:'images/ui/sell.png', isUi: true},
	'ui-undo':           {path:'images/ui/undo.png', isUi: true},
	'ui-endturn':        {path:'images/ui/endturn.png', isUi: true},
	'ui-chat':           {path:'images/ui/chat-settings.png', isUi: true},
	'ui-settings':       {path:'images/ui/settings-icon.png', isUi: true},
	'ui-music-previous': {path:'images/ui/music-previous.png', isUi: true},
	'ui-music-next':     {path:'images/ui/music-next.png', isUi: true},
	'ui-music-play':     {path:'images/ui/music-play.png', isUi: true},
	'ui-music-pause':    {path:'images/ui/music-pause.png', isUi: true},
	'ui-music-mute':    {path:'images/ui/music-mute.png', isUi: true},
	'ui-music-unmute':    {path:'images/ui/music-unmute.png', isUi: true},
	'ui-rotate-left':    {path:'images/ui/rotate-left.png', isUi: true},
	'ui-rotate-reset':   {path:'images/ui/rotate-reset.png', isUi: true},
	'ui-rotate-right':   {path:'images/ui/rotate-right.png', isUi: true},
	
	'ui-savings':   {path:'images/ui/savings.png', isUi: true},
	'ui-income':   {path:'images/ui/income.png', isUi: true},
	'ui-wages':   {path:'images/ui/wages.png', isUi: true},
	'ui-balance':   {path:'images/ui/balance.png', isUi: true},
	'ui-build':   {path:'images/ui/build.png', isUi: true},
	
	'ui-logo':   {path:'images/logo256_2.png', isUi: true},


	// ingame graphics:
	'infinitewater': {path:'images/water.jpg', scale:1, offsetX: 0, isPattern: true},
	'water-anim': {path:'images/water-anim.png', scale:1, offsetX: 0, isPattern: true, isAnimated: true, animationData: waterAnimData},
	'water-anim-big': {path:'images/water-anim.png', isPattern: true, isAnimated: true, animationData: waterAnimData, isBigAnim: true},
	
	
	'land':     {path:'images/land2b2b.jpg', scale:1, offsetX: 0}, 
	'land-dead':{path:'images/land2b2b-dead.jpg', scale:1, offsetX: 0}, 
	'land-c1':  {path:'images/land-c1.jpg', scale:1, offsetX: 0}, 
	'land-c2':  {path:'images/land-c2.jpg', scale:1, offsetX: 0}, 
	'land-c3':  {path:'images/land-c3.jpg', scale:1, offsetX: 0}, 
	'land-c4':  {path:'images/land-c4.jpg', scale:1, offsetX: 0}, 
	'land-c5':  {path:'images/land-c5.jpg', scale:1, offsetX: 0}, 
	'land-c6':  {path:'images/land-c6.jpg', scale:1, offsetX: 0}, 
	'land-c7':  {path:'images/land-c7.jpg', scale:1, offsetX: 0}, 
	'land-c8':  {path:'images/land-c8.jpg', scale:1, offsetX: 0}, 
	// NOTE: must update landTextures array if new textures added.
	
	'dirt':     {path:'images/dirt2.jpg', scale:1, offsetX: 0},
	'snow':     {path:'images/snow.jpg', scale:1, offsetX: 0},
	'cliff':    {path:'images/cliff2.jpg', scale:1, offsetX: 0},
	'water':    {path:'images/water.jpg', scale:1, offsetX: 0},
	
	'dead':     {path:'images/orig-scaled/128x128/dead.png', scale:2, offsetX: 0},
	'grass':    {path:'images/orig-scaled/128x128/grass.png', scale:2, offsetX: -2, offsetY: -2},
	'tree':     {path:'images/orig-scaled/128x128/tree.png', scale:2, offsetX: -2, offsetY: -2},
	'rock2':    {path:'images/orig-scaled/128x128/rock2c.png', scale:1.8, offsetX: 0, offsetY: -3},
	'mine1':    {path:'images/orig-scaled/128x128/mine1.png', scale:1.8, offsetX: 0, offsetY: -10},
	
	
	'dead-winter':     {path:'images/orig-scaled/128x128/dead.png', scale:2, offsetX: 0},
	'grass-winter':    {path:'images/orig-scaled/128x128/winter/grass.png', scale:2, offsetX: -2, offsetY: -2},
	'tree-winter':     {path:'images/orig-scaled/128x128/winter/tree.png', scale:2, offsetX: -2, offsetY: -2},
	'rock-winter':     {path:'images/orig-scaled/128x128/winter/rock.png', scale:1.8, offsetX: 0, offsetY: -3},
	'mine-winter':     {path:'images/orig-scaled/128x128/winter/mine.png', scale:1.8, offsetX: 0, offsetY: -10},
	'landmine-winter': {path:'images/'+pathPrefix+'/winter/landmine.png', scale:1.8, offsetX: 0, offsetY: -10},
	
	'castle1-winter':  {path:'images/'+pathPrefix+'/winter/castle1.png', scale: unitScales[0], offsetX: unitOffsets[0].x, offsetY: unitOffsets[0].y},
	'castle2-winter':  {path:'images/'+pathPrefix+'/winter/castle2.png', scale: unitScales[1], offsetX: unitOffsets[1].x, offsetY: unitOffsets[1].y},
	'castle3-winter':  {path:'images/'+pathPrefix+'/winter/castle3.png', scale: unitScales[2], offsetX: unitOffsets[2].x, offsetY: unitOffsets[2].y},
	
	
	'protect':  {path:'images/orig-scaled/128x128/protect.png', scale:1.6, offsetX: 0},
	'select':   {path:'images/orig-scaled/128x128/select.png', scale:1, offsetX: 0},
	

	'castle1':  {path:'images/'+pathPrefix+'/castle1.png', scale: unitScales[0], offsetX: unitOffsets[0].x, offsetY: unitOffsets[0].y},
	'castle2':  {path:'images/'+pathPrefix+'/castle2.png', scale: unitScales[1], offsetX: unitOffsets[1].x, offsetY: unitOffsets[1].y},
	'castle3':  {path:'images/'+pathPrefix+'/castle3.png', scale: unitScales[2], offsetX: unitOffsets[2].x, offsetY: unitOffsets[2].y},
	
	'soldier1': {path:'images/'+pathPrefix+'/soldier1.png', scale: unitScales[3], offsetX: unitOffsets[3].x, offsetY: unitOffsets[3].y},
	'soldier2': {path:'images/'+pathPrefix+'/soldier2.png', scale: unitScales[4], offsetX: unitOffsets[4].x, offsetY: unitOffsets[4].y},
	'soldier3': {path:'images/'+pathPrefix+'/soldier3.png', scale: unitScales[5], offsetX: unitOffsets[5].x, offsetY: unitOffsets[5].y},
	'soldier4': {path:'images/'+pathPrefix+'/soldier4.png', scale: unitScales[6], offsetX: unitOffsets[6].x, offsetY: unitOffsets[6].y},
	
	// "-1" = second frame. could add more frames later.
	'soldier1-1': {path:'images/'+pathPrefix+'/soldier1-1.png', scale: unitScales[3], offsetX: unitOffsets[3].x, offsetY: unitOffsets[3].y},
	'soldier2-1': {path:'images/'+pathPrefix+'/soldier2-1.png', scale: unitScales[4], offsetX: unitOffsets[4].x, offsetY: unitOffsets[4].y},
	'soldier3-1': {path:'images/'+pathPrefix+'/soldier3-1.png', scale: unitScales[5], offsetX: unitOffsets[5].x, offsetY: unitOffsets[5].y},
	'soldier4-1': {path:'images/'+pathPrefix+'/soldier4-1.png', scale: unitScales[6], offsetX: unitOffsets[6].x, offsetY: unitOffsets[6].y},
	
	'sailboat1':  {path:'images/'+pathPrefix+'/sailboat.png', scale: unitScales[6], offsetX: 0, offsetY: -4},
	'landmine':   {path:'images/'+pathPrefix+'/landmine1.png', scale:1.8, offsetX: 0, offsetY: -10},
	'cannon':     {path:'images/'+pathPrefix+'/cannon.png', scale: 1.5, offsetX: 0, offsetY: -4},

	
	//'castle1':  {path:'images/orig-scaled/128x128/castle1.png', scale:1.8, offsetX: 0},
	//'castle2':  {path:'images/orig-scaled/128x128/castle2.png', scale:1.8, offsetX: 0},
	//'castle3':  {path:'images/orig-scaled/128x128/castle3.png', scale:1.8, offsetX: 0},
	//'soldier1': {path:'images/orig-scaled/128x128/soldier1.png', scale:1.8, offsetX: 0},
	//'soldier2': {path:'images/orig-scaled/128x128/soldier2.png', scale:1.8, offsetX: 0},
	//'soldier3': {path:'images/orig-scaled/128x128/soldier3.png', scale:1.8, offsetX: 0},
	//'soldier4': {path:'images/orig-scaled/128x128/soldier4.png', scale:1.8, offsetX: 0, offsetY: 3},
};
if(use_fill){
	imageAssets['dirt'] = {path:'images/dirt3.png', scale:1, offsetX: 0, isPattern: true};
}






//////////////////////////////
// color picker:


let hue = 0;
let saturation = 100;
let lightness = 50;

function updateColorPreview() {
	const [r, g, b] = hslToRgb(hue, saturation, lightness);
	currentColor = rgbToHex(r, g, b);
	//preview.style.backgroundColor = rgbToHex(r, g, b);
	updatePickerPreviewTile(currentColor);
}



function rgbToHsl(r, g, b) {
	// Normalize r, g, b to [0, 1]
	r /= 255;
	g /= 255;
	b /= 255;

	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const delta = max - min;

	let h = 0, s = 0, l = (max + min) / 2;

	if (delta !== 0) {
		s = delta / (1 - Math.abs(2 * l - 1));

		switch(max) {
			case r:
				h = ((g - b) / delta) % 6;
				break;
			case g:
				h = ((b - r) / delta) + 2;
				break;
			case b:
				h = ((r - g) / delta) + 4;
				break;
		}

		h *= 60;
		if (h < 0) h += 360;
	}

	return { 
		h: Math.round(h), 
		s: +(s * 100).toFixed(1), 
		l: +(l * 100).toFixed(1) 
	};
}


function hslToRgb(h, s, l) {
	s /= 100;
	l /= 100;
	const k = n => (n + h / 30) % 12;
	const a = s * Math.min(l, 1 - l);
	const f = n => l - a * Math.max(Math.min(k(n) - 3, 9 - k(n), 1), -1);
	return [Math.round(f(0)*255), Math.round(f(8)*255), Math.round(f(4)*255)];
}

function updateIndicator(){
	const rect = picker.getBoundingClientRect();
	
	let x = (hue/360)*rect.width;
	let y = ((100-saturation)/100)*rect.height;
	
	indicator.style.left = `${x}px`;
	indicator.style.top = `${y}px`;
	
	console.log(lightness);
	
	lightnessSlider.value = lightness;
}

function getPoint(e) {
	if (e.touches && e.touches.length) {
		return {
			x: e.touches[0].clientX,
			y: e.touches[0].clientY
		};
	}

	return {
		x: e.clientX,
		y: e.clientY
	};
}
function handlePointer(e) {
	const rect = picker.getBoundingClientRect();
	const { x, y } = getPoint(e);

	const px = Math.min(Math.max(x - rect.left, 0), rect.width);
	const py = Math.min(Math.max(y - rect.top, 0), rect.height);

	hue = (px / rect.width) * 360;
	saturation = 100 - (py / rect.height) * 100;

	indicator.style.left = `${px}px`;
	indicator.style.top = `${py}px`;

	updateColorPreview();
}

function handlePointer1(e) {
	const rect = picker.getBoundingClientRect();
	const x = Math.min(Math.max((e.clientX || e.touches[0].clientX) - rect.left, 0), rect.width);
	const y = Math.min(Math.max((e.clientY || e.touches[0].clientY) - rect.top, 0), rect.height);

	hue = (x / rect.width) * 360;
	saturation = 100 - (y / rect.height) * 100;

	indicator.style.left = `${x}px`;
	indicator.style.top = `${y}px`;

	updateColorPreview();
}

picker.addEventListener('mousedown', e => {
	handlePointer(e);
	const moveHandler = e => handlePointer(e);
	const upHandler = () => {
		window.removeEventListener('mousemove', moveHandler);
		window.removeEventListener('mouseup', upHandler);
	};
	window.addEventListener('mousemove', moveHandler);
	window.addEventListener('mouseup', upHandler);
});

picker.addEventListener('touchstart', e => {
	e.preventDefault();
	handlePointer(e);
	const moveHandler = e => handlePointer(e);
	const endHandler = () => {
		window.removeEventListener('touchmove', moveHandler);
		window.removeEventListener('touchend', endHandler);
	};
	window.addEventListener('touchmove', moveHandler);
	window.addEventListener('touchend', endHandler);
});

lightnessSlider.addEventListener('input', e => {
	lightness = e.target.value; // 0-100
	updateColorPreview();
});



function updatePickerPreviewTile(color){
	let textureType = landTextures[getMyPlayer().textureType ?? 0];
	createHexagonMaskedImage(getImage(textureType), HEX_SIZE, 1, pickerPreviewTile, color);
}

function updateHostPreviewTile(color){
	let textureType = landTextures[getMyPlayer().textureType ?? 0];
	createHexagonMaskedImage(getImage(textureType), HEX_SIZE, 1, hostPreviewTile, color);
}
function updateLobbyPreviewTile(color){
	let textureType = landTextures[getMyPlayer().textureType ?? 0];
	createHexagonMaskedImage(getImage(textureType), HEX_SIZE, 1, lobbyPreviewTile, color);
}




// * Creates a new transparent canvas element containing a source image
// * clipped into a centered, anti-aliased hexagonal shape.
// *
// * @param {HTMLImageElement | HTMLCanvasElement} sourceImage - The original rectangular texture.
// * @param {number} hexSize - The radius of the hexagon in pixels (e.g., 120).
// * @param {number} textureScale - A multiplier to scale the source image (e.g., 1.0 for original size).
// * @returns {HTMLCanvasElement} - A new canvas element with the masked hexagon image.
function createHexagonMaskedImage(sourceImage, hexSize, textureScale = 1.0, canvasElem = null, color = null) {
	let canvasOut;
	if(canvasElem){
		canvasOut = canvasElem;
	}else{
		canvasOut = document.createElement('canvas');
	}

	// FIX 1: Canvas is fixed at 256x256
	const canvasSize = 256;
	// The radius of the hexagon MUST be 128 (half of the canvas size) to fill it
	const CANVAS_RADIUS = canvasSize/2; 

	canvasOut.width = canvasSize;
	canvasOut.height = canvasSize;
	const ctxOut = canvasOut.getContext('2d');

	// Clear the canvas if reusing it.
	ctxOut.clearRect(0, 0, canvasSize, canvasSize);

	// The center point of the new canvas (always 128)
	const center = CANVAS_RADIUS; 

	// Calculate source image draw dimensions
	const drawWidth = sourceImage.width * textureScale;
	const drawHeight = sourceImage.height * textureScale;

	// Calculate top-left corner (to center the scaled image on the 256x256 canvas)
	const drawX = center - (drawWidth / 2);
	const drawY = center - (drawHeight / 2);

	// FIX 2: Hexagon drawing coordinates must use the CANVAS_RADIUS (128)
	let px = center; // Center X for the hexagon path (128)
	let py = center; // Center Y for the hexagon path (128)
	const padding = 0; 

	// FIX 3: The radius 'r' for the path must be CANVAS_RADIUS (128)
	const r = CANVAS_RADIUS + padding; 

	ctxOut.save();

	// --- 4. Define the Hexagonal Clipping Path using fixed CANVAS_RADIUS ---
	ctxOut.beginPath();
	// Path points are calculated relative to the canvas center (px, py)
	ctxOut.moveTo(px + r * HEX_CORNERS[0].x, py + r * HEX_CORNERS[0].y);
	ctxOut.lineTo(px + r * HEX_CORNERS[1].x, py + r * HEX_CORNERS[1].y);
	ctxOut.lineTo(px + r * HEX_CORNERS[2].x, py + r * HEX_CORNERS[2].y);
	ctxOut.lineTo(px + r * HEX_CORNERS[3].x, py + r * HEX_CORNERS[3].y);
	ctxOut.lineTo(px + r * HEX_CORNERS[4].x, py + r * HEX_CORNERS[4].y);
	ctxOut.lineTo(px + r * HEX_CORNERS[5].x, py + r * HEX_CORNERS[5].y);
	ctxOut.closePath();

	ctxOut.clip(); // Apply the clip

	// --- 5. Draw the Scaled Source Image (Clipped) ---
	ctxOut.drawImage(
		sourceImage,
		drawX,
		drawY,
		drawWidth,
		drawHeight
	);

	// --- 6. Apply Color Multiplication (If specified) ---
	if(color){
		ctxOut.globalCompositeOperation = "multiply";
		ctxOut.fillStyle = color;
		ctxOut.fillRect(0, 0, canvasSize, canvasSize);
	}

	// --- 7. Restore context and reset composite operation ---
	ctxOut.globalCompositeOperation = 'source-over';
	ctxOut.restore();

	return canvasOut;
}




// draws ">" triangle where the pointy right side is the x y coordinate.
function drawRightTriangle(ctx, x, y, height, width) {
	const hh = height / 2;

	ctx.beginPath();
	
	ctx.moveTo(x-width, y-hh);                 // Top-left
	ctx.lineTo(x-width, y-hh + height);        // Bottom-left
	ctx.moveTo(x-width, y-hh);                 // Back to top-left
	ctx.lineTo(x, y);  // Top to center-right
	ctx.moveTo(x-width, y-hh + height);        // Bottom-left
	ctx.lineTo(x, y);  // Bottom to center-right

	ctx.strokeStyle = 'yellow';
	ctx.lineWidth = 2.5;
	ctx.lineCap = 'round';
	ctx.stroke();
}


// direction = 0,1,2,3 = to right, to bottom, to left, to up
function drawTriangle(ctx, x, y, angle = 0){
	let scale = 0.45;
	let h = 76;
	let w = h/2;
	drawTriangleAtAngle(ctx, x-HEX_SIZE/2, y+HEX_SIZE/3, h*scale, w*scale, angle);
}


function drawEdgeTriangle(ctx, x, y, angleDeg) {
	let scale = 0.45;
	let h = 76;
	let w = h / 2;

	// Pulse distance along the pointing direction
	// 2 = line width, so it will hit the edge without going outside of it and be cut.
	// 20 = unit triangle pulse distance.
	//let pulse = pulseScale(2, 20, PULSE_SPEED);
	let pulse = 2; // disable for now. 2px distance from edge so the line wont be cut.

	// Convert angle to radians
	let angleRad = angleDeg * (Math.PI / 180);

	// Offset x and y by pulse along the angle
	let offsetX = Math.cos(angleRad) * pulse;
	let offsetY = Math.sin(angleRad) * pulse;

	// Draw the triangle shifted by the pulse
	drawTriangleAtAngle(ctx, x - offsetX, y - offsetY, h * scale, w * scale, angleDeg);
}



function drawTriangleAtAngle(ctx, x, y, height, width, angleDeg = 0) {
	const h2 = height / 2;
	const angle = angleDeg * (Math.PI / 180);

	// Base triangle pointing RIGHT
	const points = [
		{ x: 0,       y: 0 },       // tip
		{ x: -width,  y: -h2 },     // top base corner
		{ x: -width,  y:  h2 }      // bottom base corner
	];

	const cosA = Math.cos(angle);
	const sinA = Math.sin(angle);

	// Rotate & translate points
	const rotated = points.map(p => ({
		x: x + (p.x * cosA - p.y * sinA),
		y: y + (p.x * sinA + p.y * cosA)
	}));

	ctx.beginPath();
	ctx.moveTo(rotated[0].x, rotated[0].y);
	ctx.lineTo(rotated[1].x, rotated[1].y);
	ctx.lineTo(rotated[2].x, rotated[2].y);
	ctx.closePath();

	ctx.strokeStyle = 'yellow';
	ctx.lineWidth = 2.5;
	ctx.lineCap = 'round';
	ctx.stroke();
}





async function load8BitBMP(url) {
	const buffer = await (await fetch(url)).arrayBuffer();
	const dv = new DataView(buffer);

	const pixelDataOffset = dv.getUint32(10, true);
	const width = dv.getInt32(18, true);
	const height = dv.getInt32(22, true);
	const bitsPerPixel = dv.getUint16(28, true);
	const paletteCount = dv.getUint32(46, true) || 256;

	if (bitsPerPixel !== 8) throw new Error("Only 8-bit BMPs supported");

	// Read palette (B,G,R,0)
	const palette = [];
	for (let i = 0; i < paletteCount; i++) {
		const b = dv.getUint8(54 + i * 4 + 0);
		const g = dv.getUint8(54 + i * 4 + 1);
		const r = dv.getUint8(54 + i * 4 + 2);
		palette.push([r, g, b]);
	}

	// Read pixel indices (bottom-up rows, 4-byte aligned)
	const pixels = new Uint8Array(width * height);
	const rowSize = Math.ceil(width / 4) * 4;
	let offset = pixelDataOffset;
	for (let y = height - 1; y >= 0; y--) {
		for (let x = 0; x < width; x++) {
			pixels[y * width + x] = dv.getUint8(offset++);
		}
		offset = pixelDataOffset + (height - 1 - y + 1) * rowSize;
	}

	return { width, height, palette, pixels };
}



function getCroppedBMP(bmp, dx, dy, width, height) {
	const { width: srcW, height: srcH, pixels, palette } = bmp;

	// Ensure crop stays inside the image bounds
	dx = Math.max(0, Math.min(dx, srcW - 1));
	dy = Math.max(0, Math.min(dy, srcH - 1));
	const cropW = Math.min(width, srcW - dx);
	const cropH = Math.min(height, srcH - dy);

	// Allocate new pixel array for cropped region
	const newPixels = new Uint8Array(cropW * cropH);

	for (let y = 0; y < cropH; y++) {
		const srcY = dy + y;
		for (let x = 0; x < cropW; x++) {
			const srcX = dx + x;
			newPixels[y * cropW + x] = pixels[srcY * srcW + srcX];
		}
	}

	// Return a new BMP-like object
	return {
		width: cropW,
		height: cropH,
		palette: bmp.palette.map(c => [...c]), // deep copy so palette edits wonâ€™t affect original
		pixels: newPixels
	};
}



function cyclePalette(palette, start = 229, end = 240) {
	const last = palette[end];
	for (let i = end; i > start; i--){
		palette[i] = palette[i - 1];
	}
	palette[start] = last;
}


function drawPaletteImage(ctx2, bmp, dx = 0, dy = 0) {
	const imgData = ctx2.createImageData(bmp.width, bmp.height);
	const data = imgData.data;
	const { pixels, palette } = bmp;

	for (let i = 0; i < pixels.length; i++) {
		const [r, g, b] = palette[pixels[i]];
		const j = i * 4;
		data[j] = r;
		data[j + 1] = g;
		data[j + 2] = b;
		data[j + 3] = 255;
	}

	ctx2.putImageData(imgData, dx, dy);
}



async function loadImages() {
	const loadPromises = [];

	for (const [key, obj] of Object.entries(imageAssets)) {
		const img = new Image();
		img.src = obj.path;
		imageCache[key] = img;

		// dont process ui images, just preload them.
		if (!obj.isUi) {
			const promise = new Promise((resolve, reject) => {
				img.onload = async () => {
					try {
						await img.decode(); // ensure fully decoded before use
						//console.log(`Image loaded: ${key}`);

						obj.image = img;

						// --- NEW: generate patterns for images that are marked as patterns ---
						if (!obj.isPattern) {
							// just generate mipmaps for normal images:
							obj.mipmaps = await generateMipmaps(img, 6);
						}else{
							if(obj.isAnimated){
								if (obj.isBigAnim) {
									const anim = obj.animationData;
									const frameCount = anim.frames.length;
									const gridSize = 8;
									const tileW = anim.tileWidth;
									const tileH = anim.tileHeight;
									const outputSize = gridSize * tileW;
									
									// load 13 images at once from single image:
									let waterAllPath = "images/water-all.bmp";
									let bmpAll = await load8BitBMP(waterAllPath);

									// Create shuffled pool of frame indices 0â€“12, repeated 5 times
									const baseIndices = Array.from({ length: frameCount }, (_, i) => i);
									const shuffledPool = [];
									for (let i = 0; i < 5; i++) {
										const arr = [...baseIndices];
										for (let j = arr.length - 1; j > 0; j--) {
											const k = Math.floor(randomFunc() * (j + 1));
											[arr[j], arr[k]] = [arr[k], arr[j]];
										}
										shuffledPool.push(...arr);
									}

									// Fill initial 8Ã—8 tile map from shuffled pool
									const tileMap = [];
									let poolIndex = 0;
									for (let y = 0; y < gridSize; y++) {
										const row = [];
										for (let x = 0; x < gridSize; x++) {
											let imageIndex = shuffledPool[poolIndex % shuffledPool.length];
											//let imageNumber = imageIndex+21;
											//let imagePath = `images/waterframes/watrtl${imageNumber}.bmp`;
											let bmp = getCroppedBMP(bmpAll, imageIndex*32, 0, 32, 32);
											row.push(bmp);
											poolIndex++;
										}
										tileMap.push(row);
									}

									// Build 13 big animation frames (each 256Ã—256)
									obj.animFrames = [];
									for (let frameIdx = 0; frameIdx < frameCount; frameIdx++) {
										const off = new OffscreenCanvas(outputSize, outputSize);
										const ctx2d = off.getContext('2d');
										
										// 8x8 tiles image:
										for (let y = 0; y < gridSize; y++) {
											for (let x = 0; x < gridSize; x++) {
												let bmp = tileMap[y][x];
												
												let dx = x*tileW;
												let dy = y*tileH;
												drawPaletteImage(ctx2d, bmp, dx, dy);
												cyclePalette(bmp.palette, 229, 240);
											}
										}

										// Generate mipmaps + patterns for this composite frame
										const bitmap = await createImageBitmap(off);
										const mipmaps = await generateMipmaps(bitmap, 6);
										const patterns = mipmaps.map(mipmap => {
											const c = new OffscreenCanvas(mipmap.width, mipmap.height);
											const ctx3 = c.getContext('2d');
											ctx3.drawImage(mipmap, 0, 0);
											return ctx.createPattern(c, 'repeat');
										});

										obj.animFrames.push({
											mipmaps,
											patterns
										});
									}

									// Metadata (same structure as small animated textures)
									obj.frameCount = frameCount;
									obj.frameDuration = 100; // adjust if you want faster/slower
									obj.currentFrame = 0;
									obj.lastFrameTime = performance.now();

									console.log(`Generated large animated pattern frames for ${key}`);
								}else{
									const anim = obj.animationData;
									obj.animFrames = [];

									for (const frame of anim.frames) {
										const frameCanvas = new OffscreenCanvas(anim.tileWidth, anim.tileHeight);
										const fctx = frameCanvas.getContext('2d');
										fctx.drawImage(
											img,
											frame.x, frame.y, anim.tileWidth, anim.tileHeight,
											0, 0, anim.tileWidth, anim.tileHeight
										);
										const frameBitmap = await createImageBitmap(frameCanvas);
										const frameMipmaps = await generateMipmaps(frameBitmap, 6);

										// For each mipmap level, create a pattern
										const framePatterns = frameMipmaps.map(mipmap => {
											const c = new OffscreenCanvas(mipmap.width, mipmap.height);
											const ctx2d = c.getContext('2d');
											ctx2d.drawImage(mipmap, 0, 0);
											return ctx.createPattern(c, 'repeat');
										});

										obj.animFrames.push({
											mipmaps: frameMipmaps,
											patterns: framePatterns
										});
									}

									obj.frameCount = anim.frames.length;
									obj.frameDuration = 300; // ms per frame, tweak as needed
									obj.currentFrame = 0;
									obj.lastFrameTime = performance.now();
								}
							}else{
								obj.mipmaps = await generateMipmaps(img, 6);
								obj.patterns = obj.mipmaps.map(mipmap => {
									// create a temporary canvas context for pattern
									const c = new OffscreenCanvas(mipmap.width, mipmap.height);
									const ctx2d = c.getContext('2d');
									ctx2d.drawImage(mipmap, 0, 0);
									return ctx.createPattern(c, 'repeat');
								});
							}
						}

						resolve();
					} catch (err) {
						console.error(`Error generating mipmaps for ${key}:`, err);
						reject(err);
					}
				};

				img.onerror = () => {
					console.error(`Failed to load image: ${obj.path}`);
					reject(new Error(`Failed to load image: ${obj.path}`));
				};
			});

			loadPromises.push(promise);
		}
	}

	await Promise.all(loadPromises);
	console.log("All images, mipmaps, and pattern mipmaps generated");
}


async function generateMipmaps(img, levels = 6) {
	const mipmaps = [];

	// Level 0 = original image as ImageBitmap
	const baseBitmap = await createImageBitmap(img);
	mipmaps.push(baseBitmap);

	let width = img.width;
	let height = img.height;
	let prev = baseBitmap;

	// Generate smaller levels using OffscreenCanvas
	for (let i = 1; i < levels; i++) {
		width = Math.max(1, Math.floor(width / 2));
		height = Math.max(1, Math.floor(height / 2));

		const off = new OffscreenCanvas(width, height);
		const ctx = off.getContext('2d');

		ctx.imageSmoothingEnabled = true;
		ctx.imageSmoothingQuality = 'high';
		ctx.drawImage(prev, 0, 0, width, height);

		// Convert the offscreen result into an ImageBitmap (GPU-friendly)
		const bitmap = await createImageBitmap(off);
		mipmaps.push(bitmap);

		prev = bitmap;
	}

	return mipmaps;
}








function getMipmapForZoom(imgObj, miplevel = -1) {
	if (!imgObj.mipmaps) return imgObj.image;
	if(miplevel == -1) miplevel = zoomMipLevel;
	return imgObj.mipmaps[miplevel];
}




// --- NEW FUNCTION: To get a loaded image from the cache
function getImage(key) {
	return imageCache[key];
}

function getImageSettings(key){
	return imageAssets[key];
}

// --- DOM ELEMENTS ---
const pages = {
	start: document.getElementById('start-page'),
	host: document.getElementById('host-page'),
	lobby: document.getElementById('lobby-page'),
	game: document.getElementById('game-page'),
};






const gameNameInput = document.getElementById('game-name-input');
const hostBtn = document.getElementById('host-btn');
const joinBtn = document.getElementById('join-btn');
const spectateBtn = document.getElementById('spectate-btn');
const connectionStatus = document.getElementById('connection-status');

// Host Page
const hostRoomNameTitle = document.getElementById('host-room-name-title');
const mapWidthInput = document.getElementById('map-width');
const mapHeightInput = document.getElementById('map-height');
const startMoneyInput = document.getElementById('start-money');





const spectateHostBtn = document.getElementById('spectate-host-btn');


const loadedGameInfoContainer = document.getElementById('loaded-game-info-container');
const loadGameDate = document.getElementById('load-game-date');
const loadGamePlayersList = document.getElementById('load-game-players');
const startGameBtn = document.getElementById('start-game-btn');




const startReplayBtn = document.getElementById('start-replay-btn');
const hostPlayerList = document.getElementById('host-player-list');

const startPlayerList = document.getElementById('start-player-list');
const lobbyStartPlayerList = document.getElementById('lobby-start-player-list');

const hostTextureType = document.getElementById('host-texture-type');
const lobbyTextureType = document.getElementById('lobby-texture-type');

const hostTextureTypeMsg = document.getElementById('host-texture-type-msg');
const lobbyTextureTypeMsg = document.getElementById('lobby-texture-type-msg');



hostTextureType.addEventListener("change", function(){
	let player = getMyPlayer();
	player.textureType = parseInt(hostTextureType.value, 10);
	
	broadcastLobbyState();
	
	console.warn("player.textureType:", player.textureType);
});




function loadedMapMode(disableButtons){
	startPlayerList.disabled = disableButtons;
	mapScale.disabled = disableButtons;
	loadMapBtn.disabled = disableButtons;
	loadRandomBtn.disabled = disableButtons;
	
	addAiBtn.disabled = disableButtons;
	
	// todo: make clients disable these too by listening to message of loaded map.
}





startPlayerList.addEventListener("change", function () {
	gameState.settings.startPlayerId = startPlayerList.value;
	
	broadcastLobbyState();
	
	console.log("gameState.settings.startPlayerId:", gameState.settings.startPlayerId);
});



// Lobby Page
const lobbyRoomNameTitle = document.getElementById('lobby-room-name-title');
const lobbyMapSize = document.getElementById('lobby-map-size');
const lobbyStartMoney = document.getElementById('lobby-start-money');
const lobbyMapScale = document.getElementById('lobby-map-scale');


const lobbyColorPicker = document.getElementById('lobby-color-picker');
const hostRoomColorPicker = document.getElementById('host-room-color-picker');

const lobbyColorPickerMsg = document.getElementById('lobby-color-picker-msg');
const hostRoomColorPickerMsg = document.getElementById('host-room-color-picker-msg');



const lobbyPlayerList = document.getElementById('lobby-player-list');
const lobbyStatus = document.getElementById('lobby-status');



// Game Page
canvas = document.getElementById('game-canvas');
ctx = canvas.getContext('2d');






const playerUIList = document.getElementById('player-ui-list');
const chatMessages = document.getElementById('chat-messages');
const topFloatUiChatMessages = document.getElementById('top-float-ui-messages');


const lobbyChatMessages = document.getElementById('lobby-chat-messages');
const lobbyChatInput = document.getElementById('lobby-chat-input');

const clientLobbyChatMessages = document.getElementById('client-lobby-chat-messages');
const clientLobbyChatInput = document.getElementById('client-lobby-chat-input');

//ctx.imageSmoothingEnabled = true;
//ctx.imageSmoothingQuality = 'high';

const chatInput = document.getElementById('chat-input');
const turnInfo = document.getElementById('turn-info');
const playerSavings = document.getElementById('player-savings');
const playerIncome = document.getElementById('player-income');
const playerWages = document.getElementById('player-wages');
const playerBalance = document.getElementById('player-balance');

const infoLeft = document.getElementById('info-left');


const nextUnitBtn = document.getElementById('next-unit-btn');
const previousUnitBtn = document.getElementById('previous-unit-btn');

const buildOtherBtn = document.getElementById('build-other-btn');

const buildSoldierBtn = document.getElementById('build-soldier-btn');
const buildCastleBtn = document.getElementById('build-castle-btn');
const endTurnBtn = document.getElementById('end-turn-btn');
const undoBtn = document.getElementById('undo-btn');
const sellUnitBtn = document.getElementById('sell-unit-btn');
const buildPopup = document.getElementById('build-popup');

const buildPopupTitle = document.getElementById('build-popup-title');
const buildPopupList = document.getElementById('build-popup-list');
const buildPopupClose = document.getElementById('build-popup-close');

const toggleUiBtn = document.getElementById('toggle-ui-btn');
const quitGameBtn = document.getElementById('quit-game-btn');

const saveGameBtn = document.getElementById('save-game-btn');

//const settingsBtn = document.getElementById('settings-btn');
const quickSettingsBtn = document.getElementById('quick-settings-btn');


const settingsUi = document.getElementById('settings-ui');


const gameSettingsBtn = document.getElementById('game-settings-btn');
const gameSettingsBtn2 = document.getElementById('game-settings-btn2');

const closeGameSettingsBtn = document.getElementById('close-game-settings-btn');
const gameSettingsUi = document.getElementById('game-settings-ui');
const gameSettingsUiWrapper2 = document.getElementById('game-settings-ui-wrapper2');



const uiEditor = document.getElementById('ui-editor');

const closeEndgamePopupBtn = document.getElementById('close-endgame-popup-btn');
const openEndgamePopupBtn = document.getElementById('endgame-stats-btn');
const endgamePopupUi = document.getElementById('endgame-popup-ui');
const endgamePopupUiWrapper2 = document.getElementById('endgame-popup-ui-wrapper2');

const endgameStatsWrapper = document.getElementById('endgame-stats-wrapper');



const endgamePopupTitle = document.getElementById('endgame-popup-title');
const endgamePopupMessage = document.getElementById('endgame-popup-message');


const endgamePopupStatsHexes = document.getElementById('endgame-popup-stats-hexes');
const endgamePopupStatsSoldiers = document.getElementById('endgame-popup-stats-soldiers');
const endgamePopupStatsWages = document.getElementById('endgame-popup-stats-wages');
const endgamePopupStatsMoney = document.getElementById('endgame-popup-stats-money');


const lobbyGameSettingsBtn = document.getElementById('lobby-game-settings-btn');


const startGameCheckBtn = document.getElementById('start-game-check-btn');


const forConfirmation = document.querySelectorAll('.for-confirmation');
const forSettings = document.querySelectorAll('.for-settings');




// for game settings check popup
function openSettingsCheck(){
	openGameSettings();
	
	showConfirmationView();
}


function switchConfirmationView(show){
	// show confirmation views:
	forConfirmation.forEach(el => {
		el.style.display = show ? "block" : "none";
	});
	// hide non-confirmation views:
	forSettings.forEach(el => {
		el.style.display = show ? "none" : "block";
	});
}

function showConfirmationView(){
	switchConfirmationView(true);
}
function hideConfirmationView(){
	switchConfirmationView(false);
}

startGameCheckBtn.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	startGameCheck();
});


gameSettingsBtn.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	openGameSettings();
	hideConfirmationView();
});
gameSettingsBtn2.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	openGameSettings();
	hideConfirmationView();
});
gameSettingsBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
gameSettingsBtn2.tabIndex = -1; //remove it from the tab order

	
	
lobbyGameSettingsBtn.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	openGameSettings();
	hideConfirmationView();
});




function openGameSettings(){
	// unfocus chatinput:
	chatInput.blur();
	
	gameSettingsUi.style.display = "flex";
	
	addPopupState(gameSettingsUi);
}
function closeGameSettings(){
	gameSettingsUi.style.display = "none";
	
	removePopupState(gameSettingsUi);
}

closeGameSettingsBtn.addEventListener("click", () => {
	closeGameSettings();
});




function openEndgamePopup(fireworksEnabled){
	// unfocus chatinput:
	chatInput.blur();
	
	endgamePopupUi.style.display = "flex";
	
	endgameStatsWrapper.style.display = "none";
	
	if(fireworksEnabled || getMyPlayer().isWinner){
		fireworks.start();
	}
	
	if(fireworksEnabled){
		playSound("victory");
	}else{
		playSound("defeat");
	}
	
	//addPopupState(endgamePopupUi);
}

function closeEndgamePopup(){
	endgamePopupUi.style.display = "none";
	
	endgameStatsWrapper.style.display = "flex";
	
	fireworks.stop();
	
	//removePopupState(endgamePopupUi);
}

closeEndgamePopupBtn.addEventListener("click", () => {
	closeEndgamePopup();
});

openEndgamePopupBtn.addEventListener("click", () => {
	let fireworksEnabled = getMyPlayer().isWinner;
	openEndgamePopup(fireworksEnabled);
});





function openIngameSettings(){
	settingsUi.style.display = "flex";
}
function closeIngameSettings(){
	settingsUi.style.display = "none";
}



quickSettingsBtn.addEventListener("click", (e) => {
	e.stopPropagation(); // needed or it will close the popup instantly due to check of handleOutside()
	toggleSettings();
});




const moveConfirmationPopup = document.getElementById('move-confirmation-popup');
const moveConfirmationWrapper = document.getElementById('move-confirmation-wrapper');
const moveConfirmationWrapper2 = document.getElementById('move-confirmation-wrapper2');

const moveConfirmationCheckbox = document.getElementById('move-confirmation-popup-dont-show-again');
const moveConfirmationButton = document.getElementById('move-confirmation-popup-confirm-button');

setLocalStorageItem("hideMoveConfirmationPopup", "false");

function showMoveConfirmationPopup(){
	// Show popup only if user did not opt out
	if(getLocalStorageItem("hideMoveConfirmationPopup") !== "true"){
		moveConfirmationPopup.hidden = false;
		moveConfirmationPopup.style.display = "flex";
	}
}

// Handle confirmation
moveConfirmationButton.addEventListener("click", () => {
	if(moveConfirmationCheckbox.checked){
		setLocalStorageItem("hideMoveConfirmationPopup", "true");
	}
	moveConfirmationPopup.hidden = true;
	moveConfirmationPopup.style.display = "none";
});






const musicPauseBtn2 = document.getElementById('music-pause-btn2');
const musicPlayBtn2 = document.getElementById('music-play-btn2');
const musicNextBtn2 = document.getElementById('music-next-btn2');
const musicPreviousBtn2 = document.getElementById('music-previous-btn2');
const musicMuteBtn2 = document.getElementById('music-mute-btn2');
const musicUnmuteBtn2 = document.getElementById('music-unmute-btn2');



//const refreshCanvasBtn = document.getElementById('refresh-canvas');

const rotateLeftBtn = document.getElementById('rotate-left-btn');
const rotateRightBtn = document.getElementById('rotate-right-btn');
const rotateResetBtn = document.getElementById('rotate-reset-btn');



const topFloatUi = document.getElementById('top-float-ui');
const uiRight = document.getElementById('ui-right');
const uiLeft = document.getElementById('ui-left');



const UNIT_ADJECTIVES = [
	"Iron", "Crimson", "Silent", "Wild", "Steady", "Grim", "Swift", "Brave",
	"Stone", "Golden", "Night", "Feral", "Storm", "Scarlet", "Frozen", "Noble",
];

const UNIT_NOUNS = [
	"Wolf", "Falcon", "Hammer", "Viper", "Saber", "Shield", "Reaver", "Hunter",
	"Sentinel", "Warden", "Rider", "Striker", "Golem", "Specter", "Marauder", "Prowler",
];

let possibleUnitNames = [];
createPossibleUnitNames();

function createPossibleUnitNames(){
	possibleUnitNames = [];
	// 16x16 = 256 items array of unique names:
	for(let a = 0; a < UNIT_ADJECTIVES.length; a++){
		const adj = UNIT_ADJECTIVES[a];
		for(let n = 0; n < UNIT_NOUNS.length; n++){
			const noun = UNIT_NOUNS[n];
			possibleUnitNames.push(`${adj}${noun}`);
		}
	}
	possibleUnitNames = shuffle(possibleUnitNames);
	//console.log(possibleUnitNames);
}

function randomUnitName(){
	// longest: CrimsonMarauder
	//const adj = UNIT_ADJECTIVES[random(0, UNIT_ADJECTIVES.length-1)];
	//const noun = UNIT_NOUNS[random(0, UNIT_NOUNS.length-1)];
	//return `${adj}${noun}`;
	return possibleUnitNames[random(0, possibleUnitNames.length-1)];
}


function findNextFreeRandomUnitName(playerIndex){
	let unitName = "";
	
	let unitNamesList = [];
	for(let i = 0; i < gameState.units.length; i++){
		let unit = gameState.units[i];
		
		if(unit.name && unit.ownerIndex === playerIndex && unitTypeCanMove(unit.type)){
		//if(unit.name && unit.ownerIndex === playerIndex && unit.internalType === 'soldier'){
			unitNamesList.push(unit.name);
		}
	}
	
	// try to get a name that doesnt exist yet:
	let found = 0;
	for(let i = 0; i < possibleUnitNames.length; i++){
		unitName = possibleUnitNames[i];
		if(!unitNamesList.includes(unitName)){
			// unique name found
			found = 1;
			break;
		}
	}
	// if all names were used, just add number to end:
	if(!found){
		for(let number = 1; number < 10; number++){
			for(let i = 0; i < possibleUnitNames.length; i++){
				unitName = possibleUnitNames[i] + number;
				if(!unitNamesList.includes(unitName)){
					// unique name found
					found = 1;
					break;
				}
			}
			if(found){
				break;
			}
		}
	}
	// if still not found, just uses the last set unitName.
	
	return unitName;
}


// randomname random name random nick
function randomPlayerName() {
	const prefixes = [
		"al", "bel", "cor", "dar", "el", "fen", "gal", "hal", "jor", "kal",
		"lin", "mor", "nor", "or", "pel", "quil", "ron", "sel", "tor", "val",
	];
	const middles = [
		"a", "e", "i", "o", "u", "ae", "ia", "eo", "ou", "ai",
	];
	const suffixes = [
		"dor", "mar", "ric", "tan", "ven", "win", "bar", "dris", "lith", "zor",
		"thus", "mir", "gorn", "las", "thar", "mond",
	];

	function capitalize(word) {
		return word.charAt(0).toUpperCase() + word.slice(1);
	}

	const prefix = prefixes[Math.floor(randomFunc() * prefixes.length)];
	const middle = middles[Math.floor(randomFunc() * middles.length)];
	const suffix = suffixes[Math.floor(randomFunc() * suffixes.length)];

	return capitalize(prefix + middle + suffix);
}

function getRandomString(length) {
	const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	let result = '';
	for (let i = 0; i < length; i++) {
		const randomIndex = Math.floor(randomFunc() * chars.length);
		result += chars[randomIndex];
	}
	return result;
}




const addAiBtn = document.getElementById('add-ai-btn');

let ai_counter = 1;

addAiBtn.addEventListener('click', () => {
	if (!isHost()) return;

	let randomStr = getUID(5); // add short random id so the total length is 10 at minimum.
	const aiPlayer = {
		id: `AI-${ai_counter}-${randomStr}`,
		name: `AI-${ai_counter}`,
		color: getNextFreeColor(),
		textColor: getNextFreeTextColor(),
		isSpectator: false,
		isAI: true,
		isDead: false,
	};

	//gameState.players.push(aiPlayer);
	addPlayer(aiPlayer);
	ai_counter++;

	// Update the UI for the host and broadcast the new state to all clients
	broadcastLobbyState();
});



// =================================================================
// --- UTILITY FUNCTIONS
// =================================================================

function centerTo(q, r) {
	const centerX = axialToPixelX(q, r);
	const centerY = axialToPixelY(q, r);

	const zoom = viewport.zoom;
	const rot  = viewport.rotation;

	const cos = Math.cos(rot);
	const sin = Math.sin(rot);

	// rotate world position around (0,0)
	const rx = centerX * cos - centerY * sin;
	const ry = centerX * sin + centerY * cos;

	// now compute the translation that places this at canvas center
	viewport.x = canvas.width  / 2 - rx * zoom;
	viewport.y = canvas.height / 2 - ry * zoom;
	
	return axialToPixel(q, r);
}



function centerToPixelPos(centerX, centerY) {
	viewport.x = canvas.width  / 2 - centerX * viewport.zoom;
	viewport.y = canvas.height / 2 - centerY * viewport.zoom;
	return {x: centerX, y: centerY};
}

function centerToUnit(unit){
	if(unit){
		centerTo(unit.q, unit.r);
		return axialToPixel(unit.q, unit.r);
	}
	return null;
}

function centerAndSelectUnit(unit){
	if(unit){
		selectedUnit = unit;
		selectedHex = {q:unit.q, r:unit.r};
		
		hideBuildPopup();
		updateHighlights();
		updateSelectedPoolInfo(selectedHex);
		
		centerToUnit(unit);
		
		// enable sell button:
		sellUnitBtn.disabled = false;
		
		return axialToPixel(unit.q, unit.r);
	}
	return null;
}


function centerToTile(tile){
	if(tile){
		centerTo(tile.q, tile.r);
		return axialToPixel(tile.q, tile.r);
	}
	return null;
}

function centerFirstUnit(){
	return centerAndSelectFirstUnit(false);
}



function centerAndSelectFirstUnit(selectUnit = true){
	let player = getMyPlayer();
	
	//let found = 0;
	if(player && !player.isSpectator){
		
		// find first soldier unit to center to:
		for (const unit of gameState.units) {
			if(unitTypeCanMove(unit.type) && unit.ownerIndex === player.playerIndex){
			//if(unit.internalType === 'soldier' && unit.ownerIndex === player.playerIndex){
				if(selectUnit){
					return centerAndSelectUnit(unit);
				}else{
					return centerToUnit(unit);
				}
				//found = 1;
				//break;
			}
		}
		// no movable units found: try to find a castle and center to it:
		// this might be possible when loading a game, or if loaded map has castles set.
		//if(!found){
			for (const unit of gameState.units) {
				if(unit.internalType === 'castle' && unit.ownerIndex === player.playerIndex){
					if(selectUnit){
						return centerAndSelectUnit(unit);
					}else{
						return centerToUnit(unit);
					}
					//found = 1;
					//break;
				}
			}
		//}
		// if no units found at all, just choose first hex owned by player:
		//if(!found){
			for(let i = 0; i < gameState.map.tilesData.length; i++){
				let tile = gameState.map.tilesData[i];
				if(tile.ownerIndex === player.playerIndex){
					return centerToTile(tile);
					//found = 1;
					//break;
				}
			}
		//}
	}
	
	// if no valid center pos found, center to map middle:
	//if(!found){
		let centerX = 0;
		let centerY = 0;
		let total = 0;
		for(let i = 0; i < gameState.map.tilesData.length; i++){
			let tile = gameState.map.tilesData[i];
			const x = axialToPixelX(tile.q, tile.r);
			const y = axialToPixelY(tile.q, tile.r);
			centerX += x;
			centerY += y;
			total++;
		}
		if(total){
			centerX = centerX/total;
			centerY = centerY/total;
		}
		
		return centerToPixelPos(centerX, centerY);
	//}
	
}



function showPage(pageId) {
	CURRENT_PAGE = pageId;
	
	// change settings popup depending on page:
	switchSettings(pageId);
	
	if(pageId === 'game'){
		randomTrack();
		if(!musicMuted){
			playMusic();
		}
	}

	Object.values(pages).forEach(page => page.classList.remove('active'));
	if (pages[pageId]) {
		pages[pageId].classList.add('active');
	}
	if (pageId === 'game') {
		resizeCanvas();
		
		// might fix weird black bar appearing at bottom sometimes:
		// "A2HS standalone/PWA mode has viewport bugs on many Android versions."
		// "The OS initially gives a height that includes or excludes soft navigation bars incorrectly."
		// "The CSS units vh and JavaScript window.innerHeight are unreliable on first load in these conditions."
		setTimeout(resizeCanvas, 1000);
		
		render();
	}
}







// MUST use playerId here 
function sendToPlayer(playerId, data) {
	if (!isHost()) return;
	
	if (playerId === localPlayer.id) {
		// It's the host, handle directly
		handleHostData(data);
	} else if (connections.has(playerId)) {
		connections.get(playerId).send(data);
	}
}


function sendToHost(data) {
	if (isHost()) {
		// Host handles its own actions directly
		handleClientData(localPlayer.id, data);
	} else if (hostPeerId && connections.has(hostPeerId)) {
		connections.get(hostPeerId).send(data);
	}
}

// --- AI BATCHING GLOBALS ---
let isAiBatching = false;
let aiBatchBuffer = [];

function broadcast(data, everyone = true) {
	if (!isHost()) return;

	// 1. ALWAYS process locally immediately.
	// This updates the Host's gameState, allowing the AI to 'see' the result 
	// of its move before calculating the next one.
	if(everyone){ // if want to broadcast to everyone, this includes host here:
		handleHostData(data);
	}

	// 2. Handle Network Sending
	if (isAiBatching) {
		// In AI Batch mode: Collect message to buffer
		aiBatchBuffer.push(data);
	} else {
		// Standard mode: Send to all connected clients immediately
		for (const [peerId, conn] of connections.entries()) {
			conn.send(data);
		}
	}
}



function toggleSettings(setState = -1){
	let hidePopup = (settingsUi.style.display === 'flex');
	if(setState !== -1){
		hidePopup = (setState === 0);
	}
	
	if(hidePopup){
		settingsUi.style.opacity = '1';
		settingsUi.style.display = 'none';
	}else{
		settingsUi.style.opacity = '1';
		settingsUi.style.display = 'flex';
	}
}




let hideTimeout = null;
let hideTimeout2 = null;

function clearTimeouts(){
	if(hideTimeout){
		clearTimeout(hideTimeout);
		hideTimeout = null;
	}
	if(hideTimeout2){
		clearTimeout(hideTimeout2);
		hideTimeout2 = null;
	}
}

function hideTopFloatUi(){
	clearTimeouts();
	topFloatUi.style.transition = 'opacity 1.0s';
	topFloatUi.style.opacity = '1';
	topFloatUi.style.display = 'flex';
	
	hideTimeout = setTimeout(() => {
		topFloatUi.style.opacity = '0';
		hideTimeout2 = setTimeout(() => {
			topFloatUi.style.display = 'none';
		}, 1000); // matches the topFloatUi.style.transition time.
	}, 10000); // 10 sec delay until hides top chat.
}


let showTopLeftUi = false;

function toggleUiTopLeft(toggleValue = null){
	if(toggleValue === null){
		showTopLeftUi = !showTopLeftUi;
	}else{
		showTopLeftUi = toggleValue;
	}
	toggleUiBtn.classList.toggle('active', showTopLeftUi);
	
	clearTimeouts();
	
	if(showTopLeftUi){
		uiLeft.style.display = 'flex';
		topFloatUi.style.display = 'none';
		topFloatUi.style.opacity = '0';
		chatMessages.scrollTop = chatMessages.scrollHeight;
		chatInput.focus();
	}else{
		uiLeft.style.display = 'none';
		topFloatUi.style.display = 'flex';
		topFloatUi.style.opacity = '1';
		topFloatUiChatMessages.scrollTop = topFloatUiChatMessages.scrollHeight;
		hideTopFloatUi();
	}
}



function pushLobbyChatMessage(from, message, isSpectator, color = '#FFF') {
	
	let spectag = "";
	let nameStr = `${from}:`;
	
	if(isSpectator){
		spectag = " (spec)";
		color = "#FFFFFF"; // force spectator color.
		nameStr = `(${from}):`;
	}

	const item = document.createElement('div');
	item.innerHTML = `<strong style="color: ${color};" class="msgfromtext"></strong><span class="msgtext"></span>`;

	const safeMsgFrom = document.createTextNode(nameStr);
	const safeMsg = document.createTextNode(` ${message}`);
	item.querySelector(".msgfromtext").appendChild(safeMsgFrom);
	item.querySelector(".msgtext").appendChild(safeMsg);

	lobbyChatMessages.appendChild(item);
	lobbyChatMessages.scrollTop = lobbyChatMessages.scrollHeight;

	const item2 = item.cloneNode(true);
	clientLobbyChatMessages.appendChild(item2);
	clientLobbyChatMessages.scrollTop = clientLobbyChatMessages.scrollHeight;
	
	limitLobbyChatUIMessages();
}


function pushLobbySystemChatMessage(message, color = '#FFF') {
	const item = document.createElement('div');

	const strong = document.createElement('strong');
	strong.style.color = color;
	strong.textContent = message; // SAFE

	item.appendChild(strong);

	lobbyChatMessages.appendChild(item);
	lobbyChatMessages.scrollTop = lobbyChatMessages.scrollHeight;

	const item2 = item.cloneNode(true);
	clientLobbyChatMessages.appendChild(item2);
	clientLobbyChatMessages.scrollTop = clientLobbyChatMessages.scrollHeight;
	
	limitLobbyChatUIMessages();
}


function getHHii() {
	const now = new Date();
	const hours = String(now.getHours()).padStart(2, '0');
	const minutes = String(now.getMinutes()).padStart(2, '0');
	return `${hours}:${minutes}`;
}

function pushChatMessage(from, message, isSpectator, color = '#FFF') {
	
	// moved on top here so it will be ready for rendering chat.
	// show chat messages on top if topleft ui is not open
	if(!showTopLeftUi){
		//console.warn("hideTopFloatUi");
		hideTopFloatUi();
	}
	
	
	let spectag = "";
	let nameStr = `${from}:`;
	
	if(isSpectator){
		spectag = " (spec)";
		color = "#FFFFFF"; // force spectator color.
		nameStr = `(${from}):`;
	}

	const item = document.createElement('div');
	item.innerHTML = `<span style="color: ${color};" class="msgtime"></span><strong style="color: ${color};" class="msgfromtext"></strong><span class="msgtext"></span>`;

	const safeMsgTime = document.createTextNode(getHHii()+" "); // "23:45 "
	const safeMsgFrom = document.createTextNode(nameStr);
	const safeMsg = document.createTextNode(` ${message}`);
	item.querySelector(".msgtime").appendChild(safeMsgTime);
	item.querySelector(".msgfromtext").appendChild(safeMsgFrom);
	item.querySelector(".msgtext").appendChild(safeMsg);

	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
	
	limitChatUIMessages();
	
	const item2 = item.cloneNode(true);
	topFloatUiChatMessages.appendChild(item2);
	topFloatUiChatMessages.scrollTop = topFloatUiChatMessages.scrollHeight;
	
	limitTopFloatUIMessages();
}

function limitTopFloatUIMessages(){
	// trim old items for the floating UI
	while (topFloatUiChatMessages.children.length > 3) {
		topFloatUiChatMessages.removeChild(topFloatUiChatMessages.firstElementChild);
	}
}
function limitChatUIMessages(){
	// --- FIX: Prevent Memory Leak ---
	// no need to see that far in chat history anyway...
	while (chatMessages.children.length > 100) {
		chatMessages.removeChild(chatMessages.firstElementChild);
	}
}

function limitLobbyChatUIMessages(){
	// --- FIX: Prevent Memory Leak ---
	// no need to see that far in chat history anyway...
	while (lobbyChatMessages.children.length > 100) {
		lobbyChatMessages.removeChild(lobbyChatMessages.firstElementChild);
	}
	while (clientLobbyChatMessages.children.length > 100) {
		clientLobbyChatMessages.removeChild(clientLobbyChatMessages.firstElementChild);
	}
}




// sendmessage addmessage pushmessage sendchatmessage
function addChatMessage(from, message, isSpectator, color = '#FFF') {
	pushChatMessage(from, message, isSpectator, color);
}

// sendmessage addmessage pushmessage sendchatmessage
function addLobbyChatMessage(from, message, isSpectator, color = '#FFF') {
	pushLobbyChatMessage(from, message, isSpectator, color);
}

function addLobbySystemChatMessage(message, color = '#FFF') {
	pushLobbySystemChatMessage(message, color);
}



function getTurnDate(type = 'day'){
	const turn = gameState.turn.turnNumber;
	if(type === 'week-day'){
		const daysPerWeek = 7;

		let week = 1+Math.floor((turn - 1) / daysPerWeek);
		let day = ((turn - 1) % daysPerWeek) + 1;

		const parts = [];
		if (week > 0) parts.push(`Week: ${week}`);
		parts.push(`Day: ${day}`);

		return parts.join(", ");
	}else if(type === 'month-week-day'){
	
		const daysPerWeek = 7;
		const weeksPerMonth = 4;
		const daysPerMonth = daysPerWeek * weeksPerMonth;

		let month = 1+Math.floor((turn - 1) / daysPerMonth);
		let week = 1+Math.floor(((turn - 1) % daysPerMonth) / daysPerWeek);
		let day = ((turn - 1) % daysPerWeek) + 1;

		const parts = [];
		if (month > 0) parts.push(`Month: ${month}`);
		if (week > 0) parts.push(`Week: ${week}`);
		parts.push(`Day: ${day}`);

		return parts.join(", ");
	}else{
		return "Day: "+turn;
	}
}


function addCurrentTurnChatMessage(){
	let player = getCurrentTurnPlayer();
	let turnDate = getTurnDate('week-day');
	let tag = "";
	if(player.isAI){
		tag = " (AI)";
	}
	addSystemChatMessage(`${turnDate} - ${player.name}'s${tag} turn.`, player.textColor);
	
	if(isMyTurn()){
		showTurnPopup();
	}
}



// pointer* events already catch: mouse touch stylus
// But keeping touch* is harmless and sometimes useful for older browsers.
// scroll catches mouse-wheel, touch drag, inertia scrolling, etc.
const userActivityEvents = [
	"click",
	"mousedown",
	"mouseup",
	//"mousemove",
	"wheel",
	"keydown",
	"keyup",
	"touchstart",
	"touchmove",
	"touchend",
	"pointerdown",
	//"pointermove",
	"pointerup",
	"scroll",
];

// hide "your turn" popup if any user input was given:
userActivityEvents.forEach(event => {
	// passive: true keeps performance good for things like scroll and touch events.
	window.addEventListener(event, throttledMarkUserActive, { passive: true });
});

let lastActiveTime = 0;
function throttledMarkUserActive() {
	const now = Date.now();
	if (now - lastActiveTime > 500) {  // adjust interval as needed
		hideTurnPopup();
		lastActiveTime = now;
	}
}




// pushsystemchat
function addSystemChatMessage(message, color = '#FFF') {
	
	// moved on top here so it will be ready for rendering chat.
	// show chat messages on top if topleft ui is not open
	if(!showTopLeftUi){
		//console.warn("hideTopFloatUi2");
		hideTopFloatUi();
	}
	/*
	const item = document.createElement('div');
	item.innerHTML = `<strong style="color: ${color};">${message}</strong>`;
	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
	*/

	const item = document.createElement('div');

	const strong = document.createElement('strong');
	strong.style.color = color;
	strong.textContent = message; // SAFE

	item.appendChild(strong);
	chatMessages.appendChild(item);
	chatMessages.scrollTop = chatMessages.scrollHeight;
	
	limitChatUIMessages();
	
	const item2 = item.cloneNode(true);
	topFloatUiChatMessages.appendChild(item2);
	topFloatUiChatMessages.scrollTop = topFloatUiChatMessages.scrollHeight;

	limitTopFloatUIMessages();
}



function shortUIDBase36(maxLength = 16) {
	let bytes = 10;
	const arr = new Uint8Array(bytes);
	crypto.getRandomValues(arr);

	let num = 0n;
	for (const b of arr) num = (num << 8n) | BigInt(b);

	return num.toString(36).toUpperCase().slice(0, maxLength);
}

function getUID(maxLength = 10) {
	// seems to be working right, no way two identical IDS generated.
	//return Date.now().toString(36) + randomFunc().toString(36).substr(2);
	//return Date.now().toString(36).toUpperCase() + randomFunc().toString(36).substr(2).toUpperCase();
	return shortUIDBase36(maxLength);
}



// =================================================================
// --- HEXAGON MATH
// =================================================================

function axialToPixel(q, r) {
	// If first argument is an object, extract values
	if (q !== null && typeof q === "object") {
		r = q.r;
		q = q.q; // must be set here or overwrites q before r.
	}
	if (typeof q !== "number" || typeof r !== "number") {
		throw new TypeError("axialToPixel expects (q, r) numbers or an object { q, r }");
	}
	const x = HEX_SIZE * (3/2 * q);
	const y = HEX_SIZE * (SQRT3/2 * q + SQRT3 * r);
	return { x, y };
}

// faster functions without object creation:
function axialToPixelX(q, r) {
	// If first argument is an object, extract values
	if (q !== null && typeof q === "object") {
		r = q.r;
		q = q.q; // must be set here or overwrites q before r.
	}
	if (typeof q !== "number" || typeof r !== "number") {
		throw new TypeError("axialToPixelX expects (q, r) numbers or an object { q, r }");
	}
	return HEX_SIZE * (3/2 * q);
}
function axialToPixelY(q, r) {
	// If first argument is an object, extract values
	if (q !== null && typeof q === "object") {
		r = q.r;
		q = q.q; // must be set here or overwrites q before r.
	}
	if (typeof q !== "number" || typeof r !== "number") {
		throw new TypeError("axialToPixelY expects (q, r) numbers or an object { q, r }");
	}
	return HEX_SIZE * (SQRT3/2 * q + SQRT3 * r);
}


function pixelToAxial(x, y) {
	// If first argument is an object, extract values
	if (x !== null && typeof x === "object") {
		y = x.y;
		x = x.x; // must be set here or overwrites q before r.
	}
	if (typeof x !== "number" || typeof y !== "number") {
		throw new TypeError("pixelToAxial expects (x, y) numbers or an object { x, y }");
	}
	// 1. undo translation
	let vx = x - viewport.x;
	let vy = y - viewport.y;

	// 2. undo rotation
	const sin = Math.sin(-viewport.rotation);
	const cos = Math.cos(-viewport.rotation);

	const rx = vx * cos - vy * sin;
	const ry = vx * sin + vy * cos;

	// 3. undo zoom
	const viewX = rx / viewport.zoom;
	const viewY = ry / viewport.zoom;

	// 4. convert world coords â†’ axial hex
	const q = (2/3 * viewX) / HEX_SIZE;
	const r = (-1/3 * viewX + SQRT3/3 * viewY) / HEX_SIZE;

	return hexRound(q, r);
}



function pixelToAxialPrecise(x, y) {
	// If first argument is an object, extract values
	if (x !== null && typeof x === "object") {
		y = x.y;
		x = x.x; // must be set here or overwrites q before r.
	}
	if (typeof x !== "number" || typeof y !== "number") {
		throw new TypeError("pixelToAxial expects (x, y) numbers or an object { x, y }");
	}
	// 1. undo translation
	let vx = x - viewport.x;
	let vy = y - viewport.y;

	// 2. undo rotation
	const sin = Math.sin(-viewport.rotation);
	const cos = Math.cos(-viewport.rotation);

	const rx = vx * cos - vy * sin;
	const ry = vx * sin + vy * cos;

	// 3. undo zoom
	const viewX = rx / viewport.zoom;
	const viewY = ry / viewport.zoom;

	// 4. convert world coords â†’ axial hex
	const q = (2/3 * viewX) / HEX_SIZE;
	const r = (-1/3 * viewX + SQRT3/3 * viewY) / HEX_SIZE;

	return {q, r};
}


/*
function pixelToAxial1(x, y) {
	// Apply viewport inverse transform
	const viewX = (x - viewport.x) / viewport.zoom;
	const viewY = (y - viewport.y) / viewport.zoom;
	
	const q = (2/3 * viewX) / HEX_SIZE;
	const r = (-1/3 * viewX + SQRT3/3 * viewY) / HEX_SIZE;

	return hexRound(q, r);
}
*/

function hexRound(q, r) {
	// If first argument is an object, extract values
	if (q !== null && typeof q === "object") {
		r = q.r;
		q = q.q; // must be set here or overwrites q before r.
	}
	if (typeof q !== "number" || typeof r !== "number") {
		throw new TypeError("hexRound expects (q, r) numbers or an object { q, r }");
	}
	const s = -q - r;
	let rq = Math.round(q);
	let rr = Math.round(r);
	let rs = Math.round(s);

	const q_diff = Math.abs(rq - q);
	const r_diff = Math.abs(rr - r);
	const s_diff = Math.abs(rs - s);

	if (q_diff > r_diff && q_diff > s_diff) {
		rq = -rr - rs;
	} else if (r_diff > s_diff) {
		rr = -rq - rs;
	}

	// make sure no -0 values exist... 
	//   just for clarity and perhaps possible bugs since values are stringified in some places.
	if (Object.is(rq, -0)) rq = 0;
	if (Object.is(rr, -0)) rr = 0;

	// `rs` is derived, so we just return `rq` and `rr`
	return { q: rq, r: rr };
}


function getHexNeighbors(q, r) {
	// If first argument is an object, extract values
	if (q !== null && typeof q === "object") {
		r = q.r;
		q = q.q; // must be set here or overwrites q before r.
	}
	if (typeof q !== "number" || typeof r !== "number") {
		throw new TypeError("hexRound expects (q, r) numbers or an object { q, r }");
	}
	return [                    //              i for "angle index" calculations
		{ q: q,     r: r + 1 }, // bottom       0
		{ q: q - 1, r: r + 1 }, // bottom left  1
		{ q: q - 1, r: r },     // top left     2
		{ q: q,     r: r - 1 }, // top          3
		{ q: q + 1, r: r - 1 }, // top right    4
		{ q: q + 1, r: r },     // bottom right 5
	];
}

// i matches getHexNeighbors index
function getSideAngle(i){
	return i*60+90; // clockwise rotation angles (the edge's top line to bottom line)
}


function getHexDistance(q1, r1, q2, r2) {
	const dq = q1 - q2;
	const dr = r1 - r2;
	const ds = (-q1 - r1) - (-q2 - r2);
	return (Math.abs(dq) + Math.abs(dr) + Math.abs(ds)) / 2;
}

function getPointsDistance(p1, p2) {
	const dx = p2.x - p1.x;
	const dy = p2.y - p1.y;
	return Math.sqrt(dx * dx + dy * dy);
}

function getHexPointDistance(hex, point){
	let h2 = pixelToAxialPrecise(point.x, point.y);
	return getHexDistance(hex.q, hex.r, h2.q, h2.r);
}


// =================================================================
// --- CANVAS RENDERING
// =================================================================
function resizeCanvas(){
	//console.warn(`resizeCanvas(): old = ${canvas.width}x${canvas.height}, new = ${window.innerWidth}x${window.innerHeight}`);
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
}

function refreshCanvas(){
	addSystemChatMessage(`resizeCanvas(): old = ${canvas.width}x${canvas.height}, new = ${window.innerWidth}x${window.innerHeight}`);
	resizeCanvas();
}


function initCanvas() {
	// old code, using resizeCanvas() now.
	//canvas.width = window.innerWidth;
	//canvas.height = window.innerHeight;
}




function getHexAnglePosX(i, px, py, multi = 1){
	return px + HEX_SIZE * multi * HEX_CORNERS[i].x;
}

function getHexAnglePosY(i, px, py, multi = 1){
	return py + HEX_SIZE * multi * HEX_CORNERS[i].y;
}

function getHexAnglePos(i, px, py, multi = 1){
	const x = px + HEX_SIZE*multi * HEX_CORNERS[i].x;
	const y = py + HEX_SIZE*multi * HEX_CORNERS[i].y;
	
	//const angle = 2 * Math.PI / 6 * (i + 1); // +0.5 for pointy top
	//const x = px + HEX_SIZE*multi * Math.cos(angle);
	//const y = py + HEX_SIZE*multi * Math.sin(angle);
	return {x, y};
}


function drawHexLine(i, px, py, multi = 1){
	//let p1 = getHexAnglePos(i, px, py, multi);
	//let p2 = getHexAnglePos(i+1, px, py, multi);
	//ctx.moveTo(p1.x, p1.y);
	//ctx.lineTo(p2.x, p2.y);
	
	// faster way, no object creations:
	let r = HEX_SIZE * multi;

	ctx.moveTo(
		px + r * HEX_CORNERS[i].x, 
		py + r * HEX_CORNERS[i].y
	);
	ctx.lineTo(
		px + r * HEX_CORNERS[i+1].x, 
		py + r * HEX_CORNERS[i+1].y
	);
}







// general function to draw the old water shading, not used yet.
function drawCalligraphyLine(x1, y1, x2, y2, penWidth, penAngle = Math.PI/2) {
	// Compute perpendicular offset based on fixed pen angle
	const offsetX = Math.cos(penAngle) * (penWidth / 2);
	const offsetY = Math.sin(penAngle) * (penWidth / 2);

	ctx.beginPath();
	ctx.moveTo(x1 - offsetX, y1 - offsetY);
	ctx.lineTo(x2 - offsetX, y2 - offsetY);
	ctx.lineTo(x2 + offsetX, y2 + offsetY);
	ctx.lineTo(x1 + offsetX, y1 + offsetY);
	ctx.closePath();
	ctx.fill();
}








let waterShadingHeight = 20;




// 1. Update drawFilledLine to accept separate X and Y offsets
function drawFilledLine(x1, y1, x2, y2, offX, offY) {
	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	// Add the offset vector to create the "depth"
	ctx.lineTo(x2 + offX, y2 + offY);
	ctx.lineTo(x1 + offX, y1 + offY);
	ctx.closePath();
	ctx.fill();
}





function norm180(a) {
	const tau = Math.PI * 2;
	return ((a + Math.PI) % tau + tau) % tau - Math.PI;
}

function getEdgeCorners(px, py, ival, scale = 1, offX = 0, offY = 0){
	let radius = HEX_SIZE*scale;
	const x1 = px + radius * HEX_CORNERS[ival].x;
	const y1 = py + radius * HEX_CORNERS[ival].y;
	const x2 = px + radius * HEX_CORNERS[ival+1].x;
	const y2 = py + radius * HEX_CORNERS[ival+1].y;
	return {x1: x1+offX, y1: y1+offY, x2: x2+offX, y2: y2+offY};
}



function drawFilledShadingLine(px, py, ival, scale1, scale2, scale3, color1, color2, offX = 0, offY = 0){
	let edge1 = getEdgeCorners(px, py, ival, scale1, offX, offY); // 1.0  utside edge
	let edge2 = getEdgeCorners(px, py, ival, scale2, offX, offY); // 0.9  inside edge
	let edge3 = getEdgeCorners(px, py, ival, scale3, offX, offY); // 0.6  most inside edge
/*
	let textX = (edge1.x1+edge1.x2)/2;
	let textY = (edge1.y1+edge1.y2)/2;
	ctx.save();
	ctx.translate(textX, textY);
	drawStrokedText(text);
	ctx.restore();
	*/
	
	ctx.fillStyle = color1; // 0.3
	ctx.beginPath();
	ctx.moveTo(edge1.x1, edge1.y1);
	ctx.lineTo(edge1.x2, edge1.y2);
	ctx.lineTo(edge2.x2, edge2.y2);
	ctx.lineTo(edge2.x1, edge2.y1);
	ctx.closePath();
	ctx.fill();
	
	ctx.fillStyle = color2; // 0.1
	ctx.beginPath();
	ctx.moveTo(edge2.x1, edge2.y1);
	ctx.lineTo(edge2.x2, edge2.y2);
	ctx.lineTo(edge3.x2, edge3.y2);
	ctx.lineTo(edge3.x1, edge3.y1);
	ctx.closePath();
	ctx.fill();
}

function drawLandShading(px, py, drawLines, scale1, scale2, scale3, color1, color2, offX = 0, offY = 0){
	if(drawLines.length > 0){
		for (let i = 0; i < drawLines.length; i++) {
			let ival = drawLines[i];
			// 1, 0.9, 0.6
			drawFilledShadingLine(px, py, ival, scale1, scale2, scale3, color1, color2, offX, offY);
		}
	}
}


function drawShoreShading(px, py, drawLines, scale1, scale2, scale3, color1, color2){
	// Calculate the "Down" vector relative to current rotation.
	// This ensures the shadow always falls towards the bottom of the monitor.
	// 'waterShadingHeight' is your global depth constant.
	const r = viewport.rotation;

	// We want the vector (0, height) in Screen Space.
	// To get that in our Rotated World Space, we rotate it by -r.
	const offX = waterShadingHeight * Math.sin(r);
	const offY = waterShadingHeight * Math.cos(r);

	if(drawLines.length > 0){
		for (let i = 0; i < drawLines.length; i++) {
			let ival = drawLines[i];
			let worldAngle = getSideAngle(ival) * Math.PI/180;
			let cameraAngle = viewport.rotation;

			// clockwise camera -> add
			let screenAngle = norm180(worldAngle + cameraAngle);

			let dy = Math.sin(screenAngle);
			let hide_shading = dy > 0.8;

			if (!hide_shading) {
				drawFilledShadingLine(px, py, ival, scale1, scale2, scale3, color1, color2, offX, offY);
			}
		}
	}
}


// 2. Update drawWaterShading to calculate the "Screen Down" vector
function drawWaterShading(px, py, drawLines, color = "rgba(0,0,0, 0.6)"){
	// Calculate the "Down" vector relative to current rotation.
	// This ensures the shadow always falls towards the bottom of the monitor.
	// 'waterShadingHeight' is your global depth constant.
	const r = viewport.rotation;

	// We want the vector (0, height) in Screen Space.
	// To get that in our Rotated World Space, we rotate it by -r.
	const offX = waterShadingHeight * Math.sin(r);
	const offY = waterShadingHeight * Math.cos(r);

	if(drawLines.length > 0){
		ctx.fillStyle = color;
		

		for (let i = 0; i < drawLines.length; i++) {

			let ival = drawLines[i];

			let worldAngle = getSideAngle(ival) * Math.PI/180;
			let cameraAngle = viewport.rotation;

			// clockwise camera -> add
			let screenAngle = norm180(worldAngle + cameraAngle);

			let dy = Math.sin(screenAngle);
			let show_shading = dy > 0; // hide if pointing up

			if (show_shading) {
				const x1 = px + HEX_SIZE * HEX_CORNERS[ival].x;
				const y1 = py + HEX_SIZE * HEX_CORNERS[ival].y;
				const x2 = px + HEX_SIZE * HEX_CORNERS[ival+1].x;
				const y2 = py + HEX_SIZE * HEX_CORNERS[ival+1].y;

				drawFilledLine(x1, y1, x2, y2, offX, offY);
				
				
			}
		}
	}
}







function drawHexagonPathLines(px, py, drawLines = null, scale = 1) {
	if(drawLines){
		if(drawLines.length > 0){
			ctx.beginPath();
			for(let i = 0; i < drawLines.length; i++){
				let ival = drawLines[i]; // convert getHexNeighbors indexes to i multiplier value for calculations of angles.
				drawHexLine(ival, px, py, scale);
			}
			//ctx.closePath(); // only needed for drawing filled/complete hex.
		}
	}else{
		const r = HEX_SIZE * scale;
		
		// draw all lines in one go:
		ctx.beginPath();
		ctx.moveTo(
			px + r * HEX_CORNERS[0].x, 
			py + r * HEX_CORNERS[0].y
		);
		for (let ival = 1; ival < 6; ival++) {
			ctx.lineTo(
				px + r * HEX_CORNERS[ival].x, 
				py + r * HEX_CORNERS[ival].y
			);
		}
		ctx.closePath(); // complete the hex.
	}
}




// drawLines = array of values 0-5
// 0 = bottom left
// 1 = top left
// 2 = Top
// 3 = top right
// 4 = bottom right
// 5 = bottom
function drawHexagonPath(px, py, padding = 0) {
	const r = HEX_SIZE + padding;
	ctx.beginPath();
	// Unrolled loop for speed and no Math.cos/sin calls
	ctx.moveTo(px + r * HEX_CORNERS[0].x, py + r * HEX_CORNERS[0].y);
	ctx.lineTo(px + r * HEX_CORNERS[1].x, py + r * HEX_CORNERS[1].y);
	ctx.lineTo(px + r * HEX_CORNERS[2].x, py + r * HEX_CORNERS[2].y);
	ctx.lineTo(px + r * HEX_CORNERS[3].x, py + r * HEX_CORNERS[3].y);
	ctx.lineTo(px + r * HEX_CORNERS[4].x, py + r * HEX_CORNERS[4].y);
	ctx.lineTo(px + r * HEX_CORNERS[5].x, py + r * HEX_CORNERS[5].y);
	ctx.closePath();
}

function drawHexagonPathRotated(px, py, padding = 0, rotationRad = 0) {
	const r = HEX_SIZE + padding;
	ctx.beginPath();
	for (let i = 0; i < 6; i++) {
		const angle = 2 * Math.PI / 6 * (i + 1);
		let x = Math.cos(angle+rotationRad);
		let y = Math.sin(angle+rotationRad);
		if(i === 0){
			ctx.moveTo(px + r * x, py + r * y);
		}else{
			ctx.lineTo(px + r * x, py + r * y);
		}
	}
	ctx.closePath();
}





let GM = 20;

function drawImageMipped(ctx, imageName, dx, dy, dWidth, dHeight, miplevel = -1){
	const imgObj = imageAssets[imageName];
	if(miplevel == -1) miplevel = zoomMipLevel;
	const mip = getMipmapForZoom(imgObj, miplevel);
	ctx.drawImage(mip, dx, dy, dWidth, dHeight);
	//ctx.drawImage(mip, dx, dy, dWidth, dHeight);
}






function drawImageMippedCropped(ctx, imageName, dx, dy, dWidth, dHeight, miplevel = -1, cropBottomPercent = 0){
	const imgObj = imageAssets[imageName];
	if(miplevel == -1) miplevel = zoomMipLevel;
	const mip = getMipmapForZoom(imgObj, miplevel);
	//ctx.drawImage(mip, dx, dy, dWidth, dHeight);
	//console.warn(imgObj);
	//console.warn(mip);
	
	const cropHeight = mip.height - mip.height*cropBottomPercent;
	ctx.drawImage(
		mip,
		0, 0, mip.width, cropHeight,   // take only the top part
		//dx, dy, dWidth, dHeight * (cropHeight / mip.height)
		
		// to make translate etc work, draw centered around dx,dy:
		dx-dWidth/2, dy-dHeight/2, dWidth, dHeight * (cropHeight / mip.height)
	);
}


function checkCulling(x, y, topEdgeOffset = 0) {
	// 1. Calculate rotation components
	// (If you call this thousands of times per frame, consider pre-calculating these 
	// outside the loop and passing them in)
	const cos = Math.cos(viewport.rotation);
	const sin = Math.sin(viewport.rotation);

	// 2. Rotate the World Point
	// This matches how ctx.rotate() transforms the coordinate system
	const rx = x * cos - y * sin;
	const ry = x * sin + y * cos;

	// 3. Convert to Screen Space
	// Now we apply the zoom and viewport translation to the rotated coordinates
	const screenX = rx * viewport.zoom + viewport.x;
	const screenY = ry * viewport.zoom + viewport.y;

	// 4. Check Screen Boundaries
	// We use HEX_SIZE * zoom as a safety margin so we don't pop objects 
	// out of existence when they are half-off screen.
	const margin = HEX_SIZE * viewport.zoom;

	// Left & Right
	if (screenX < -margin || 
		screenX > canvas.width + margin) {
		return true;
	}

	// Top & Bottom
	// We preserve your topEdgeOffset logic here
	if (screenY < (-HEX_SIZE + topEdgeOffset) * viewport.zoom || 
		screenY > canvas.height + margin) {
		return true;
	}

	return false;
}



function darkenHexColor(color, percentage = 0.8){
	return blendHexColor(color, "#000000", percentage);
}
function lightenHexColor(color, percentage = 0.1){
	return blendHexColor(color, "#FFFFFF", percentage);
}

function hexToRgba(hex, opacity = 1) {
	// Remove the leading '#' if present
	hex = hex.replace(/^#/, '');

	// Handle shorthand hex (e.g. #f53)
	if (hex.length === 3) {
		hex = hex.split('').map(char => char + char).join('');
	}

	// Parse r, g, b values
	const r = parseInt(hex.substring(0, 2), 16);
	const g = parseInt(hex.substring(2, 4), 16);
	const b = parseInt(hex.substring(4, 6), 16);

	// Clamp opacity between 0 and 1
	const alpha = Math.max(0, Math.min(1, opacity));

	return `rgba(${r}, ${g}, ${b}, ${alpha})`;
}


function rgbToHex(r, g, b){
	return "#" + [r, g, b].map(x => x.toString(16).padStart(2, "0")).join("");
}

function hexToRgb(hex){
	hex = hex.replace(/^#/, "");
	if (hex.length === 3) {
		hex = hex.split("").map(x => x + x).join("");
	}
	const num = parseInt(hex, 16);
	return [num >> 16, (num >> 8) & 255, num & 255];
}

function blendHexColor(color1, color2 = "#000000", percentage = 0.5) {
	// Ensure percentage is between 0 and 1
	percentage = Math.min(Math.max(percentage, 0), 1);

	const rgb1 = hexToRgb(color1);
	const rgb2 = hexToRgb(color2);

	// Blend each channel
	const blended = rgb1.map((c, i) => Math.round(c * (1 - percentage) + rgb2[i] * percentage));

	return rgbToHex(blended[0], blended[1], blended[2]);
}



const fpsInfo = document.getElementById("fps-info");
const tilesDrawnInfo = document.getElementById("tiles-drawn-info");
const objectsDrawnInfo = document.getElementById("objects-drawn-info");
const particlesDrawnInfo = document.getElementById("particles-drawn-info");


let lastTime = 0;
let frameCount = 0;

let TILES_DRAWN = 0;
let OBJECTS_DRAWN = 0;

let prev_particles = -1;

function trackFPS(){
	//let timestamp = Date.now();
	let timestamp = performance.now();
	if (!lastTime) lastTime = timestamp;

	const delta = timestamp - lastTime;
  
	if (delta >= 500) {
		let fps = frameCount/(delta/1000);
		//console.log("FPS: "+fps.toFixed(2));
		fpsInfo.textContent = "FPS: "+fps.toFixed(0);
		tilesDrawnInfo.textContent = "Tiles drawn: "+TILES_DRAWN;
		objectsDrawnInfo.textContent = "Objects drawn: "+OBJECTS_DRAWN;
		
		
		
		frameCount = 0;
		lastTime = timestamp;
	}else{
		frameCount++;
	}
	
	// update particles in real time when value changes:
	if(particles.length != prev_particles){
		particlesDrawnInfo.textContent = "Particles drawn: "+particles.length;
		
		prev_particles = particles.length;
	}
	

}


function drawObject(ctx, x, y, objectName, tile = null){
	let imageKey = objectName;
	const img = getImage(imageKey);
	
	if (img && img.complete && img.width > 0) {
		// Draw the image centered and scaled
		let imginfo = getImageSettings(imageKey);
		let scale = imginfo.scale*0.9; // 0.9 global scale
		let ratio = img.height/img.width;
		let drawSize = 50;
		let hsize = drawSize/2;
		let offsetX = imginfo.offsetX;
		let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
		
		// used for ctx.translate:
		let xoff = ((offsetX)*scale);
		let yoff = ((offsetY+10)*ratio*scale);
		
		let dx = x-((hsize-offsetX)*scale);
		let dy = y-((hsize-offsetY+10)*ratio*scale);
		let dw = drawSize*scale;
		let dh = drawSize*ratio*scale;
		
		let cropBottomPercent = 0; // how much from the bottom is cropped out.
		let buildOffsetY = 0;
		
		let draw = true;
		let alpha = 1;
		
		// if drawing actual tile object and not just object by name:
		if(tile){

			
			let animate = true;
			//if(unit.wasSpawned){
			//	animate = false;
			//}
			if(tile.animationFinished){
				animate = false;
			}
			if(tile.creationTime && animate){
				let timeDiff = msNowFloor() - tile.creationTime;
				let animationEnded = false;
				
				// 1 = appear from bottom to up
				if(tile.animationStyle == 1){
					if(timeDiff < animationLenTree){
						// for castles
						// forward in time as much as it should be cut at start:
						let startPercent = 0.19;

						if(tile.object === 'tree'){
							startPercent = 0.20;
						}else if(tile.object === 'grass'){
							startPercent = 0.25;
						}
						let startAnimDiff = timeDiff+animationLenTree*startPercent;
						if(startAnimDiff > animationLenTree){
							startAnimDiff = animationLenTree;
						}
						let animPercent = 1-(startAnimDiff/animationLenTree);
						
						// set crop to start at 20%
						cropBottomPercent = animPercent+startPercent;
						
						buildOffsetY = dh*(1-animPercent)-dh;
					}else{
						animationEnded = true;
					}
				}else if(tile.animationStyle == 2){
					// 2 = appear from zero size to normal size
					
					if(timeDiff < animationLenGrass){
						// for soldiers
						let animPercent = timeDiff/animationLenGrass;
						animPercent = animPercent+0.2;
						if(animPercent > 1){
							animPercent = 1;
						}
						scale = imginfo.scale*0.9*animPercent; // 0.9 global scale
						ratio = img.height/img.width;
						drawSize = 50;
						hsize = drawSize/2;
						offsetX = imginfo.offsetX;
						offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
						
						// used for ctx.translate:
						xoff = ((offsetX)*scale);
						yoff = ((offsetY+10)*ratio*scale);
						
						dx = x-((hsize-offsetX)*scale);
						dy = y-((hsize-offsetY+10)*ratio*scale);
						dw = drawSize*scale;
						dh = drawSize*ratio*scale;
					}else{
						animationEnded = true;
					}
				}
				if(animationEnded){
					cropBottomPercent = 0;
					animate = false;
					tile.animationFinished = 1;
				}
			}
			
			
			// check if mine can be drawn depending whos viewing the game:
			if(tile.objectOwnerIndexes !== undefined && tile.objectOwnerIndexes.length > 0){
				if(!tile.objectOwnerIndexes.includes(localPlayer.playerIndex)){
					if(!REPLAY_ENABLED){
						// not in replay, dont draw enemy mines:
						draw = false;
					}else{
						// if replay, draw "enemy" mines ghosted:
						draw = true;
						alpha = 0.5;
					}
				}
			}

		}
		
		if(draw){
			ctx.save();

			// move to object position
			ctx.translate(x, y);
			// undo viewport rotation
			ctx.rotate(-viewport.rotation);
			// now apply screen-space offsets
			ctx.translate(-xoff, -yoff);
			
			if(alpha < 1){
				ctx.globalAlpha = alpha;
			}

			// draw object:
			drawImageMippedCropped(ctx, imageKey, 0, -buildOffsetY, dw, dh, -1, cropBottomPercent);
			
			ctx.restore();
		}
	}
}





let useAnimatedWater = 1;
let isBigAnimatedWater = 1;

// renderinfinitewater 
let useInfiniteWater = 1;
let drawWaterTiles = 0;


// faster than using translateSelf etc.
function setMatrix(matrix, scale, x, y) {
	matrix.a = scale;  // Scale X
	matrix.b = 0;      // Skew Y
	matrix.c = 0;      // Skew X
	matrix.d = scale;  // Scale Y
	matrix.e = x;      // Translate X
	matrix.f = y;      // Translate Y
}

let infiniteWaterFrame = 0;

// draw water draw infinitewater draw infinite water render infinitewater render infinite water
function drawInfiniteWater(){

	let waterZoomMipLevel = getZoomMipLevel(0.6); // smaller = earlier switch to smaller image
	let waterAnimZoomMipLevel = getZoomMipLevel(1.6); // smaller = earlier switch to smaller image
	let bigWaterAnimZoomMipLevel = getZoomMipLevel(1.6); // smaller = earlier switch to smaller image


	if(useInfiniteWater){
		if(useAnimatedWater){
			if(isBigAnimatedWater){
				
				//////////////////////////////////////
				// currently used water animation method.
				//
				
				const patternObj = imageAssets['water-anim-big'];
				if (patternObj && patternObj.isAnimated) {
					const now = performance.now();
					if (now - patternObj.lastFrameTime >= patternObj.frameDuration) {
						patternObj.currentFrame = (patternObj.currentFrame + 1) % patternObj.frameCount;
						// skip first frame, since its same as last frame:
						// TODO: remove the first frame image from the actual image frames array to save memory.
						if(patternObj.currentFrame == 0) patternObj.currentFrame = 1;
						patternObj.lastFrameTime = now;
					}

					const frame = patternObj.animFrames[patternObj.currentFrame];
					const pattern = frame.patterns[bigWaterAnimZoomMipLevel];
					const mipScale = Math.pow(0.5, bigWaterAnimZoomMipLevel);

					//matrixInfiniteWater.setMatrixValue(""); // Reset to identity (or use logic to reset)
					//matrixInfiniteWater.translateSelf(viewport.x, viewport.y);
					//matrixInfiniteWater.scaleSelf(viewport.zoom * 1.6 / mipScale);
					
					// calculate scrolling in x axis for water, apply zoom difference so it will move faster when zoomed in (always same ratio).
					let waterScrollRight = (infiniteWaterFrame/5)*viewport.zoom;
					
					setMatrix(matrixInfiniteWater, 
						viewport.zoom * 1.6 / mipScale, 
						viewport.x+waterScrollRight, viewport.y
					);
					infiniteWaterFrame++;
					
					pattern.setTransform(matrixInfiniteWater);
					
					//const matrix = new DOMMatrix()
					//	.translate(viewport.x, viewport.y)
					//	.scale(viewport.zoom * 1.6 / mipScale);
					//pattern.setTransform(matrix);
					ctx.fillStyle = pattern;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
				}
			}else{
				const patternObj = imageAssets['water-anim'];
				if (patternObj && patternObj.isAnimated) {
					const now = performance.now();
					if (now - patternObj.lastFrameTime >= patternObj.frameDuration) {
						patternObj.currentFrame = (patternObj.currentFrame + 1) % patternObj.frameCount;
						patternObj.lastFrameTime = now;
					}

					const frame = patternObj.animFrames[patternObj.currentFrame];
					const pattern = frame.patterns[waterAnimZoomMipLevel];
					const mipScale = Math.pow(0.5, waterAnimZoomMipLevel);

					//matrixInfiniteWater.setMatrixValue(""); // Reset to identity (or use logic to reset)
					//matrixInfiniteWater.translateSelf(viewport.x, viewport.y);
					//matrixInfiniteWater.scaleSelf(viewport.zoom * 2.4 / mipScale);
					setMatrix(matrixInfiniteWater, 
						viewport.zoom * 2.4 / mipScale, 
						viewport.x, viewport.y
					);
					pattern.setTransform(matrixInfiniteWater);
					
					//const matrix = new DOMMatrix()
					//	.translate(viewport.x, viewport.y)
					//	.scale(viewport.zoom * 2.4 / mipScale);
					//pattern.setTransform(matrix);
					
					ctx.fillStyle = pattern;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
				}
			}

		}else{
			const patternObj = imageAssets['infinitewater'];
			// get current mip level image pattern:
			const pattern = patternObj.patterns[waterZoomMipLevel];
			const mipScale = Math.pow(0.5, waterZoomMipLevel);
			
			//matrixInfiniteWater.setMatrixValue(""); // Reset to identity (or use logic to reset)
			//matrixInfiniteWater.translateSelf(viewport.x, viewport.y);
			//matrixInfiniteWater.scaleSelf(viewport.zoom * 0.4 / mipScale);
			setMatrix(matrixInfiniteWater, 
				viewport.zoom * 0.4 / mipScale, 
				viewport.x, viewport.y
			);
			pattern.setTransform(matrixInfiniteWater);
			
			//const matrix = new DOMMatrix()
			//	.translate(viewport.x, viewport.y) 
			//	.scale(viewport.zoom*0.4/mipScale); // mipScale = scale to different mip level
			//pattern.setTransform(matrix);

			ctx.fillStyle = pattern;
			ctx.fillRect(0, 0, canvas.width, canvas.height);
		}
	}else{
		// default clear without textures.
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}
}



// * Returns a new CanvasPattern with a color multiplied on top of the original pattern.
// * @param {CanvasRenderingContext2D} ctx - The target context to create the pattern for.
// * @param {CanvasPattern} pattern - The cached pattern to colorize.
// * @param {string} color - The color to multiply with, e.g., "#ff0000".
// * @param {number} width - Width of the pattern tile.
// * @param {number} height - Height of the pattern tile.
// * @returns {CanvasPattern} - A new CanvasPattern with the color applied.
function createColoredPattern(ctx, pattern, color, width, height) {
	// Offscreen canvas to render the colored pattern
	const off = document.createElement("canvas");
	off.width = width;
	off.height = height;
	const offCtx = off.getContext("2d");

	// Draw the original pattern onto the offscreen canvas
	offCtx.fillStyle = pattern;
	offCtx.fillRect(0, 0, width, height);

	// Apply the color using multiply
	offCtx.globalCompositeOperation = "multiply";
	offCtx.fillStyle = color;
	offCtx.fillRect(0, 0, width, height);

	// Reset composite operation
	offCtx.globalCompositeOperation = "source-over";

	// Create a new pattern from the offscreen canvas
	return ctx.createPattern(off, "repeat");
}






//let drawnTiles = 0;
//let previous_drawnTiles = 0;
let drawDebugText = 0;



function getTexMipLevel(){
	let miplevel = zoomMipLevel;
	if(miplevel == -1) miplevel = zoomMipLevel;
	return miplevel;
}

function getTexMipScale(){
	return Math.pow(0.5, getTexMipLevel());
}

function transformPattern(imageName){
	//let miplevel = getTexMipLevel();
	//const patternObj = imageAssets[imageName];
	//const pattern = imageAssets[imageName].patterns[miplevel];

	//const mipScale = Math.pow(0.5, miplevel);
	//const scaleMatrix = new DOMMatrix().scaleSelf(1/getTexMipScale());
	//pattern.setTransform(scaleMatrix); // scaleMatrix set in render function each frame.
	imageAssets[imageName].patterns[getTexMipLevel()].setTransform(scaleMatrix); // scaleMatrix set in render function each frame.

}

function fillPattern(ctx, imageName){
	//let miplevel = getTexMipLevel();
	//const patternObj = imageAssets[imageName];
	//const pattern = patternObj.patterns[miplevel];
	//pattern.setTransform(scaleMatrix); // scaleMatrix set in render function each frame.
	//transformPattern(imageName);
	ctx.fillStyle = imageAssets[imageName].patterns[getTexMipLevel()];
	ctx.fill();
}


// expensive for garbage collector to create every frame, just create once.
let scaleMatrix = new DOMMatrix();
let matrixInfiniteWater = new DOMMatrix();
let hex_pad = 0;
let reversed = 0;
let drawtextures = 1;



// type = 0 = (water 3d effect), 1 = water shores, 2 = tiles shading.
function drawMapShading(type){
	let pulse = pulseScale(0.8, 1, 0.002);
	
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		//const { x, y } = axialToPixel(q, r);
		const x = axialToPixelX(q, r);
		const y = axialToPixelY(q, r);

		// --- Culling Check ---
		if(checkCulling(x, y, -waterShadingHeight)){
			continue;
		}
		
		// draw shadows/shading for land tiles next to water:
		// draw map outlines:
		// renderoutlines render outlines
		if(getTileType(tile) !== 'water'){
			if(tile.outline){
				let player = getPlayerByIndex(tile.ownerIndex);
				let color;
				if(player){
					//color = hexToRgba(darkenHexColor(player.color, 0.8), 0.8);
					color = darkenHexColor(player.color, 0.8);
				}else{
					//color = hexToRgba(darkenHexColor("#705F4B", 0.8), 0.8);
					color = "#16181C";
					//       #16181C blueish dark brown seems best, darker brown pops up too much.
					//       #18140C dark brown
				}
				
				if(type === 0){ // water 3d
					drawWaterShading(x, y, tile.outline, color);
				}else if(type === 2){ // land shading
					drawLandShading(x, y, tile.outline, 1, 0.9, 0.6, "rgba(0,0,0, 0.3)", "rgba(0,0,0, 0.1)");
				}
			}
		}else{
			if(type === 1){ // shore shading
			
				// draw shores with lighter water by transparent hex:
				const r = viewport.rotation;

				// We want the vector (0, height) in Screen Space.
				// To get that in our Rotated World Space, we rotate it by -r.
				const offX = waterShadingHeight * Math.sin(r);
				const offY = waterShadingHeight * Math.cos(r);
				
				//ctx.save(); // probably not necessary here since the other drawings doesnt use them either.
				drawHexagonPath(x+offX, y+offY);
				ctx.fillStyle = "rgba(200,200,255, 0.035)";
				ctx.fill();
				//ctx.restore();
				
				drawShoreShading(x, y, tile.outline, 1, 0.9*pulse, 0.7*pulse*pulse, "rgba(200,200,255, 0.2)", "rgba(200,200,255, 0.1)");
			}
		}
	}
}


function drawPlayerTile(x, y, playerIndex){
	let player = getPlayerByIndex(playerIndex);
	
	
	ctx.save(); // needed for hex drawing.
	
	// Define the hex path
	// for dirt hex.
	drawHexagonPath(x, y);


	let imageName = getDirtTileName();
	let img = getImage(imageName);

	// 4. If image is loaded, draw it clipped and scaled
	if (img && img.complete && img.width > 0) {
		ctx.clip(); // Apply clip to the hex path

		// Calculate the "pointy-top" hex bounding box
		const hexWidth = HEX_SIZE * SQRT3*GS;
		const hexHeight = HEX_SIZE * 2;
		
		// Calculate "scale-to-fit" (contain) ratio
		const ratio = Math.min(hexWidth / img.width, hexHeight / img.height);
		const dWidth = img.width * ratio;
		const dHeight = img.height * ratio;
		
		// Calculate centered destination (dx, dy)
		const dx = x - dWidth / 2;
		const dy = y - dHeight / 2;
		
		let textureType = 0;
		
		if(player.textureType !== undefined){
			textureType = player.textureType;
			// make sure wont read out of array if someone messed with textures changes:
			if(textureType > landTextures.length-1){
				textureType = landTextures.length-1;
			}
		}
		
		let textureName = landTextures[textureType];

		let color = player.color;
		
		
		drawImageMipped(ctx, textureName, dx, dy, dWidth, dHeight, tileZoomMipLevel);

		
		// Multiply by player color
		ctx.globalCompositeOperation = "multiply";
		ctx.fillStyle = color; // e.g. "#ff0000"
		ctx.fillRect(dx, dy, dWidth, dHeight);
		ctx.globalCompositeOperation = "source-over";
	}
	
	ctx.restore();
}



function drawDirtTile(x, y){

	ctx.save(); // needed for hex drawing.
	
	// Define the hex path
	// for dirt hex.
	drawHexagonPath(x, y);
	
	let imageName = getDirtTileName();
	let img = getImage(imageName);

	// 4. If image is loaded, draw it clipped and scaled
	if (img && img.complete && img.width > 0) {
		ctx.clip(); // Apply clip to the hex path

		// Calculate the "pointy-top" hex bounding box
		const hexWidth = HEX_SIZE * SQRT3*GS;
		const hexHeight = HEX_SIZE * 2;
		
		// Calculate "scale-to-fit" (contain) ratio
		const ratio = Math.min(hexWidth / img.width, hexHeight / img.height);
		const dWidth = img.width * ratio;
		const dHeight = img.height * ratio;
		
		// Calculate centered destination (dx, dy)
		const dx = x - dWidth / 2;
		const dy = y - dHeight / 2;
		
		drawImageMipped(ctx, imageName, dx, dy, dWidth, dHeight, tileZoomMipLevel);
	}
	
	ctx.restore();
}



// get the percent size of appearing tiles (used in drawmaptiles and drawhighlights lines drawing)
// percentMultiplier = simply multiplies the percent, used in the lines drawing to keep lines outside the hex.
function getAppearingPercent(tile, percentMultiplier = 1){
	let tileAppearingPercent = 0;
	
	let startPercent = 0.2;
	let tileAnimationLen = 500;
	
	let timeDiff = performance.now() - tile.appearStartTime;
	// make it start animation from 20% size:
	timeDiff += startPercent*tileAnimationLen;
	
	// draw dirt under the owned tile only if animation is still going on:
	if(timeDiff < tileAnimationLen){
		tileAppearingPercent = (timeDiff/tileAnimationLen)*percentMultiplier; // 1...0
	}
	
	return tileAppearingPercent;
}


let tileZoomMipLevel = 1; // updated at drawMapTiles()




// rendertiles drawtiles rendermaptiles render tiles render map tiles
function drawMapTiles(){
	
	TILES_DRAWN = 0;

	tileZoomMipLevel = getZoomMipLevel(0.5); // use normal. smaller = earlier switch to smaller image
	
	// calculate scale matrix for tile textures:

	if(use_fill){
		//scaleMatrix = new DOMMatrix().scaleSelf(1/getTexMipScale());
		scaleMatrix.setMatrixValue(""); // Reset to identity (or use logic to reset)
		//scaleMatrix.translateSelf(viewport.x, viewport.y);
		scaleMatrix.scaleSelf(1/getTexMipScale());

		transformPattern(getDirtTileName());
	}
	
	
	// --- DRAW TILES ---
	// draw only the tiles that exists. (old code had 2 for loops for q and r ranges...)
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		//const { x, y } = axialToPixel(q, r);
		const x = axialToPixelX(q, r);
		const y = axialToPixelY(q, r);

		// all water tiles are actually shores, no water tiles are included after saving map.
		if (getTileType(tile) === 'water') {
			//if(useInfiniteWater){
				continue; // skip water tiles.
			//}
		}
		
		// --- Culling Check ---
		//if(checkCulling(x, y, -waterShadingHeight)){
		if(checkCulling(x, y)){
			continue;
		}
		

		
		let drawTile = true;
		

		// 2. Draw the fallback background color (or owner color)
		let fallbackColor = LAND_COLOR;
		if(getTileType(tile) === 'water'){
			fallbackColor = WATER_COLOR;
			if(!drawWaterTiles){
				drawTile = false;
			}
		}else{/* else if (tile.ownerIndex !== -1) {
			const owner = getPlayerByIndex(tile.ownerIndex);
			fallbackColor = owner ? owner.color : LAND_COLOR;
		} else if (tile.type === 'land') {*/
			// if owned tile:
			if(tile.ownerIndex !== -1){
				const owner = getPlayerByIndex(tile.ownerIndex);
				fallbackColor = owner ? owner.color : LAND_COLOR;
			}else{
				// non-owned tile:
				fallbackColor = LAND_COLOR;
			}
		}
		
		if(!drawTile){
			continue;
		}
		

		let img = null;
		let imageName = "";
		
		//drawnTiles++;
		
		// --- Start Drawing Hex ---

		// anything inside save/restore is clipped to the hex shape.

		// draw dirt texture under the player tile texture while it animates.
		// when animation has ended, this wont be necessary anymore.
		// should set isDead and deadAnimationEnded to false after animation ends,
		// so it matches the default values. or just remove those keys alltogether so they wont be saved.
		let tileSizePad = hex_pad; // hex_pad is for debugging, hex_pad default = zero.
		
		let drawDyingAnim = false;
		let tileDyingPercent = 0;
		
		let drawAppearingAnim = false;
		let tileAppearingPercent = 0;
		
		// not sure if !tile.isAppearing is necessary anymore since isDying etc are deleted if claiming a tile.
		// this was to prevent isDying taking over the rendering.
		if(tile.isDying && !tile.isAppearing){
			let timeDiff = performance.now() - tile.deadStartTime;
			let tileAnimationLen = 3000;
			let maxTileSize = 80; // 80 makes it negative (backwards). for hex_pad (tileSizePad)
			
			// draw dirt under the owned tile only if animation is still going on:
			if(timeDiff < tileAnimationLen){
				drawDyingAnim = true;

				tileDyingPercent = timeDiff/tileAnimationLen; // 0...1
				tileSizePad = -tileDyingPercent*maxTileSize; // 0...-40
				
				drawDirtTile(x, y);
			}else{
				//tile.isDying = false;
				// remove keys so they wont be stored in tilesData anymore.
				delete tile.isDying;
				delete tile.deadStartTime;
				delete tile.deadOwnerIndex;
			}
		}
		
		if(tile.isAppearing){
			let maxTileSize = 40;
			tileAppearingPercent = getAppearingPercent(tile);
			if(tileAppearingPercent){
				tileSizePad = -(1-tileAppearingPercent)*maxTileSize; // -40...0
				
				let showPreviousOwner = false;
				if(tile.powner !== undefined && tile.powner !== -1){
					showPreviousOwner = true;
				}
				
				if(showPreviousOwner){
					drawPlayerTile(x, y, tile.powner);
				}else{
					drawDirtTile(x, y);
				}
			}else{
				// remove keys so they wont be stored in tilesData anymore.
				delete tile.isAppearing;
				delete tile.appearStartTime;
				//delete tile.appearOwnerIndex;
			}
		}
		
		
		ctx.save(); // needed for hex drawing.
		

		
		// Define the hex path
		if(tileDyingPercent){
			// draw rotation-animated and fading hexagon for dying hex:
			let per = tileDyingPercent*1.5; // 1.5x so it will be fully opaque when going down to zero size.
			ctx.globalAlpha = 1.5-per;
			// for grass hex,
			drawHexagonPathRotated(x, y, tileSizePad, per*Math.PI*3);
		}else if(tileAppearingPercent){
			drawHexagonPath(x, y, tileSizePad);
		}else{
			// for dirt OR grass hex.
			drawHexagonPath(x, y, tileSizePad);
		}
		
		
		//ctx.fillStyle = fallbackColor;
		//ctx.fill();

		// useimages = false for testing performance without tile images.
		if(useimages){
			// 3. Get the background image for this tile type
			// (We assume the image key is the same as tile.type)
			let ownerIndex = tile.ownerIndex;
			if(drawDyingAnim){
				ownerIndex = tile.deadOwnerIndex;
			}
			
			
			img = null;
			imageName = "";
			if(ownerIndex !== -1){
				imageName = 'land'; // tile.type
				img = getImage(imageName);
			}else{
				// no owner, use dirt image:
				if(getTileType(tile) === 'water') {
					imageName = 'water';
					img = getImage(imageName);
				}else{
					if(getTileType(tile) === 'land'){
						imageName = getDirtTileName();
					}else{
						imageName = tile.type;
					}
					//img = getImage(imageName);
					img = getImage(imageName);
					
				}
			}
			if(previewdraw){
				imageName = getDirtTileName();
				img = getImage(imageName);
			}
			


			// 4. If image is loaded, draw it clipped and scaled
			if (img && img.complete && img.width > 0) {
				ctx.clip(); // Apply clip to the hex path

				// Calculate the "pointy-top" hex bounding box
				const hexWidth = HEX_SIZE * SQRT3*GS;
				const hexHeight = HEX_SIZE * 2;
				
				// Calculate "scale-to-fit" (contain) ratio
				const ratio = Math.min(hexWidth / img.width, hexHeight / img.height);
				const dWidth = img.width * ratio;
				const dHeight = img.height * ratio;
				
				// Calculate centered destination (dx, dy)
				const dx = x - dWidth / 2;
				const dy = y - dHeight / 2;
				
				if(ownerIndex !== -1 && !previewdraw){
					// Draw the gray texture (owned land) with multiply operation:
					const player = getPlayerByIndex(ownerIndex);
					
					if(drawtextures){
						
						let textureType = 0;
						
						if(player.textureType !== undefined){
							textureType = player.textureType;
							// make sure wont read out of array if someone messed with textures changes:
							if(textureType > landTextures.length-1){
								textureType = landTextures.length-1;
							}
						}
						
						let textureName = landTextures[textureType];
						// change dead players textures to skull texture:
						//if(player.isDead){
						//	textureName = 'land-dead';
						//}
						let color = player.color;
						
						
						drawImageMipped(ctx, textureName, dx, dy, dWidth, dHeight, tileZoomMipLevel);

						
						
						
						
						if(!tile.isProtected){
							// showing unprotected lands might make game boring, also confusing when it shows different color.
							//color = lightenHexColor(player.color, 0.2);
						}
						// todo: make own images for each player texture?
						// Multiply by player color
						ctx.globalCompositeOperation = "multiply";
						ctx.fillStyle = color; // e.g. "#ff0000"
						ctx.fillRect(dx, dy, dWidth, dHeight);
						ctx.globalCompositeOperation = "source-over";
					}
					
					// draw tile savings debug info:
					//drawText(x, y, tile.savings);
					if(drawDebugText){
						ctx.fillStyle = "#FFFFFF";
						ctx.font = "11px sans-serif";
						
						ctx.fillText(formatNumber(tile.savings, 8), x, y+22);
					}
				
					
				}else{
					// draw dirt image:
					
					if(drawtextures){
						if(use_fill){
							// slower... todo: think how to speed up.
							fillPattern(ctx, imageName);
						}else{
							drawImageMipped(ctx, imageName, dx, dy, dWidth, dHeight, tileZoomMipLevel);
						}

					}
					
					
					if(drawDebugText){
						ctx.fillStyle = "#000000";
						ctx.font = "11px sans-serif";
	
						ctx.fillText(formatNumber(tile.savings, 4), x, y+23);
					}
				
				}
				
				TILES_DRAWN++;

			}
			
		}
		// Restore context (removes clip)
		ctx.restore();
	}
	

	// log how many tiles were drawn to test culling working:
	//if(previous_drawnTiles != drawnTiles){
		//console.log("drawnTiles = "+drawnTiles);
		//previous_drawnTiles = drawnTiles;
	//}
	
}



// renderhighlights
function drawHighlights(){

	let highlightedEnemyPlayer = null;
	let highlightedPlayer = null;
	
	// draw pools edges for all pools:
	if(enemyHighlightedPool.length > 0){
		let tile = getTileAt(enemyHighlightedPool[0].q, enemyHighlightedPool[0].r);
		highlightedEnemyPlayer = getPlayerByIndex(tile.ownerIndex);
	}
	
	if(highlightedPool.length > 0){
		// pool length is zero if no pool selected.
		let tile = getTileAt(highlightedPool[0].q, highlightedPool[0].r);
		highlightedPlayer = getPlayerByIndex(tile.ownerIndex);
	}
	// use selectedPool for highlighting:
	//if(selectedPool && selectedPool.hexes && selectedPool.hexes.length > 0){
	//	let tile = getTileAt(selectedPool.hexes[0].q, selectedPool.hexes[0].r);
	//	highlightedPlayer = getPlayerByIndex(tile.ownerIndex);
	//}


	// draw highlighted lines for all pools:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		//const { x, y } = axialToPixel(q, r);
		const x = axialToPixelX(q, r);
		const y = axialToPixelY(q, r);

		if (getTileType(tile) === 'water') {
			if(useInfiniteWater){
				continue; // skip water tiles.
			}
		}
		
		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		
		// dont draw edges if tile appearing animation is going on:
		//if(tile.isAppearing){
		//	continue;
		//}

		
		
		if(tile.ownerIndex !== -1){
			let neighbours = tile.neighbours;
			if(neighbours && neighbours.length > 0){
				let highlightedLines = [];
				// ({tileIndex: nTile.tileIndex, neighbourIndex: i, q: n.q, r: n.r}
				// [q,r,tileIndex] (NEW FORMAT for smaller gamestate.maptiles)
				for(let n = 0; n < neighbours.length; n++){
					//let neigh = neighbours[n];
					let neighTileIndex = neighbours[n];
					let neighbourIndex = n;
					// -1 = water tile:
					if(neighTileIndex != -1){
						let nTile = gameState.map.tilesData[neighTileIndex];
						if(nTile.ownerIndex !== tile.ownerIndex){
							//console.log(nTile.ownerIndex, tile.ownerIndex);
							highlightedLines.push(neighbourIndex);
						}
					}else{
						// water tiles: add by default.
						highlightedLines.push(neighbourIndex);
					}
				}
				
				
				if(highlightedLines.length > 0){
					// set line radius multiplier:
					// - draws selected pools lines inside the hex, so the lines wont overlap which makes it hard to see colors.
					// - fixed to HEX_SIZE and the line width. if any of them changed, this multiplier needs to be changed.
					let linemulti = HEX_LINE_MULTI;
					if(tile.isAppearing){
						linemulti = getAppearingPercent(tile, HEX_LINE_MULTI);
					}
					
					drawHexagonPathLines(x, y, highlightedLines, linemulti);
					//drawHexagonPathLines(x, y, [0,1,2,3,4,5]);
					
					let player = getPlayerByIndex(tile.ownerIndex);
					let color = lightenHexColor(player.color, 0.1);
					let opacity = 0.5;
					let dashedMode = 0;
					
					let poolSelected = 0;
					
					if(highlightedEnemyPlayer){
						if(highlightedEnemyPlayer.playerIndex === tile.ownerIndex){
							opacity = 1;
							color = lightenHexColor(player.color, 0.6);
							poolSelected = 1;
						}
					}
					
					if(highlightedPlayer){
						if(highlightedPlayer.playerIndex === tile.ownerIndex){
							dashedMode = 1;
						}
					}
					
					if(dashedMode){
						// your pool highlight
						
						let isSelectedPool = false;
						// check if this tile is currently selected individual pool:
						if(highlightedPool && highlightedPool.length > 0){
							for(let p = 0; p < highlightedPool.length; p++){
								let pool = highlightedPool[p];
								if(pool.q == q && pool.r == r){
									isSelectedPool = true;
									break;
								}
							}
						}


						ctx.setLineDash([12.5, 15]);
						if(isSelectedPool){
							ctx.strokeStyle = 'rgba(255,255,0, 1)';
							ctx.lineWidth = 4;
						}else{
							ctx.strokeStyle = 'rgba(255,255,255, 1)';
							ctx.lineWidth = 3;
						}
						
						ctx.lineCap = 'round';
						ctx.stroke();
						ctx.lineCap = 'butt'; // reset to default
						ctx.setLineDash([]);

						
					}else{
						let drawEdges = true;
						if(!gameSettings.drawPoolEdges && !poolSelected){
							drawEdges = false;
						}
						if(drawEdges){
							// enemy pool highlight
							let pulse = 1;
							if(poolSelected){
								pulse = pulseScale(0.3, 1.0, 0.008);
							}
							ctx.strokeStyle = hexToRgba(color, opacity*pulse);
							ctx.lineWidth = 3;
							ctx.lineCap = 'round';
							ctx.stroke();
							ctx.lineCap = 'butt'; // reset to default
						}
					}
				}
			}
		}
	}
	

}



let draw_objects = 1;

// renderobjects
function drawObjects(){
	OBJECTS_DRAWN = 0;

	if(!draw_objects){
		return;
	}
	
	// Draw objects (trees etc) on top of pool edges:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;

		//const { x, y } = axialToPixel(q, r);
		const x = axialToPixelX(q, r);
		const y = axialToPixelY(q, r);

		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		
		if (tile.object) {
			let object = tile.object;
			if(!isSummer()){
				if(object === 'grass'){
					object = 'grass-winter';
				}else if(object === 'rock2'){
					object = 'rock-winter';
				}else if(object === 'tree'){
					object = 'tree-winter';
				}else if(object === 'mine1'){
					object = 'mine-winter';
				}else if(object === 'landmine'){
					object = 'landmine-winter';
				}
			}
			drawObject(ctx, x, y, object, tile);
			OBJECTS_DRAWN++;
		}
		
	}
}


let animationLenCastle = 600;
let animationLenSoldier = 250;

let animationLenTree = 600;
let animationLenGrass = 400;

// draw only specific type of units; "soldier" or "castle"
function drawUnitsByInternalType(unitType){
	for (const unit of gameState.units) {
		if(unit.internalType !== unitType){
			continue;
		}
		
		//let { x, y } = axialToPixel(unit.q, unit.r);
		const x = axialToPixelX(unit.q, unit.r);
		const y = axialToPixelY(unit.q, unit.r);

		// --- Culling Check ---
		if(checkCulling(x, y)){
			continue;
		}
		//unitsDrawn++;
		
		// no idea why this is here... probably loaded game missing players fix?
		const owner = getPlayerByIndex(unit.ownerIndex);
		if (!owner){
			//console.log("owner not found: "+unit.ownerIndex);
			continue;
		}

		const data = getUnitInfo(unit.type);//SOLDIER_DATA[unit.type] || CASTLE_DATA[unit.type];
		
		let animSuffix = "";
		let animationFrames = unitTypeAnimationFramesCount(unit.type);
		if(animationFrames > 1){
		//if(unit.internalType === 'soldier'){
			// disabled for now, seems confusing when there is constant movement on screen.
			let useRandomPhase = 0; // 0 or 1 value to enable randomized animation phase.
			
			// causes image to be "soldier1-1.png" etc, the second frame for animation.
			animSuffix = pulseScale(0,1, 0.002, unit.q*unit.r*useRandomPhase) < 0.5 ? "-1" : "";
		}
		let seasonKey = "";
		if(!isSummer()){ 
			if(data.type === 'castle'){
				seasonKey = "-winter";
			}
		}
		
		let imageKey = `${data.defaultImage}${seasonKey}${animSuffix}`;//`${data.type}${data.level}${animSuffix}`;
		const img = getImage(imageKey);
		

		
		if (img && img.complete && img.width > 0) {
			// Draw the image centered and scaled
			let imginfo = getImageSettings(imageKey);
			let scale = imginfo.scale*0.9; // 0.9 global scale
			let ratio = img.height/img.width;
			let drawSize = 50;
			let hsize = drawSize/2;
			let offsetX = imginfo.offsetX;
			let offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
			
			// used for ctx.translate:
			let xoff = ((offsetX)*scale);
			let yoff = ((offsetY+10)*ratio*scale);
			
			//let dx = x-((hsize-offsetX)*scale);
			//let dy = y-((hsize-offsetY+10)*ratio*scale);
			let dw = drawSize*scale;
			let dh = drawSize*ratio*scale;
			
			// draw unit:
			
			
			let cropBottomPercent = 0; // how much from the bottom is cropped out.
			let buildOffsetY = 0;
			
			let animate = true;
			if(unit.wasSpawned){
				animate = false;
			}
			if(unit.animationFinished){
				animate = false;
			}
			if(unit.creationTime && animate){
				let timeDiff = msNowFloor() - unit.creationTime;
				let animationEnded = false;
				
				if(unit.animationStyle == 1){
					if(timeDiff < animationLenCastle){
						// for castles
						// forward in time as much as it should be cut at start:
						let startPercent = 0.19;

						if(unit.type === 'hut'){
							startPercent = 0.19;
						}else if(unit.type === 'castle'){
							startPercent = 0.17;
						}else if(unit.type === 'fortress'){
							startPercent = 0.15;
						}
						let startAnimDiff = timeDiff+animationLenCastle*startPercent;
						if(startAnimDiff > animationLenCastle){
							startAnimDiff = animationLenCastle;
						}
						let animPercent = 1-(startAnimDiff/animationLenCastle);
						
						// set crop to start at 20%
						cropBottomPercent = animPercent+startPercent;
						
						buildOffsetY = dh*(1-animPercent)-dh;
					}else{
						animationEnded = true;
					}
				}else if(unit.animationStyle == 2){
					if(timeDiff < animationLenSoldier){
						// for soldiers
						let animPercent = timeDiff/animationLenSoldier;
						animPercent = animPercent+0.2;
						if(animPercent > 1){
							animPercent = 1;
						}
						scale = imginfo.scale*0.9*animPercent; // 0.9 global scale
						ratio = img.height/img.width;
						drawSize = 50;
						hsize = drawSize/2;
						offsetX = imginfo.offsetX;
						offsetY = imginfo.offsetY ? imginfo.offsetY : 0;
						
						// used for ctx.translate:
						xoff = ((offsetX)*scale);
						yoff = ((offsetY+10)*ratio*scale);
						
						//dx = x-((hsize-offsetX)*scale);
						//dy = y-((hsize-offsetY+10)*ratio*scale);
						dw = drawSize*scale;
						dh = drawSize*ratio*scale;
					}else{
						animationEnded = true;
					}
				}
				if(animationEnded){
					cropBottomPercent = 0;
					animate = false;
					unit.animationFinished = 1;
				}
			}
			
			ctx.save();
			
			// move to object position
			ctx.translate(x, y);
			// undo viewport rotation
			ctx.rotate(-viewport.rotation);
			// now apply screen-space offsets
			ctx.translate(-xoff, -yoff);
			
			// draw unit:
			drawImageMippedCropped(ctx, imageKey, 0, -buildOffsetY, dw, dh, -1, cropBottomPercent);
			
			if(unitType === 'boat'){
				// show extra info only for the owner of the boat:
				if(unit.ownerIndex === localPlayer.playerIndex){
					let daysLeft = unit.maxDays - (gameState.turn.turnNumber - unit.dayBuilt);
					// draw loaded unit on top of the boat unit:
					if(unit.loadedUnit){
						const loadedUnitInfo = getUnitInfo(unit.loadedUnit.type);
						
						drawImageMippedCropped(ctx, loadedUnitInfo.defaultImage, 0, 0, 40, 40, -1, 0);
					}
					drawStrokedText(daysLeft, -25);
					
				}
			}

			ctx.restore();
			
			
			//drawImageMippedCropped(ctx, imageKey, dx, dy-buildOffsetY, dw, dh, -1, cropBottomPercent);
		}
	}
}


function drawUnitsRoutes(){
	ctx.save();
	for (const unit of gameState.units) {
		// draw boat routes:
		if(unit.route){
			drawRouteLines(unit.route, "rgba(255, 255, 255, 0.4)", true);
		}
		// draw soldier routes:
		if(unit.pq !== undefined){
			if(focusedHex){
				if(unit.q === focusedHex.q && unit.r === focusedHex.r){
					let route = [
						{q: unit.pq, r: unit.pr}, 
						{q: unit.q, r: unit.r},
					];
					drawRouteLines(route, "rgba(255, 255, 0, 0.6)", true, 3);
				}
			}

		}
	}
	ctx.restore();
}

// renderunits render units
function drawUnits(){
	
	// drawboatroutes draw boat routes draw unit routes drawunitroutes
	drawUnitsRoutes();
	
	// draw all units, castles first:
	drawUnitsByInternalType("castle");
	drawUnitsByInternalType("soldier");
	drawUnitsByInternalType("boat");
	drawUnitsByInternalType("mine");
	//drawUnitsByInternalType("cannon"); // todo: make the code.
	
	let pulseOffsetX = 10+(-8*pulseScale(0,2, PULSE_SPEED));
	
	let currentTurnPlayer = getCurrentTurnPlayer();
	
	
	// draw arrow signs after units (yellow triangles):
	// drawarrows draw arrows renderarrows render arrows drawing draw triangles drawtriangles
	if(isMyTurn() && !gameState.settings.gameOver){

		for (const unit of gameState.units) {
			//let { x, y } = axialToPixel(unit.q, unit.r);
			const x = axialToPixelX(unit.q, unit.r);
			const y = axialToPixelY(unit.q, unit.r);
			
			// --- Culling Check ---
			if(checkCulling(x, y)){
				continue;
			}
			
			// dont draw arrow for selected unit
			if(selectedUnit){
				if(selectedUnit.q === unit.q && selectedUnit.r === unit.r){
					continue;
				}
			}
			// no idea why this is here... probably loaded game missing players fix?
			//const owner = getPlayerByIndex(unit.ownerIndex);
			//if (!owner) continue;

			//const data = SOLDIER_DATA[unit.type] || CASTLE_DATA[unit.type];
			
			if(unitTypeCanMove(unit.type)){
				if(currentTurnPlayer.playerIndex === unit.ownerIndex){
					// draw yellow arrow sign:
					if (!unit.hasMoved) {
						ctx.save();
						ctx.translate(x, y);
						ctx.rotate(-viewport.rotation);
						drawTriangle(ctx, pulseOffsetX, 0);
						ctx.restore();
						//drawTriangle(ctx, x+pulseOffsetX, y);
					}
				}
			}
		}
	}
	
	// draw selected unit name on top of it:
	if(selectedUnit){
		const x = axialToPixelX(selectedUnit.q, selectedUnit.r);
		const y = axialToPixelY(selectedUnit.q, selectedUnit.r);
		let dx = x;
		let dy = y;
		let offset = 1;
		
		ctx.save();
		ctx.translate(dx, dy);
		ctx.rotate(-viewport.rotation);

		drawStrokedText(selectedUnit.name, -50);
		
		ctx.restore();
	}
	
	
	
	//console.log("unitsDrawn = "+unitsDrawn);
}


function drawStrokedText(text, offset = 0){
	ctx.font = "14px sans-serif";
	ctx.lineWidth = 3; // outline thickness
	ctx.strokeStyle = "black";
	ctx.fillStyle = "white";
	ctx.lineJoin = "round"; // prevents sharp corners on letters
	ctx.strokeText(text, 0, offset);

	ctx.fillStyle = "white";
	ctx.fillText(text, 0, offset);
}


// rendermovementranges
function drawMovementRanges(){
	


	// Draw movement range
	ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
	for (const hex of validMoveHexes) {
		//const { x, y } = axialToPixel(hex.q, hex.r);
		const x = axialToPixelX(hex.q, hex.r);
		const y = axialToPixelY(hex.q, hex.r);
		drawHexagonPath(x, y);
		ctx.fill();
	}
	
	// Draw invalid move range
	ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
	for (const hex of invalidMoveHexes) {
		//const { x, y } = axialToPixel(hex.q, hex.r);
		const x = axialToPixelX(hex.q, hex.r);
		const y = axialToPixelY(hex.q, hex.r);
		drawHexagonPath(x, y);
		ctx.fill();
	}
}




let prev_highlight = "";
let cur_buildCheck = null;

// renderPlacementHighlight 
function drawPlacementHighlight(){


	// Draw selected hex outline
	if (selectedHex) {
		//const { x, y } = axialToPixel(selectedHex.q, selectedHex.r);
		const x = axialToPixelX(selectedHex.q, selectedHex.r);
		const y = axialToPixelY(selectedHex.q, selectedHex.r);
		
		drawHexagonPathLines(x, y);
		ctx.strokeStyle = 'rgba(255,255,255, 0.4)';
		ctx.lineWidth = 2;
		ctx.lineCap = 'round';
		ctx.stroke();
		ctx.lineCap = 'butt'; // reset to default
	}
	
	
	
	// Draw placement highlight
	if (placingUnit) {
		const mouseHex = pixelToAxial(lastMousePos.x, lastMousePos.y);
		//const { x, y } = axialToPixel(mouseHex.q, mouseHex.r);
		const x = axialToPixelX(mouseHex.q, mouseHex.r);
		const y = axialToPixelY(mouseHex.q, mouseHex.r);
		
		let cur_highlight =  mouseHex.q+", "+mouseHex.r;
		
		// run  isPlacementValid() only when mouse has moved to different hex:
		if(prev_highlight !== cur_highlight){
			//console.warn("prev_drawPlacementHighlight !== curstr");
			
			
			const buildCheck = isPlacementValid(placingUnit.type, mouseHex, getMyPlayer(), getSelectedPoolHex(), false, selectedUnit);
			cur_buildCheck = buildCheck;
			prev_highlight = cur_highlight;
		}

		// draw always with cached info:
		drawHexagonPath(x, y);
		if (cur_buildCheck.valid) {
			ctx.fillStyle = 'rgba(0, 255, 0, 0.4)';
		} else {
			ctx.fillStyle = 'rgba(255, 0, 255, 0.4)';
		}
		ctx.fill();
	}
}

function pulseScale(min, max, speed = 0.003, sinoffset = 0) {
	const t = performance.now() * speed;
	const n = (Math.sin(t+sinoffset) + 1) / 2; // 0 â†’ 1
	return min + (max - min) * n;
}



function drawUnitSelection(){
	if(selectedUnit){
		//const { x, y } = axialToPixel(selectedUnit.q, selectedUnit.r);
		const x = axialToPixelX(selectedUnit.q, selectedUnit.r);
		const y = axialToPixelY(selectedUnit.q, selectedUnit.r);


		let scale = pulseScale(0.6, HEX_LINE_MULTI, PULSE_SPEED);
		drawHexagonPathLines(x, y, null, scale);
		
		ctx.lineDashOffset = 8*scale;
		let dashes = [16*scale, 24*scale];
		
		
		// your pool highlight
		ctx.setLineDash(dashes);
		ctx.strokeStyle = 'rgba(255,255,255, 1)';
		ctx.lineWidth = 4*scale;
		ctx.lineCap = 'round';
		ctx.stroke();
		ctx.lineCap = 'butt'; // reset to default
		ctx.setLineDash([]);

	}
}



// host only cheat function to give money
function givemoney(amount){
	if(selectedPool && selectedPool.hexes.length > 0){
		selectedPool.hexes[0].tile.savings += amount;
		updatePlayerSavings(getMyPlayer().playerIndex);
		updateSelectedPoolInfo();
		console.log("givemoney = "+amount);
	}
}

function givemoneyall(amount){
	for(let i = 0; i < gameState.map.tilesData.length; i++){
		let tile = gameState.map.tilesData[i];
		if(tile.ownerIndex !== -1){
			tile.savings += amount;
		}
	}
	updatePlayerSavings(getMyPlayer().playerIndex);
	updateSelectedPoolInfo();
	console.log("givemoneyall = "+amount);
}


//==========================================
// CORE PARTICLE LOGIC
//==========================================

// Global array to store all active particles from all explosions
let particles = [];

// Utility: Get random number between min and max
const randomRange = (min, max) => randomFunc() * (max - min) + min;


// Creates an explosion with bouncing physics.
function createExplosion(ep) {
	if(!gameSettings.drawParticles){
		return;
	}
	let x = ep.x;
	let y = ep.y;
	let color = ep.color;
	let shapeMode = ep.shapeMode;
	let fadeMode = ep.fadeMode;
	let amount = ep.amount;
	let initialSpeed = ep.initialSpeed;
	let life = ep.life ?? 1.3;
	let decay = ep.decay ?? { min: 0.01, max: 0.03 };
	let rotationSpeed = ep.rotationSpeed ?? { min: -0.1, max: 0.1 };
	let fadeAtGround = ep.fadeAtGround ?? 0;
	let toFloor = ep.toFloor ?? 0;
	let upSpeedMulti = ep.upSpeedMulti ?? 1;
	let type = ep.type ?? "exp";

	for (let i = 0; i < amount; i++) {
		let speedVariation = initialSpeed * 0.5;
		let speed = randomRange(initialSpeed - speedVariation, initialSpeed + speedVariation);
		let angle = randomFunc() * Math.PI * 2;
		let gravity = 0.25;
		let vz = randomRange(2, 6)*upSpeedMulti;
		let size = randomRange(4, 8);
		if(toFloor){
			vz = randomRange(1, 1.5);
			size = randomRange(1, 3);
			//speed *= 1.5;
		}

		let specificShape = 'circle';
		if (shapeMode == 0) {
			specificShape = randomFunc() > 0.5 ? 'square' : 'triangle';
		}

		particles.push({
			type: type, // explosion type, to check which to draw when.
			// GROUND COORDINATES (The floor position)
			x: x,
			y: y,
			vx: Math.cos(angle) * speed,
			vy: Math.sin(angle) * speed,

			// HEIGHT COORDINATES (The "Fake Z" axis)
			z: 0,                    // Start on the ground
			vz: vz,   // Initial upward "pop" velocity
			gravity: gravity,           // How heavy the particle is
			bounceFactor: 0.6,       // Bounciness

			// BLOOD/STREAK LOGIC
			hitGround: false,        // Has it touched the floor yet?
			groundHitX: 0,           // Where did it land?
			groundHitY: 0,           // Where did it land?

			color: color,
			shape: specificShape,
			fadeMode: fadeMode,
			life: life,
			decay: randomRange(decay.min, decay.max),
			size: size,
			rotation: randomRange(0, 360),
			rotationSpeed: randomRange(rotationSpeed.min, rotationSpeed.max),
			fadeAtGround: fadeAtGround,
			toFloor: toFloor,
		});
	}
}





const textParticles = [];

function spawnFloatingText({x, y, text = "+1", color = "yellow", font = "20px Arial"}){
	let moveDuration = 0.3;
	let fadeDuration = 3.5;
	let totalLife = moveDuration+fadeDuration;
	textParticles.push({
		x,
		startY: y,
		y,
		offsetY: 0,
		startTime: performance.now(),

		text,
		color,
		font,

		elapsed: 0,
		alpha: 1,

		moveDuration: moveDuration, // seconds
		fadeDuration: fadeDuration,
		moveDistance: 55,
		totalLife: totalLife
	});
}


function updateTextParticles() {
	
	for (let i = textParticles.length - 1; i >= 0; i--) {
		const p = textParticles[i];
	
		p.elapsed = (performance.now() - p.startTime) / 1000;
		//p.elapsed += dt;

		// Move upward for first 0.5s
		//if (p.elapsed <= p.moveDuration) {
			const t = p.elapsed / p.moveDuration;
			//p.y = p.startY - t * p.moveDistance;
			
			// update offset, not directly y coordinate or rotation wont work:
			p.offsetY = -t * p.moveDistance; 
			if(p.offsetY < -p.moveDistance){
				p.offsetY = -p.moveDistance; // fix random end positions.
			}
		//}

		// Fade after movement stops
		if (p.elapsed > p.moveDuration) {
			const fadeTime = p.elapsed - p.moveDuration;
			const t = Math.min(fadeTime / p.fadeDuration, 1);
			p.alpha = 1 - t;
		}

		// Remove when dead
		if (p.elapsed >= p.totalLife) {
			textParticles.splice(i, 1);
		}
	}
}

function drawTextParticles() {
	for (const p of textParticles) {
		if (p.alpha <= 0) continue;

		ctx.save();
		
		// move to object position
		ctx.translate(p.x, p.y);
		// undo viewport rotation
		ctx.rotate(-viewport.rotation);
		// now apply screen-space offsets
		ctx.translate(0, p.offsetY);
		
		// draw text:
		ctx.globalAlpha = p.alpha;
		
		// stroke:
		ctx.font = "30px sans-serif";
		ctx.lineWidth = 4; // outline thickness
		ctx.strokeStyle = "black";
		ctx.fillStyle = p.color;
		ctx.lineJoin = "round"; // prevents sharp corners on letters
		ctx.strokeText(p.text, 0, 0);
		// fill:
		ctx.fillStyle = p.color;
		ctx.fillText(p.text, 0, 0);
		
		
		ctx.restore();
	}
}




// renderexplosions renderparticles drawparticles
// default type is "exp", 
// cross explosion is "crossExplosion" (death by starvation)
function renderParticles(type = "exp") {
	// 1. Pre-calculate rotation math to save performance
	// We want the Z-offset to always point "Up" on the monitor.
	// Since the context is rotated by viewport.rotation, we counter it.
	const sinR = Math.sin(viewport.rotation);
	const cosR = Math.cos(viewport.rotation);

	for (let i = particles.length - 1; i >= 0; i--) {
		let p = particles[i];
		if(p.type !== type){
			continue;
		}

		// --- 1. PHYSICS UPDATE (Unchanged) ---
		p.x += p.vx;
		p.y += p.vy;
		p.vx *= 0.95;
		p.vy *= 0.95;
		p.vz -= p.gravity;
		p.z += p.vz;

		if (p.z <= 0) {
			if (p.fadeAtGround) {
				if (!p.hitGround) {
					p.hitGround = true;
					p.groundHitX = p.x;
					p.groundHitY = p.y;
				}
				p.z = 0;
				p.vz = 0; 
				p.vx *= 0.8; 
				p.vy *= 0.8;
			} else {
				p.z = 0;
				p.vz *= -p.bounceFactor;
				p.vx *= 0.8;
				p.vy *= 0.8;
				if (Math.abs(p.vz) < 1) p.vz = 0;
			}
		}

		p.rotation += p.rotationSpeed;
		p.life -= p.decay;

		let opacity = 1;
		if (p.fadeMode === 'slow') {
			opacity = Math.max(0, p.life);
		} else {
			opacity = p.life > 0 ? 1 : 0;
		}

		if (p.life < 0.01) {
			particles.splice(i, 1);
			continue;
		}

		// --- 2. DRAWING ---

		// A. Draw Shadow (Keeps World Rotation - Correct)
		if (!p.hitGround || !p.fadeAtGround) {
			ctx.save();
			ctx.translate(p.x, p.y);
			ctx.scale(1, 0.5);
			ctx.beginPath();
			ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
			ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
			ctx.fill();
			ctx.restore();
		}

		// B. Draw Blood Stripe (Keeps World Rotation - Correct)
		if (p.fadeAtGround && p.hitGround) {
			ctx.save();
			ctx.globalAlpha = opacity;
			ctx.strokeStyle = p.color;
			ctx.lineWidth = p.size;      
			ctx.lineCap = "round";       
			
			ctx.beginPath();
			ctx.moveTo(p.groundHitX, p.groundHitY); 
			ctx.lineTo(p.x, p.y);                   
			ctx.stroke();
			ctx.restore();
		}

		// C. Draw Particle Body (FIXED: Counter-rotate the Z-offset)
		ctx.save();

		// LOGIC EXPLANATION:
		// We start at the ground position (p.x, p.y).
		// Instead of subtracting Z from Y (which moves it World-North),
		// we calculate where "Screen-Up" is within this rotated context.
		// Screen-Up requires subtracting from Y (cos) and X (sin) based on rotation.
		
		const visualX = p.x - (p.z * sinR);
		const visualY = p.y - (p.z * cosR);

		ctx.translate(visualX, visualY);
		
		ctx.rotate(p.rotation);
		ctx.globalAlpha = opacity;
		ctx.fillStyle = p.color;

		ctx.beginPath();
		if (p.shape === 'circle') {
			ctx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
			ctx.fill();
		} else if (p.shape === 'square') {
			ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
		} else if (p.shape === 'triangle') {
			const r = p.size / 1.5;
			ctx.moveTo(0, -r);
			ctx.lineTo(r, r);
			ctx.lineTo(-r, r);
			ctx.closePath();
			ctx.fill();
		}
		ctx.restore();
	}
}





function clearShieldingUnitsTips(){
	shieldingUnits = null;
	shieldingStartTime = 0;
}

function drawProtectMessages(){
	// draw "stop" text on top of units that were shielding a move or placement.
	if(shieldingUnits){
		if(msNowFloor()-shieldingStartTime < 1000){
			for(let i = 0; i < shieldingUnits.length; i++){
				let shieldingUnit = shieldingUnits[i];
				//const { x, y } = axialToPixel(shieldingUnit.q, shieldingUnit.r);
				const x = axialToPixelX(shieldingUnit.q, shieldingUnit.r);
				const y = axialToPixelY(shieldingUnit.q, shieldingUnit.r);
		
				drawObject(ctx, x, y, "protect");
			}
		}else{
			shieldingUnits = null;
			shieldingStartTime = 0;
		}
	}
}




// Draw a 2px-thick circle in the center; the canvas background remains transparent
function drawCircle(cx, cy, radius, lineWidth = 10, strokeStyle = '#ff0000') {
	ctx.beginPath();
	
	ctx.arc(cx, cy, radius, 0, Math.PI * 2);
	ctx.lineWidth = lineWidth;
	ctx.strokeStyle = strokeStyle;
	
	ctx.stroke();
}




function insideRect(rect, x, y){
	if(x < rect.x1) return false;
	if(x > rect.x2) return false;
	if(y < rect.y1) return false;
	if(y > rect.y2) return false;
	return true;
}


function drawMoveDirectionsOverlay() {
	if(gameState.settings.gameOver) return;
	
	if(!isMyTurn()){
		return;
	}

	// Pre-calculate rotation components for efficiency
	const cosR = Math.cos(viewport.rotation);
	const sinR = Math.sin(viewport.rotation);

	let pulse = 0.6 * pulseScale(1, 1.5, PULSE_SPEED);

	let canvasRect = {
		x1: 0,
		y1: 0,
		x2: canvas.width,
		y2: canvas.height
	};

	ctx.save();

	for (const unit of gameState.units) {
		// only show my player soldiers that havent moved yet:
		if(!unitTypeCanMove(unit.type) ||
		//if(unit.internalType !== 'soldier' ||
			unit.ownerIndex !== localPlayer.playerIndex ||
			unit.hasMoved){
			continue;
		}
		
		// 1. Get unit world coordinates:
		const worldPosX = axialToPixelX(unit.q, unit.r);
		const worldPosY = axialToPixelY(unit.q, unit.r);
		
		// 2. ROTATE THE WORLD POINT by the viewport's rotation
		// This gives us the position relative to the rotated viewport axes.
		const rotatedX = worldPosX * cosR - worldPosY * sinR;
		const rotatedY = worldPosX * sinR + worldPosY * cosR;

		// 3. Scale and Translate to get the final screen coordinates (x, y)
		let x = rotatedX * viewport.zoom + viewport.x;
		let y = rotatedY * viewport.zoom + viewport.y;

		if(insideRect(canvasRect, x, y)){
			continue; // it's visible, no need to draw edge indicator
		}

		// Find intersection point on canvas edge
		let edgeX = x;
		let edgeY = y;
		
		let angle = 0;
		
		// The following logic (4.) now correctly operates on the true screen coordinates (x, y).

		// Clamp to screen bounds
		if (x > canvas.width){ edgeX = canvas.width; angle = 0; }
		if (y > canvas.height){ edgeY = canvas.height; angle = 90; }
		if (x < 0){ edgeX = 0; angle = 180; }
		if (y < 0){ edgeY = 0; angle = 270; }
		
		if (x > canvas.width && y > canvas.height){ angle = 45; }
		if (x < 0 && y > canvas.height){ angle = 90+45; }
		if (x < 0 && y < 0){ angle = 180+45; }
		if (x > canvas.width && y < 0){ angle = 270+45; }
		
		drawEdgeTriangle(ctx, edgeX, edgeY, angle);
	}

	ctx.restore();
}




viewport.rotation = 0.21;//0.62;//-Math.PI/4;

let drawRanges = 0;

let previewdraw = 0;


let focusedHexEnabled = true;


// rounds up the coordinate to nearest valid hex and shows only allowed hexes for boats/mines etc.
function getNearestValidHex(point){
	let closestHex = {q:0,r:0,dist:999999, found:false};

	if(point === null){
		return closestHex;
	}
	

	let hex = pixelToAxial(point.x, point.y);
	let tile = getTileAt(hex.q, hex.r);
	
	

	if(selectedUnit && isTypeBoat(selectedUnit.type)){
		closestHex.q = hex.q;
		closestHex.r = hex.r;
		closestHex.found = true;
		return closestHex;
	}
	
	if(placingUnit){
		if(selectedUnit){
			if(isTypeBoat(placingUnit.type)){
				if(isHexNextToHex(selectedUnit, hex) && isTileWater(tile)){
					closestHex.q = hex.q;
					closestHex.r = hex.r;
					closestHex.found = true;
				}
				return closestHex;
			}else if(isTypeMine(placingUnit.type)){
				if(isHexNextToHex(selectedUnit, hex) && isTileLand(tile)){
					closestHex.q = hex.q;
					closestHex.r = hex.r;
					closestHex.found = true;
				}
				return closestHex;
			}
		}
		if(isTypeSoldier(placingUnit.type)){
			// if pointing on unit, just focus there instead of avoiding it.
			if(getUnitAt(hex.q, hex.r)){
				closestHex.q = hex.q;
				closestHex.r = hex.r;
				closestHex.found = true;
				return closestHex;
			}
		}else if(isTypeCastle(placingUnit.type)){
			// only allow building inside your pool:
			for(let i = 0; i < highlightedPool.length; i++){
				let validHex = highlightedPool[i];
				if(isHexHex(validHex, hex)){
					closestHex.q = hex.q;
					closestHex.r = hex.r;
					closestHex.found = true;
					break;
				}
			}
			return closestHex;
		}
	}else{
		// not placingUnit.
		if(getUnitAt(hex.q, hex.r)){
			closestHex.q = hex.q;
			closestHex.r = hex.r;
			closestHex.found = true;
			return closestHex;
		}
	}
	
	for(let i = 0; i < validMoveHexes.length; i++){
		let validHex = validMoveHexes[i];
		
		let dist = getHexPointDistance(validHex, point);
		if(dist < closestHex.dist){
			closestHex.dist = dist;
			closestHex.q = validHex.q;
			closestHex.r = validHex.r;
			closestHex.found = true;
		}
	}
	// add selected unit in the search list so it wont try to move it when you click unit again.
	if(selectedUnit){
		let validHex = selectedUnit;
		let dist = getHexPointDistance(validHex, point);
		if(dist < closestHex.dist){
			closestHex.dist = dist;
			closestHex.q = validHex.q;
			closestHex.r = validHex.r;
			closestHex.found = true;
		}
	}
	if(closestHex.dist > 1.6){
		closestHex.found = false;
	}
	return closestHex;
}



function drawFocusedHex(){
	if(focusedHex){
		let nearestValidHex = null;
		
		
		let overrideColor = null;

		let closestHex = getNearestValidHex(focusedPoint);
		if(closestHex.found){
			focusedHex.q = closestHex.q;
			focusedHex.r = closestHex.r;
		}else{
			if(placingUnit || selectedUnit){
				overrideColor = "rgba(255, 0, 0, 1)";
			}
		}
		
		let scale = pulseScale(0.6, HEX_LINE_MULTI, PULSE_SPEED);
				

		

		
		if(overrideColor){
			scale = HEX_LINE_MULTI*0.9;
		}
		
		ctx.lineDashOffset = 8*scale;
		let dashes = [16*scale, 24*scale];


		
		const x = axialToPixelX(focusedHex.q, focusedHex.r);
		const y = axialToPixelY(focusedHex.q, focusedHex.r);
		
		let tile = getTileAt(focusedHex.q, focusedHex.r);
		
		if(placingUnit && isTypeBoat(placingUnit.type)){
			if(isTileWater(tile)){ // !tile || tile.type === 'water'){
				drawHexagonPathLines(x, y, null, scale);
				ctx.setLineDash(dashes);
				ctx.strokeStyle = overrideColor ? overrideColor : 'rgba(255,255,255, 0.6)';
				ctx.lineWidth = 4*scale;
				
				ctx.lineCap = 'round';
				ctx.stroke();
				ctx.lineCap = 'butt'; // reset to default
				ctx.setLineDash([]); // reset possible dash.
			}
		}else{
			if(!isTileWater(tile)){ // tile && tile.type !== 'water'){
				if(selectedUnit || placingUnit){
					drawHexagonPathLines(x, y, null, scale);
					ctx.setLineDash(dashes);
					if(placingUnit){
						ctx.strokeStyle = overrideColor ? overrideColor : 'rgba(255,255,255, 0.6)';
					}else{
						ctx.strokeStyle = overrideColor ? overrideColor : 'rgba(255,255,0, 0.6)';
					}
					ctx.lineWidth = 4*scale;
				}else{
					drawHexagonPathLines(x, y, null, HEX_LINE_MULTI2);
					ctx.strokeStyle = overrideColor ? overrideColor : 'rgba(255,255,255, 0.4)';
					ctx.lineWidth = 2;
				}
				
				ctx.lineCap = 'round';
				ctx.stroke();
				ctx.lineCap = 'butt'; // reset to default
				ctx.setLineDash([]); // reset possible dash.
			}else{
				if(selectedUnit || placingUnit){
					drawHexagonPathLines(x, y, null, scale);
					ctx.setLineDash(dashes);
					if(placingUnit){
						ctx.strokeStyle = overrideColor ? overrideColor : 'rgba(255,255,255, 0.6)';
					}else{
						ctx.strokeStyle = overrideColor ? overrideColor : 'rgba(255,255,0, 0.6)';
					}
					ctx.lineWidth = 4*scale;
					
					ctx.lineCap = 'round';
					ctx.stroke();
					ctx.lineCap = 'butt'; // reset to default
					ctx.setLineDash([]); // reset possible dash.
				}
			}
		}


		
	}
}


let lastActionHexes = [];


// used to remove actionhex when player uses undo
function removeLastActionHex(id){
	lastActionHexes = lastActionHexes.filter(a => a.id !== id);
}

// id should be unitId, if other than units used, should add prefix for their ids here.
function pushLastActionHex(q, r, id, color = "#FFFFFF"){
	lastActionHexes.push({
		q: q, 
		r: r, 
		id: id,
		startTime: performance.now(),
		color: color,
	});
}


function pushLastActionHexCheckParams(ownerIndex, wasUndo, q, r, id, color){		
	let player = getPlayerByIndex(ownerIndex);
	if(!player.isAI && ownerIndex !== getMyPlayer().playerIndex){
		if(wasUndo){
			color = "#FF00FF"; // undo color
		}
		pushLastActionHex(q, r, id, color);
	}
}


let lastActionMulti = 1; // later could modify this from game settings in-game.
let lastActionStartScale = 40; // later could modify this from game settings in-game.



let lastMovesTriggerTime = performance.now();


// unsynced clearing of pq/pr, used when that player turn starts.
function clearLastActionMoves(playerIndex){
	for(let i = 0; i < gameState.units.length; i++){
		let unit = gameState.units[i];
		if(unit.ownerIndex === playerIndex){
			delete unit.pq;
			delete unit.pr;
		}
	}
}

function drawLastActionMoves(){
	let myPlayer = getMyPlayer();
	let now = performance.now();
	let timeDiff = now - lastMovesTriggerTime;
	let alphaTime = 2500*lastActionMulti; // fade out start time
	let alphaLen = 1000*lastActionMulti; // fade out length
	
	// show for 4 seconds after triggering the positions visible:
	if(timeDiff < 3500){
		
		for(let i = 0; i < gameState.units.length; i++){
			let unit = gameState.units[i];
			// only show enemies markers:
			if(unit.ownerIndex !== myPlayer.playerIndex){
				
				// if has previous position:
				if(unit.pq !== undefined){
					// if prev pos != new pos:
					if(unit.pq !== unit.q || unit.pr !== unit.r){
						let hex = {q: unit.q, r: unit.r};
						
						let scale = 1;
						
						const x = axialToPixelX(hex);
						const y = axialToPixelY(hex);
						
						// Determine rotation (in radians)
						let rotation = (now - lastMovesTriggerTime) * 0.005; // example: rotates over time

						ctx.save(); // Save the current state
						ctx.translate(x, y); // Move origin to hex center
						ctx.rotate(rotation); // Apply rotation
						
						ctx.lineCap = 'round';
						ctx.lineDashOffset = 8;
						ctx.setLineDash([16, 24]);
						
						let alpha = 1;
						if(timeDiff > alphaTime){
							alpha = 1-((timeDiff-alphaTime)/alphaLen);
						}
						if(alpha < 0) alpha = 0;

						ctx.globalAlpha = alpha;
						
						drawHexagonPathLines(0, 0, null, scale);
						
						ctx.strokeStyle = 'rgba(255,255,255, 1)';
						ctx.lineWidth = 5;
						ctx.stroke();
						
						ctx.lineCap = 'butt'; // reset to default
						ctx.setLineDash([]); // reset possible dash.
				
						ctx.restore(); // Restore original state

						// draw unit routes:
						let route = [
							{q: unit.pq, r: unit.pr}, 
							{q: unit.q, r: unit.r},
						];
						drawRouteLines(route, "rgba(255, 255, 255, 0.6)", true, 3, alpha);
					}
				}
			}
		}

	}
}


function drawLastActionHexes(){
	let dashed = true;
	let now = performance.now();
	let maxScale = lastActionStartScale;
	
	let hexLife = 1000*lastActionMulti; // zoom in end time
	let hexLife2 = 3500*lastActionMulti; // non-zoomed in end time
	let alphaTime = 2500*lastActionMulti; // fade out start time
	let alphaLen = 1000*lastActionMulti; // fade out length
	
	
	ctx.lineCap = 'round';
	ctx.lineDashOffset = 8;
	ctx.setLineDash([16, 24]);
	


	for(let i = lastActionHexes.length-1; i >= 0; i--) {
		let hex = lastActionHexes[i];
		let unitId = hex.id;
		
		let timeDiff = now - hex.startTime;
		
		let percent = timeDiff / hexLife;
		if(percent > 1) percent = 1;
		
		let scale = maxScale*(1-percent);
		if(scale < 1) scale = 1;
		
		if(timeDiff < hexLife2){

			const x = axialToPixelX(hex);
			const y = axialToPixelY(hex);
			
			// Determine rotation (in radians)
			let rotation = (now - hex.startTime) * 0.005; // example: rotates over time

			ctx.save(); // Save the current state
			ctx.translate(x, y); // Move origin to hex center
			ctx.rotate(rotation); // Apply rotation
			
			let alpha = 1;
			if(timeDiff > alphaTime){
				alpha = 1-((timeDiff-alphaTime)/alphaLen);
			}
			if(alpha < 0) alpha = 0;

			ctx.globalAlpha = alpha;
			
			//ctx.lineDashOffset = 8*scale;
			//let dashes = [16*scale, 24*scale];
			
			drawHexagonPathLines(0, 0, null, scale);
			
			ctx.strokeStyle = hex.color;//'rgba(255,255,0, 1)';
			ctx.lineWidth = 5;
			ctx.stroke();
	
			ctx.restore(); // Restore original state
		}else{
			// remove when dead:
			lastActionHexes.splice(i, 1);
		}
	}
	
	ctx.lineCap = 'butt'; // reset to default
	ctx.setLineDash([]); // reset possible dash.
}



let startZoomPos = null;
let zoomingStartTime = 0;
let zoomingLen = 1200;
let startZoomValue = 0.1;
let endZoomValue = 1;


function startZoom(isSpectator = false){
	if(startZoomPos){
		zoomingStartTime = performance.now();
		
		// force fixed zoom level for specs at start of game:
		if(isSpectator){
			startZoomValue = 0.1;
			endZoomValue = 0.3;
			zoomingLen = 1000;
		}
	}
}
function startZoom2(){
	startZoomPos = centerFirstUnit();
	startZoom();
}



function drawRouteLines(route, color = "#FFFFFF", dashed = false, speedMulti = 1, globalAlpha = 1){
	ctx.beginPath();
	ctx.strokeStyle = color;
	ctx.globalAlpha = globalAlpha;
	if(dashed){
		let time = performance.now()/50;
		ctx.setLineDash([10, 18]);
		ctx.lineDashOffset = -time*speedMulti;
	}
	ctx.lineWidth = 5.5;
	ctx.lineCap = 'round';
	for(let i = 0; i < route.length; i++){
		let hex = route[i];
		const x = axialToPixelX(hex.q, hex.r);
		const y = axialToPixelY(hex.q, hex.r);
		if(i === 0){
			ctx.moveTo(x,y);
		}else{
			ctx.lineTo(x,y);
		}
	}
	ctx.stroke();
	
	// reset to default:
	ctx.lineCap = 'butt';
	if(dashed){
		ctx.setLineDash([]);
		ctx.lineDashOffset = 0;
	}
	ctx.globalAlpha = 1;
}


let drawAllTiles = true;


function render() {
	if (!gameStarted()) return;
	
	trackFPS();

	// calculate current mip level:
	zoomMipLevel = getZoomMipLevel(1); // use normal. smaller = earlier switch to smaller image

	//console.log(tileZoomMipLevel);
  
	if(zoomingStartTime){
		let diff = performance.now() - zoomingStartTime;
		let screenX = canvas.width/2;
		let screenY = canvas.height/2;
		
		if(diff < zoomingLen){
			let percent = diff / zoomingLen; // 0...1

			zoomAtPointPercent(screenX, screenY, percent);
		}else{
			// zoom the last time to final zoom:
			zoomAtPointPercent(screenX, screenY, 1);
			zoomingStartTime = 0;
		}
	}
	
	// Save the context state
	ctx.save();
	
	if(gameSettings.drawWater){
		drawInfiniteWater();
	}else{
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}

	//ctx.translate(viewport.x, viewport.y);
	//ctx.scale(viewport.zoom, viewport.zoom);
	
	//viewport.rotation = pulseScale(0, 1.2, 0.0002);


	ctx.translate(viewport.x, viewport.y);
	ctx.rotate(viewport.rotation);
	ctx.scale(viewport.zoom, viewport.zoom);

	// translate back so drawing is centered correctly
	//ctx.translate(0, 0);

  	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';
	ctx.font = `11px sans-serif`;
	


	
	// MAP WATER SHADING (3d effect):
	if(gameSettings.drawShoresShading && gameSettings.drawWater){
		drawMapShading(1); // shores
	}
	if(gameSettings.drawWaterShading){
		drawMapShading(0); // water 3d effect
	}
	
	// MAP TILE DRAWING:
	if(drawAllTiles){
		drawMapTiles();
	}
	
	// MAP LAND SHADING (3d effect):
	if(gameSettings.drawLandShading){
		drawMapShading(2); // land shading
	}

	
	// HIGHLIGHTS DRAWING:
	if(!previewdraw){
		drawHighlights();
	}
	
	// draw under objects: cross explosion particles (death by starvation)
	if(gameSettings.drawParticles){
		renderParticles("crossExplosion");
	}

	// OBJECTS DRAWING:
	if(!previewdraw){
		drawObjects();
	}
	
	// only for debugging:
	if(drawRanges){
		// MOVEMENT RANGE DRAWING:
		drawMovementRanges();
		// PLACEMENT HIGHLIGHT DRAWING:
		drawPlacementHighlight();
	}
	
	
	

	if(validSeaMoveHexes && validSeaMoveHexes.length > 0){
		// Draw movement range
		ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
		for (const hex of validSeaMoveHexes) {
			//const { x, y } = axialToPixel(hex.q, hex.r);
			const x = axialToPixelX(hex.q, hex.r);
			const y = axialToPixelY(hex.q, hex.r);
			drawHexagonPath(x, y);
			ctx.fill();
		}
	}

/*
	// draw full route to clicked position:
	if(routeHighlight && routeHighlight.length > 0){
		// Draw movement range
		ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
		for (const hex of routeHighlight) {
			//const { x, y } = axialToPixel(hex.q, hex.r);
			const x = axialToPixelX(hex.q, hex.r);
			const y = axialToPixelY(hex.q, hex.r);
			drawHexagonPath(x, y);
			ctx.fill();
		}
		
		drawRouteLines(routeHighlight, "rgba(255, 255, 0, 0.5)", true);
	}
	*/
	
	
	
	if(focusedHexEnabled){
		drawFocusedHex();
	}
	
	
	// UNIT SELECTION DRAWING:
	if(!previewdraw){
		drawUnitSelection();
	}
	
	if(gameSettings.drawParticles){
		// explosion particles (default type = exp)
		renderParticles("exp");
	}


	
	// UNITS DRAWING:
	if(!previewdraw){
		drawUnits();
	}



	// draw "stop!" messages on protecting units
	drawProtectMessages();
	
	
	updateTextParticles();
	drawTextParticles();
	
	drawLastActionHexes();
	drawLastActionMoves();
	
	ctx.restore();
	
	
	// draw dots for unmoved units outside of screen:
	if(gameSettings.drawPointers){
		drawMoveDirectionsOverlay();
	}
	
	
	requestAnimationFrame(render);
}




let lastMousePos = { x: 0, y: 0 };

let lastpos = { x: 0, y: 0 };

let isDrawing = false; // for editor.
let currentTileType = "land";

function handleCanvasMouseMove(e) {
	//console.log("handleCanvasMouseMove");
	
	if(isDrawing && e.ctrlKey){
		if(gameState.settings.editorEnabled){
			
			
			let hex = pixelToAxial(e.clientX, e.clientY);
		
			sendTileUpdate(hex);
		}
	}else{
		
		lastMousePos.x = e.clientX;
		lastMousePos.y = e.clientY;
		
		focusedHex = pixelToAxial(e.clientX, e.clientY);
		focusedPoint = {x: e.clientX, y: e.clientY};

		
		if (dragStart && dragStart.canDrag) {
			const dx = e.clientX - lastpos.x;
			const dy = e.clientY - lastpos.y;
			
			if (!isDragging && Math.hypot(dx, dy) > 5) {
				isDragging = true;
			}
			
			if (isDragging) {
				viewport.x += dx;
				viewport.y += dy;
				//dragStart.x = e.clientX;
				//dragStart.y = e.clientY;
						
				lastpos.x = e.clientX;
				lastpos.y = e.clientY;
			}
		}
	}
}

function handleCanvasMouseDown(e) {
	//console.log("handleCanvasMouseDown");
	
	isDragging = false; // Reset dragging flag
	dragStart = { x: e.clientX, y: e.clientY };
	lastpos.x = e.clientX;
	lastpos.y = e.clientY;


	
	if(gameState.settings.editorEnabled && e.ctrlKey){
		isDrawing = true;
		
		let hex = pixelToAxial(e.clientX, e.clientY);
	
		let tile = getTileAt(hex.q, hex.r);
		if(isTileWater(tile)){
			currentTileType = "land";
		}else{
			currentTileType = "water";
		}
		
		console.warn("currentTileType", currentTileType);
		
		sendTileUpdate(hex);
	}
	
	//const clickedHex = pixelToAxial(e.clientX, e.clientY);
	//const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);
	
	// Don't drag if we click a unit
	//if (!unitOnHex) {
		dragStart.canDrag = true;
	//} else {
	//	dragStart.canDrag = false;
	//}
}


function handleCanvasMouseLeave(e) {
	isDrawing = false;
}


// seems to be only for desktop mode.
function handleCanvasMouseUp(e) {
	isDrawing = false;
	
	if(dragStart){
		const dx = e.clientX - dragStart.x;
		const dy = e.clientY - dragStart.y;
		const dist = Math.sqrt(dx*dx + dy*dy);
		
		if (dist < 5) { // It's a click, not a drag
			// right click:
			if(e.button === 2){
				// oncontextmenu contextmenu cancel build popup cancelbuildpopup
				deselectHex();
				deselectUnit();
				cancelBuildPopup();
				updateHighlights();
				selectedPool = null;
				updateSelectedPoolUi();
			}else if(e.button === 0){
				handleHexClick({x: e.clientX, y: e.clientY});
			}
		}
		isDragging = false;
		dragStart = null;
	}
}

// --- Touch controls ---
let touchStartPos = null;
let lastTouch = null;
let lastDist = null; // for pinch-zoom

let initialAngle = 0;
let isRotating = false;



function isBuildPopupOpen(){
	return buildPopup.style.display !== 'none';
}


function handleTouchStart(e) {
	//console.log("handleTouchStart");

	// unfocus chatinput:
	chatInput.blur();

	const touch = e.touches[0];
	const target = document.elementFromPoint(touch.clientX, touch.clientY);

	if(!placingUnit){
		// close build popup if clicked outside while not building an unit:
		const touchedOutside =
			!buildPopup.contains(target) &&
			!buildOtherBtn.contains(target) &&
			!buildSoldierBtn.contains(target) &&
			!buildCastleBtn.contains(target);

		if (touchedOutside && isBuildPopupOpen()) {
			cancelBuildPopup();
		}
	}

	if (e.touches.length === 1) {
		//console.log("e.touches.length === 1");
		isDragging = false;
		touchStartPos = { x: touch.clientX, y: touch.clientY };

		const clickedHex = pixelToAxial(touch.clientX, touch.clientY);
		const unitOnHex = getUnitAt(clickedHex.q, clickedHex.r);

		touchStartPos.canDrag = true; // always allow dragging while doing things
		//touchStartPos.canDrag = !unitOnHex;
		//touchStartPos.canDrag = !placingUnit;
		lastTouch = { x: touch.clientX, y: touch.clientY };
		lastDist = null;

	} else if (e.touches.length === 2) {
		//console.log("e.touches.length === 2");
		// cancel drag, start zooming by pinching.
		isDragging = false;
		touchStartPos = null;
		lastDist = Math.hypot(
			e.touches[0].clientX - e.touches[1].clientX,
			e.touches[0].clientY - e.touches[1].clientY
		);
		
		// only rotate if chat box is open:
		if(showTopLeftUi){
			// rotation:
			const [t1, t2] = e.touches;
			initialAngle = Math.atan2(
				t2.clientY - t1.clientY, 
				t2.clientX - t1.clientX
			);
			isRotating = true;
		}
		
	}
}



function handleTouchMove(e) {
	//console.log("handleTouchMove");
		
	lastMousePos.x = e.touches[0].clientX; // for placement cursor
	lastMousePos.y = e.touches[0].clientY;

	if (e.touches.length === 1 && touchStartPos && touchStartPos.canDrag) {
		// Dragging
		const touch = e.touches[0];
		const dx = touch.clientX - lastTouch.x;
		const dy = touch.clientY - lastTouch.y;
		
		if (!isDragging && Math.hypot(touch.clientX - touchStartPos.x, touch.clientY - touchStartPos.y) > 5) {
			isDragging = true; // Started dragging
		}
		
		if (isDragging) {
			viewport.x += dx;
			viewport.y += dy;
		}
		lastTouch.x = touch.clientX;
		lastTouch.y = touch.clientY;

	} else if (e.touches.length === 2 && lastDist) {
		// Pinch-zoom
		const newDist = Math.hypot(
			e.touches[0].clientX - e.touches[1].clientX,
			e.touches[0].clientY - e.touches[1].clientY
		);
		
		const zoomFactor = newDist / lastDist;
		
		// Get center of pinch
		const midX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
		const midY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

		zoomAtPoint(midX, midY, zoomFactor);

		lastDist = newDist;
	}
	
	// only rotate if chat box is open:
	if(showTopLeftUi){
		if (!isRotating || e.touches.length !== 2){
			
		}else{
			const [t1, t2] = e.touches;
			const newAngle = Math.atan2(
				t2.clientY - t1.clientY, 
				t2.clientX - t1.clientX
			);
			const deltaAngle = newAngle - initialAngle;

			rotateAroundScreenCenter(deltaAngle);
			
			initialAngle = newAngle; // update for next frame
		}
	}
}


// only for mobile?
function handleTouchEnd(e) {
	//console.log("handleTouchEnd");
	
	if (e.touches.length === 0 && touchStartPos && !isDragging) {
		// This was a tap
		handleHexClick({x: touchStartPos.x, y: touchStartPos.y});
	}
	
	
	if (e.touches.length < 2) {
		lastDist = null; // Stop zooming
		
		if(showTopLeftUi){
			isRotating = false;
		}
	}
	if (e.touches.length < 1) {
		isDragging = false; // Stop dragging
		touchStartPos = null;
		lastTouch = null;
	}
}




function getZoomMipLevel(multiplier){
	const safeZoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, viewport.zoom));
	return Math.min(
		6 - 1,
		Math.max(0, Math.round(-Math.log2(safeZoom * multiplier))) // smaller multiplier = earlier mip change to smaller
	);
}

function zoomAtPoint(x, y, factor) {
	const newZoom = Math.max(MIN_ZOOM, Math.min(viewport.zoom * factor, MAX_ZOOM));
	const oldZoom = viewport.zoom;
	
	viewport.x = x - (x - viewport.x) * (newZoom / oldZoom);
	viewport.y = y - (y - viewport.y) * (newZoom / oldZoom);
	viewport.zoom = newZoom;

	//console.log(zoomMipLevel);
}



function easeInOutSmooth(t) {
	return t * t * (3 - 2 * t);
}

function easeInOutCubic(t) {
	return t < 0.5
		? 4 * t * t * t
		: 1 - Math.pow(-2 * t + 2, 3) / 2;
}
function easeInOutPower(t, p = 3) {
	if (t < 0.5) {
		return 0.5 * Math.pow(2 * t, p);
	}
	return 1 - 0.5 * Math.pow(2 * (1 - t), p);
}

function zoomAtPointPercent(x, y, percent) {
	const t = easeInOutPower(percent, 5);
	
	const zoomDiff = endZoomValue-startZoomValue; // 0.8
	const newZoom = startZoomValue + zoomDiff*t; // 0.2...1.0
	const oldZoom = viewport.zoom;
	
	viewport.x = x - (x - viewport.x) * (newZoom / oldZoom);
	viewport.y = y - (y - viewport.y) * (newZoom / oldZoom);
	viewport.zoom = newZoom;
}


function handleWheel(e) {
	e.preventDefault();
	const zoomFactor = (e.deltaY < 0) ? 1.1 : (1 / 1.1);
	zoomAtPoint(e.clientX, e.clientY, zoomFactor);
}

// =================================================================
// --- GAME LOGIC HELPERS
// =================================================================


function getMapBounds(){
	return gameState.map.bounds;
}

function getTileAt(q, r, state = null) {
	let tileKey = `${q},${r}`;
	if(!state){
		let tileIndex = gameState.map.tiles[tileKey];
		return gameState.map.tilesData[tileIndex];
	}else{
		let tileIndex = state.map.tiles[tileKey];
		return state.map.tilesData[tileIndex];
	}
}

function getTileType(tile){
	if(tile){
		return tile.type;
	}
	return "water";
}


// if tile doesnt exist: new tile created, if not: modifying the tile.
function setTileAt(q, r, tileData, allowCreation = true, state = null) {
	let tileKey = `${q},${r}`;
	let useState = state ? state : gameState;

	if (Object.hasOwn(useState.map.tiles, tileKey)) {
		//console.log("setTileAt Object.hasOwn at ",q,r);
		// modify already existing tile:
		let tileIndex = useState.map.tiles[tileKey];
		useState.map.tilesData[tileIndex] = {...useState.map.tilesData[tileIndex], ...tileData};
	}else{
		//console.log("setTileAt add new tile at ",q,r);
		// add new tile:
		if(allowCreation){
			let tileIndex = useState.map.tilesData.length;
			useState.map.tilesData.push({q, r, tileIndex, ...tileData});
			useState.map.tiles[tileKey] = tileIndex;
		}
	}
}


function setTileOwnerByIndex(tile, ownerIndex){
	if(ownerIndex !== undefined && ownerIndex !== null){
		// remember who was previous owner (for animations):
		tile.powner = tile.ownerIndex;
		// set new owner:
		tile.ownerIndex = ownerIndex;
	}else{
		tile.ownerIndex = -1; // no owner, ownerIndex is not set.
	}
}






// will set water outline to the tile, or if doesnt exist yet, adds new tile with that info.
function setOutlineAt(q, r, lines, allowCreation = true, state = null) {
	let tile = {outline: lines};
	
	if(!getTileAt(q,r, state)){
		tile = {...tile, type: "water", ownerIndex: -1, object: null, savings: 0};
	}
	setTileAt(q, r, tile, allowCreation, state);
}


function getUnitById(unitId){
	return gameState.units.find(u => u.id === unitId);
}

function getUnitAt(q, r) {
	// If first argument is an object, extract values
	if (q !== null && typeof q === "object") {
		r = q.r;
		q = q.q; // must be set here or overwrites q before r.
	}
	return gameState.units.find(u => u.q === q && u.r === r);
}



function getCurrentTurnPlayer() {
	if (!gameStarted()) return null;
	return gameState.players[gameState.turn.currentPlayerIndex];
}

function isMyTurn() {
	const currentTurnPlayer = getCurrentTurnPlayer();
	return currentTurnPlayer && currentTurnPlayer.id === localPlayer.id;
}

function hasUnmovedUnits(){
	if(!isMyTurn()){
		return false;
	}
	const player = getMyPlayer();
	for(let i = 0; i < gameState.units.length; i++){
		let unit = gameState.units[i];

		if(unitTypeCanMove(unit.type) && unit.ownerIndex === player.playerIndex && !unit.hasMoved){
		//if(unit.internalType === 'soldier' && unit.ownerIndex === player.playerIndex && !unit.hasMoved){
			return true;
		}
	}
	return false;
}


// updateui update ui
function updateGameUI() {
	if (!gameStarted()) return;
	
	const myPlayer = getMyPlayer();
	const currentTurnPlayer = getCurrentTurnPlayer();
	
	// Update player list
	playerUIList.innerHTML = '';
	gameState.players.forEach(p => {
		const item = document.createElement('div');
		item.className = 'player-list-item';
		if (p.id === currentTurnPlayer?.id) {
			item.classList.add('current-turn');
		}
		
		item.dataset.peer = p.id;

		if(p.id	!== localPlayer.id && !p.isAI){
			item.classList.add("ai-player-item");	
		}
		
		let color = p.textColor;
		let specTag = "";
		if(p.isSpectator){
			color = "white";
			specTag = "(spec)";
		}

		if(p.isAI){
			specTag = "(AI)";
		}
		
		if(!p.quitted){
			item.innerHTML = `
				<span class="player-turn-indicator"></span>
				<span style="color: ${color}; font-weight: bold;" class="namevals"></span>
			`;
			const safeName = document.createTextNode(`${p.name} ${specTag}`);
			item.querySelector("span.namevals").appendChild(safeName);
			playerUIList.appendChild(item);
		}
	});

	// Update turn info
	let turnDate = getTurnDate('week-day');
	turnInfo.textContent = `${turnDate}`;
	
	if(!REPLAY_ENABLED){
		// Update buttons
		let canPlay = isMyTurn() && !myPlayer.isSpectator;
		if(gameState.settings.gameOver){
			canPlay = false;
		}
		buildOtherBtn.disabled = !canPlay;
		buildSoldierBtn.disabled = !canPlay;
		buildCastleBtn.disabled = !canPlay;
		sellUnitBtn.disabled = true;
		endTurnBtn.disabled = !canPlay;
		
		nextUnitBtn.disabled = !hasUnmovedUnits();
		previousUnitBtn.disabled = !hasUnmovedUnits();
		
		
		///////////////////////////////
		// THIS WONT WORK SINCE CLIENTS DOESNT HAVE currentTurnActions array, its empty! only host keeps track of it...
		let disableUndo = !canPlay;
		if(canPlay){
			//console.log("currentTurnActions len = "+currentTurnActions.length);
			//console.log(currentTurnActions);
			if(currentTurnActions && currentTurnActions.length > 0){
				disableUndo = false;
			}else{
				disableUndo = true;
			}
			//console.log("disableUndo: "+disableUndo);
		}else{
			//console.log("cant play: disableUndo: "+disableUndo);
		}
		
		//undoBtn.disabled = !canPlay; // need to fix this so all clients will also know if they have undo remaining.
		
		// update undo button state:
		undoBtn.classList.remove("disabled");
		if(!localPlayer.undoCounter){
			undoBtn.classList.add("disabled");
		}
		

		
		// Update savings
		if (myPlayer && !myPlayer.isSpectator) {
			//playerSavings.textContent = myCurrentSavings;
		} else {
			//playerSavings.textContent = "Spectating";
		}
	
	}else{
		spectatorUiMode();
	}
	
	
	//chatInput.disabled = false; // no idea why it is disabled by default...
}





function getMyTotalSavings() {
	// This is now just a client-side getter
	return myCurrentSavings;
}

function getSelectedPoolSavings() {
	// This is now just a client-side getter
	if(selectedPool){
		return selectedPool.totalSavings;
	}
	return 0;
}



// =================================================================
// --- GAME LOGIC - ACTIONS
// =================================================================

function isHexWater(q, r){
	return isTileWater(getTileAt(q, r));
}
function isHexLand(q, r){
	return isTileLand(getTileAt(q, r));
}

function isTileWater(tile){
	if(!tile){ // out of bounds, mark as water:
		return true;
	}else if(tile.type === "water"){
		return true;
	}
	return false;
}

function isTileLand(tile){
	if(!tile){ // out of bounds, mark as water:
		return false;
	}else if(tile.type === "land"){
		return true;
	}
	return false;
}


// array of units which trigger protect sound.
let shieldingUnits = null;
let shieldingStartTime = 0;

function findSelectedPool(findHex, pools = localPlayerPools, ownerIndex = localPlayer.playerIndex){
	if(pools && findHex){
		let clickedHexTile = getTileAt(findHex.q, findHex.r);
		
		if(clickedHexTile && clickedHexTile.ownerIndex === ownerIndex){
			for(let p = 0; p < pools.length; p++){
				let pool = pools[p];
				for(let h = 0; h < pool.hexes.length; h++){
					let hex = pool.hexes[h];
					if(hex.q == findHex.q && hex.r == findHex.r){
						return pool;
					}
				}
			}
		}
	}
	return null;
}


function formatDecimal(num) {
	num += EPSILON; // add 0.000001 in case the value is 9.99999999 etc...
	const fixed = num.toFixed(2); // "12.30"
	//if (fixed.endsWith("00")) return String(num|0); // integer case
	//if (fixed.endsWith("0")) return fixed.slice(0, -1); // one trailing zero
	return fixed; // both decimals meaningful
}

function formatNumber(num, decimals = 2) {
	// clamp decimals to 1â€“5
	decimals = Math.min(5, Math.max(1, decimals));

	const fixed = num.toFixed(decimals);

	// strip trailing zeros
	let stripped = fixed.replace(/0+$/, '');

	// if everything after the decimal was zeros, remove the decimal entirely
	if (stripped.endsWith('.')) stripped = stripped.slice(0, -1);

	return stripped;
}

function hidePoolInfo(){
	infoLeft.style.display = "none";
}

function showPoolInfo(){
	infoLeft.style.display = "block";
}

function formatPoolDecimal(num) {
	num += EPSILON; // add 0.000001 in case the value is 9.99999999 etc...
	const fixed = parseFloat(num.toFixed(2)); // "12.30"
	//if (fixed.endsWith("00")) return String(num|0); // integer case
	//if (fixed.endsWith("0")) return fixed.slice(0, -1); // one trailing zero
	return fixed; // both decimals meaningful
}


function updateSelectedPoolUi(){
	// disable by default, enable later:
	buildSoldierBtn.classList.add("disabled");
	buildCastleBtn.classList.add("disabled");
	buildOtherBtn.classList.add("disabled");
	
	if(selectedPool){
		console.warn("selectedPool:");
		console.warn(selectedPool);
		
		let totalBalance = (selectedPool.totalSavings + selectedPool.totalIncome) - selectedPool.totalWages;
		playerSavings.textContent = formatPoolDecimal(selectedPool.totalSavings);
		playerIncome.textContent = formatPoolDecimal(selectedPool.totalIncome);
		playerWages.textContent = formatPoolDecimal(selectedPool.totalWages);
		playerBalance.textContent = formatPoolDecimal(totalBalance);
		
		if(selectedPool.totalSavings >= minSoldierCost){
			buildSoldierBtn.classList.remove("disabled");
		}
		if(selectedPool.totalSavings >= minCastleCost){
			buildCastleBtn.classList.remove("disabled");
		}
		if(selectedPool.totalSavings >= minOtherCost){
			// must have selected unit set to build other units.
			// todo: make later check if any of the items can be built when adding new units that doesnt require selected unit.
			if(selectedUnit){
				buildOtherBtn.classList.remove("disabled");
			}
		}

		showPoolInfo();
	}else{
		hidePoolInfo();
	}
}

function updateSelectedPoolInfo(hex){
	// localPlayerPools
	console.warn("updateSelectedPoolInfo");
	console.warn(hex);
	console.warn(localPlayerPools);
	
	selectedPool = findSelectedPool(hex);
	updateSelectedPoolUi();
	console.log("updateSelectedPoolInfo: selectedPool");
	console.log(selectedPool);
}

function getSelectedPoolHex(){
	if(selectedPool && selectedPool.hexes && selectedPool.hexes.length > 0){
		return {q: selectedPool.hexes[0].q, r: selectedPool.hexes[0].r};
	}else{
		console.error("getSelectedPoolHex: tried to call without selectedPool set.");
		return null;
	}
}

function isUnitNextToUnit(unit1, unit2){
	let neigh = getHexNeighbors(unit1);
	for(let i = 0; i < neigh.length; i++){
		let hex = neigh[i];
		if(hex.q === unit2.q && hex.r === unit2.r){
			return true;
		}
	}
	return false;
}

function isUnitNextToHex(unit, hex){
	return isUnitNextToUnit(unit, hex);
}
function isHexNextToHex(hex1, hex2){
	return isUnitNextToUnit(hex1, hex2);
}

// check if two hexes equal in q/r.
function isHexHex(hex1, hex2){
	return hex1.q === hex2.q && hex1.r === hex2.r;
}


function sendTileUpdate(hex){
	console.warn("sendTileUpdate");
	if(!localPlayer.isSpectator){
		sendToHost({
			type: ACTION.action_edit_tile,
			hex: hex,
			tileType: currentTileType,
			//playerIndex: localPlayer.playerIndex,
		});
	}
}


//let EDITOR_ENABLED = 0;

let routeHighlight = [];

function handleHexClick(point) {
	if(REPLAY_ENABLED) return;
	
	let hex = pixelToAxial(point.x, point.y);
	
	
	if(gameState.settings.editorEnabled){
		
		
		//sendTileUpdate(hex);
		
		
	}else{
		

		
		shieldingUnits = null;
		
		sellUnitBtn.disabled = true;

		// dont allow selecting while moving on the map.
		if(isDragging){
			return;
		}
		const myPlayer = getMyPlayer();
		
		let startHex = gameState.units.find(
			u => u.ownerIndex === myPlayer.playerIndex && u.internalType === 'boat'
		);
		if(startHex){
			// validSeaMoveHexes contains the radius of hexes that are valid.
			routeHighlight = findFastestRoute(startHex, hex, MAX_BOAT_MOVE_DIST);
		}
		
		let clickedHexTile = getTileAt(hex.q, hex.r);
		console.warn("handleHexClick: clickedHexTile:");
		console.warn(clickedHexTile);
		if(clickedHexTile){
			//makeExplosionBySoundMessage({name:'kill', q: clickedHexTile.q, r: clickedHexTile.r, action: "test", level:1});
			//makeExplosionBySoundMessage({name:'kill2', q: clickedHexTile.q, r: clickedHexTile.r, action: "test", level:1});
		}
		
		
		//let isLandTile = !isTileWater(clickedHexTile);
		let isLandTile = isTileLand(clickedHexTile); // only checks for "land" type, so cliff type wont be allowed.
		
		// maybe this should be called first? or not...
		//updateSelectedPoolInfo(hex);
		
		//let poolHex = getSelectedPoolHex();
		//console.log("handleHexClick: poolHex:");
		//console.log(poolHex);
		
		//let updatePools = false;
		let updatePools = true; // currently always updates info, so it will set selectedPool to null if not player own pool.

		
		// hide pool info initially, show it in updateSelectedPoolInfo if called:
		//hidePoolInfo();
		
		if (!myPlayer || myPlayer.isSpectator || !isMyTurn()) {
			if(isLandTile){
				// Spectator or not my turn, just select hex for highlighting pools:
				selectedHex = hex;
				deselectUnit(); // Deselect

				//buildPopup.style.display = 'none'; // not sure why this is here, maybe possible if somehow managed to end turn while popup is active?
				//updateHighlights();

			}else{
				deselectUnit(); // Deselect
				deselectHex();
			}

			hideBuildPopup(); //buildPopup.style.display = 'none'; // not sure why this is here, maybe possible if somehow managed to end turn while popup is active?
			
			
			
			updateHighlights();
				
			// update here before return or it wont be updated.
			if(updatePools){
				updateSelectedPoolInfo(hex);
				updatePools = false;
			}
			return;
		}
		


		// --- PLACING A UNIT ---
		if (placingUnit) {
			
			// find closest hex to move onto:
			let closestHex = getNearestValidHex(point);
			if(closestHex.found){
				hex.q = closestHex.q;
				hex.r = closestHex.r;
			}
			
			let poolHex = getSelectedPoolHex();
			console.log("handleHexClick: placingUnit poolHex:");
			console.log(poolHex);
			
			if(isTypeBoat(placingUnit.type)){
				
				updatePools = false;
				
				if(selectedUnit){
					let originPoolHex = {q:selectedUnit.q, r:selectedUnit.r};
				
					const buildCheck = isPlacementValid(placingUnit.type, hex, myPlayer, poolHex, true, selectedUnit);
					
					if (buildCheck.valid) {
						

						sendToHost({
							type: ACTION.action_build,
							unitType: placingUnit.type,
							q: hex.q,
							r: hex.r,
							unitId: selectedUnit.id,
							poolHex: originPoolHex, // selectedUnit hex pool loses the money.
						});
						
						// update here before return or it wont be updated.
						if(updatePools){
							updateSelectedPoolInfo(originPoolHex);
							updatePools = false;
						}
						
						deselectUnit();
					}else{
						playSound('protect');
					}
				}

			}else{
				// type is soldier or castle.
				
				if(isUnitTypeObject(placingUnit.type)){
					updatePools = false;
					
					if(selectedUnit){
						// type: ACTION.action_build_object,
						console.warn("selectedUnit action_build_object");
						
						let originPoolHex = {q:selectedUnit.q, r:selectedUnit.r};
					
						const buildCheck = isPlacementValid(placingUnit.type, hex, myPlayer, poolHex, true, selectedUnit);
						
						if (buildCheck.valid) {
							console.warn("buildCheck valid action_build_object");
							sendToHost({
								type: ACTION.action_build_object,
								unitType: placingUnit.type,
								q: hex.q,
								r: hex.r,
								unitId: selectedUnit.id, // the builder unit id. will be set hasMoved = true.
								poolHex: originPoolHex, // selectedUnit hex pool loses the money.
							});
			
							// update here before return or it wont be updated.
							if(updatePools){
								updateSelectedPoolInfo(originPoolHex);
								updatePools = false;
							}
							
							deselectUnit();
						}else{
							playSound('protect');
						}
					
					}
				}else{
					const buildCheck = isPlacementValid(placingUnit.type, hex, myPlayer, poolHex, true, selectedUnit);
					
					if (buildCheck.valid) {
						

						sendToHost({
							type: ACTION.action_build,
							unitType: placingUnit.type,
							q: hex.q,
							r: hex.r,
							poolHex: poolHex, // remember first hex from selected pool.
						});
						
						// update here before return or it wont be updated.
						if(updatePools){
							updateSelectedPoolInfo(hex);
							updatePools = false;
						}
						
						deselectUnit();
					} else {
						if(buildCheck.reason && buildCheck.reason === "low_level"){
							shieldingUnits = getShieldingUnits(hex.q, hex.r, myPlayer.playerIndex, getUnitLevel(placingUnit.type));
							shieldingStartTime = msNowFloor();
						}
						playSound('protect');
					}
				}
			}
			
			placingUnit = null; // "deselect", must do that because there is no cancel button (yet?)
			updateHighlights();
			

			buildOtherBtn.classList.remove("cancel");
			buildSoldierBtn.classList.remove("cancel");
			buildCastleBtn.classList.remove("cancel");
			
			return;
		}
		
		// --- MOVING A UNIT ---
		if (selectedUnit) {
	
	
			// find closest hex to move onto:
			let closestHex = getNearestValidHex(point);
			if(closestHex.found){
				hex.q = closestHex.q;
				hex.r = closestHex.r;
			}
			
			console.log("handleHexClick: selectedUnit");
			
			
			let deselected = false;

			if(hex.q === selectedUnit.q && hex.r === selectedUnit.r){
				// deselect if clicked same unit again:
				deselectUnit();
				//deselectHex();
				deselected = true;
			}
			if(!deselected){
				
				if(isTypeBoat(selectedUnit.type)){
					updatePools = false;
					
					//let unitCheck = gameState.units.find(u => u.id === selectedUnit.id);
					let moveCheck = isMoveValid(selectedUnit, { q: hex.q, r: hex.r }, myPlayer);
					
					
					if(moveCheck.valid){
						// unload_unit
						let unloadingToTile = moveCheck.action !== 'move';
						
						/*
						if(selectedUnit.loadedUnit){
							let landingTile = getTileAt(hex.q, hex.r);
							// landing validation is checked in  isMoveValid()
							// just check if we moved on land instead of water to know if unloading started.
							// allowed to land on "land" (not on "cliff").
							if(getTileType(landingTile) === 'land'){
								unloadingToTile = landingTile;
							}
						}
						*/
						
						if(unloadingToTile){
							sendToHost({
								type: ACTION.action_unload_unit,
								unitId: selectedUnit.id,
								toQ: hex.q,
								toR: hex.r,
							});
						}else{
							sendToHost({
								type: ACTION.action_move,
								unitId: selectedUnit.id,
								toQ: hex.q,
								toR: hex.r,
							});
						}
						
						deselectUnit();
						console.warn("isMoveValid = true");
					}else{
						console.warn("isMoveValid = false");
						
						let unitOnHex = getUnitAt(hex);
						
						if(unitOnHex){
							if(unitCanBeSelected(unitOnHex)){
								if(unitOnHex)
								selectedHex = {q:selectedUnit.q, r:selectedUnit.r};
								selectedUnit = unitOnHex;
								updatePools = false; // ensure it wont update pools with the hex we try to move onto.
								sellUnitBtn.disabled = isTypeBoat(selectedUnit.type);
								playSound('startmove');
							}
						}else{
						
							playSound('protect');
							// set selected hex to the selected unit position:
							// caused some crash on addCost() if moved to rock first and then to tree,
							// probably remembered the selectedHex as the rock hex, so it failed...
							selectedHex = {q:selectedUnit.q, r:selectedUnit.r};
							updatePools = false; // ensure it wont update pools with the hex we try to move onto.
							sellUnitBtn.disabled = false;
						}
					}
	
				}else{
					let poolHex = getSelectedPoolHex();
					console.log("handleHexClick: selectedUnit: poolHex");
					console.log(poolHex);
					
					let loadedIntoUnit = null;
					
					// check if trying to load selectedUnit into a boat unit:
					let unitOnHex = getUnitAt(hex);
					
					let selectBoat = false;
	
					if(unitOnHex){
						console.warn("unitOnHex");
						console.warn(unitOnHex);
						
						if(isTypeBoat(unitOnHex.type)){
							// dont load unit if there already is unit:
							if(!unitOnHex.loadedUnit){
								// allow loading only if unit stands next to the boat:
								if(isUnitNextToUnit(selectedUnit, unitOnHex)){
									console.warn("loading unit into boat");
									loadedIntoUnit = unitOnHex;
								}else{
									selectBoat = true;
								}
							}else{
								if(unitCanBeSelected(unitOnHex)){
									selectBoat = true;
								}

							}
						}
					}
					
					if(loadedIntoUnit){
						sendToHost({
							type: ACTION.action_load_unit,
							unitId: selectedUnit.id,
							targetUnitId: loadedIntoUnit.id,
							poolHex: poolHex,
						});
						deselectUnit();
						
					}else if(selectBoat){
						selectedUnit = unitOnHex;
						updatePools = false; // ensure it wont update pools with the hex we try to move onto.
						sellUnitBtn.disabled = true; // boats cant be sold.
						playSound('startmove');
					}else{
					
						// Check if clicking a valid move hex
						// validMoveHexes = highlighted move area.
						// poolHex guaranteed to be in validMoveHexes.
						const isValidMove = validMoveHexes.some(h => h.q === hex.q && h.r === hex.r);
						
						console.warn("isValidMove:",isValidMove);
						//console.log("isValidMove: "+isValidMove);
					
						if (isValidMove) {
							
							
							let unitCheck = gameState.units.find(u => u.id === selectedUnit.id);
							let moveCheck = isMoveValid(unitCheck, { q: hex.q, r: hex.r }, myPlayer);
							
							if(!moveCheck.valid){
								playSound('protect');
								console.warn("playsound protect");
							}else{
								console.warn("isMoveValid = true");
							}
							sendToHost({
								type: ACTION.action_move,
								unitId: selectedUnit.id,
								toQ: hex.q,
								toR: hex.r,
								poolHex: poolHex,
							});
							
							if(moveCheck.valid){
								deselectUnit();
							}else{
								// set selected hex to the selected unit position:
								// caused some crash on addCost() if moved to rock first and then to tree,
								// probably remembered the selectedHex as the rock hex, so it failed...
								selectedHex = {q:selectedUnit.q, r:selectedUnit.r};
								updatePools = false; // ensure it wont update pools with the hex we try to move onto.
								sellUnitBtn.disabled = false;
							}
							//deselectHex();
						} else {
							// Clicked somewhere else, check for new selection
							if(isLandTile){
								const isInvalidMove = invalidMoveHexes.some(h => h.q === hex.q && h.r === hex.r);
								if(isInvalidMove){
									shieldingUnits = getShieldingUnits(hex.q, hex.r, myPlayer.playerIndex, selectedUnit.level);
									shieldingStartTime = msNowFloor();
									sellUnitBtn.disabled = false;
									console.log("clicked hex:");
									console.log(hex);
									console.log("selected unit hex:");
									console.log({q:selectedUnit.q, r:selectedUnit.r});
									updateSelectedPoolInfo({q:selectedUnit.q, r:selectedUnit.r});
									updatePools = false; // ensure it wont update pools with the hex we try to move onto.
									
									playSound('protect');
								}
								
								const unitOnHex = getUnitAt(hex.q, hex.r);
								if(unitOnHex){
									if (unitOnHex.ownerIndex === localPlayer.playerIndex) {
										//if(unitTypeCanMove(unitOnHex.type) && !unitOnHex.hasMoved){
										//if(unitOnHex.internalType === 'soldier' && !unitOnHex.hasMoved){
										if(unitCanBeSelected(unitOnHex)){
											selectedUnit = unitOnHex; // Select new unit
											sellUnitBtn.disabled = false;
											selectedHex = hex;
											playSound('startmove');
										}else{
											deselectUnit(); // Deselect
											selectedHex = hex;
										}
									}else{
										// deselect when clicking enemy unit that was not protected:
										if(!isInvalidMove){
											deselectUnit(); // Deselect
											selectedHex = hex;
											//console.log("deselected");
										}
									}
								}else{
									// deselect when clicked just land that was not protected:
									if(!isInvalidMove){
										deselectUnit(); // Deselect
										selectedHex = hex;
										//console.log("deselected");
									}
								}
							}else{
								deselectUnit(); // Deselect
								deselectHex();
							}
						}
					}
				}
			}
		} else {
			// --- SELECTING AN UNIT ---
			
			// allow selecting any unit
			//if(isLandTile){
				const unitOnHex = getUnitAt(hex.q, hex.r);
				
				if (unitOnHex && unitOnHex.ownerIndex === localPlayer.playerIndex) {
					// allow only selecting movable units
					if(unitTypeCanMove(unitOnHex.type)){
					//if(unitOnHex.internalType === 'soldier'){
						if(!unitOnHex.hasMoved){
							//console.log("selected new unit");
							selectedUnit = unitOnHex;
							sellUnitBtn.disabled = isTypeBoat(selectedUnit.type);
							selectedHex = hex;
							
							console.warn("selectedUnit");
							console.warn(selectedUnit);
							if(!selectedUnit.hasMoved){
								playSound('startmove');
							}
						}else{
							// select the hex if cannot select unit.
							deselectUnit();
							selectedHex = hex;
						}
					}else{
						// dont allow selecting castles.
						deselectUnit();
						selectedHex = hex;
					}
				} else {
					// no unit or not my unit
					if(isLandTile){
						deselectUnit();
						selectedHex = hex;
					}else{
						deselectUnit();
						deselectHex();
					}
				}
			//}else{
			//	// was water tile
			//	deselectUnit(); // Deselect
			//	deselectHex();
			//}
		}
		
	
		if(updatePools){
			updateSelectedPoolInfo(hex);
		}
		
		updateHighlights();
	}
}




function findUnitPossibleMoves(this_selectedUnit, player){
	let this_poolStartHex = this_selectedUnit;
	let this_highlightedPool = [];
	let this_validMoveHexes = [];
	let this_invalidMoveHexes = [];
	
	const tile = getTileAt(this_poolStartHex.q, this_poolStartHex.r);
	
	if (tile && tile.ownerIndex === player.playerIndex) {
		// Run BFS to find all connected friendly hexes
		const queue = [tile];
		const visited = new Set([`${tile.q},${tile.r}`]);
		
		while (queue.length > 0) {
			const current = queue.shift();
			this_highlightedPool.push(current);
			
			//for (const n of getHexNeighbors(current.q, current.r)) {
			const neighbours = current.neighbours;
			for(let i = 0; i < neighbours.length; i++){
				const neigh = neighbours[i];
				if(neigh !== -1){
					const nTile = gameState.map.tilesData[neigh];
					const nKey = `${nTile.q},${nTile.r}`;
					//const nTile = getTileAt(n.q, n.r);
					if (nTile.ownerIndex === player.playerIndex && !visited.has(nKey)) {
						visited.add(nKey);
						queue.push(nTile);
					}
				}
			}
		}
	}
	
	const borderHexes = new Map(); // Use Map to avoid duplicates, key 'q,r'
	
	// Add all empty hexes *in* the pool as valid moves
	for (const tile of this_highlightedPool) {
		// removing this fixes bug not allowing moving around selected unit:
		//if (hex.q === selectedUnit.q && hex.r === selectedUnit.r) continue;
		if (!getUnitAt(tile.q, tile.r)) {
			//this_validMoveHexes.push(hex);
			this_validMoveHexes.push(tile);
		}
		
		// While we're here, find all neighbors to build the border set
		//for (const n of getHexNeighbors(hex.q, hex.r)) {
		const neighbours = tile.neighbours;
		for(let i = 0; i < neighbours.length; i++){
			const neigh = neighbours[i];
			if(neigh !== -1){
				const nTile = gameState.map.tilesData[neigh];
				const nKey = `${nTile.q},${nTile.r}`;
				//const nTile = getTileAt(n.q, n.r);
				// If neighbor exists, is not water, and is not in our pool
				// nTile.type !== 'water'
				if (!isTileWater(nTile) && !this_highlightedPool.some(p => p.q === nTile.q && p.r === nTile.r)) {
					borderHexes.set(nKey, nTile);
				}
			}
		}
	}
	
	// Now check all border hexes for validity
	for (const [key, tile] of borderHexes.entries()) {
		//const toTile = getTileAt(hex.q, hex.r); // We know this tile exists and isn't water
		const targetUnit = getUnitAt(tile.q, tile.r);
		const shieldLevel = getShieldLevelFromTile(tile, player.playerIndex);

		if (targetUnit) {
			if (targetUnit.ownerIndex === player.playerIndex) continue; // Should be impossible
			if (this_selectedUnit.level > shieldLevel && this_selectedUnit.level > targetUnit.level) {
				this_validMoveHexes.push(tile);
			} else {
				this_invalidMoveHexes.push(tile);
			}
		} else { // No target unit
			if (tile.ownerIndex !== undefined && tile.ownerIndex !== -1) { // Enemy land
				if (this_selectedUnit.level > shieldLevel) {
					this_validMoveHexes.push(tile);
				} else {
					this_invalidMoveHexes.push(tile);
				}
			} else { // Unowned land
				// Shields don't apply to unowned land
				this_validMoveHexes.push(tile);
			}
		}
	}
	//console.warn("this_validMoveHexes");
	//console.warn(this_validMoveHexes);
	return this_validMoveHexes;
}


function isHexInPool(pool, hex){
	if(pool && pool.hexes){
		for(let p = 0; p < pool.hexes.length; p++){
			if(pool.hexes[p].q == hex.q && pool.hexes[p].r == hex.r){
				return true;
			}
		}
	}
	return false;
}



function findFastestRoute(startHex, endHex, maxDistance = 50) {
	const startKey = `${startHex.q},${startHex.r}`;
	const endKey = `${endHex.q},${endHex.r}`;

	const visited = new Set([startKey]);
	const cameFrom = new Map();

	const queue = [{
		q: startHex.q,
		r: startHex.r,
		distance: 0
	}];

	while (queue.length > 0) {
		const { q, r, distance } = queue.shift();
		const currentKey = `${q},${r}`;

		if (currentKey === endKey) {
			const path = [];
			let k = currentKey;

			while (k) {
				const [pq, pr] = k.split(',').map(Number);
				path.push({ q: pq, r: pr });
				k = cameFrom.get(k);
			}

			return path.reverse();
		}

		if (distance === maxDistance) continue;

		const neighbors = getHexNeighbors(q, r);

		for (const n of neighbors) {
			const key = `${n.q},${n.r}`;
			if (visited.has(key)) continue;

			const isEndHex = key === endKey;

			// Block land unless this is the destination
			if (!isEndHex && isHexLand(n.q, n.r)){
				// not sure whats happening here actually...
				continue;
			}

			// Block units unless this is the destination
			if (!isEndHex) {
				const unitBlocking = gameState.units.some(
					u => u.q === n.q && u.r === n.r
				);
				if (unitBlocking) continue;
			}

			visited.add(key);
			cameFrom.set(key, currentKey);

			queue.push({
				q: n.q,
				r: n.r,
				distance: distance + 1
			});
		}
	}

	return null;
}



function findFastestRoute1(startHex, endHex, maxDistance = 50) {
	if(!isHexWater(endHex.q, endHex.r) || !isHexWater(startHex.q, startHex.r)){
		return null;
	}
	const startKey = `${startHex.q},${startHex.r}`;
	const endKey = `${endHex.q},${endHex.r}`;

	const visited = new Set([startKey]);
	const cameFrom = new Map();

	// Queue entries: { q, r, distance }
	const queue = [{
		q: startHex.q,
		r: startHex.r,
		distance: 0
	}];

	while (queue.length > 0) {
		const { q, r, distance } = queue.shift();
		const currentKey = `${q},${r}`;

		if (currentKey === endKey) {
			const path = [];
			let k = currentKey;

			while (k) {
				const [pq, pr] = k.split(',').map(Number);
				path.push({ q: pq, r: pr });
				k = cameFrom.get(k);
			}

			return path.reverse();
		}

		if (distance === maxDistance) continue;

		const neighbors = getHexNeighbors(q, r);

		for (const n of neighbors) {
			const key = `${n.q},${n.r}`;
			if (visited.has(key)) continue;

			// Land blocks movement
			if (!isHexWater(n.q, n.r)) continue;

			// Units block movement
			const unitBlocking = gameState.units.some(
				u => u.q === n.q && u.r === n.r
			);
			if (unitBlocking) continue;

			visited.add(key);
			cameFrom.set(key, currentKey);

			queue.push({
				q: n.q,
				r: n.r,
				distance: distance + 1
			});
		}
	}

	return null;
}



// use findFastestRoute to get the route from a to b.
// validSeaMoveHexes contains these results.
function getReachableHexes(startHex, maxRange = 5) {
	const visited = new Set([`${startHex.q},${startHex.r},false`]);
	const results = [];

	// Queue entries: { q, r, distance, usedLand }
	const queue = [{
		q: startHex.q,
		r: startHex.r,
		distance: 0,
		usedLand: false
	}];

	while (queue.length > 0) {
		const { q, r, distance, usedLand } = queue.shift();

		if (distance === maxRange) continue;

		const neighbors = getHexNeighbors(q, r);

		for (const n of neighbors) {
			const tile = getTileAt(n.q, n.r);
			const isLand = getTileType(tile) === 'land';
			const nextUsedLand = usedLand || isLand;

			// Cannot enter more than one land hex
			if (usedLand && isLand) continue;
			
			const unitFound = gameState.units.some(
				u => u.q === n.q && u.r === n.r
			);
			if (unitFound && !isLand){
				continue;
			}

			/*
			// units/objects blocking is checked in  isMoveValid()
			// todo: could add same checks here too though. later.
			
			// Units always block
			const unitBlocking = gameState.units.some(
				u => u.q === n.q && u.r === n.r
			);
			if (unitBlocking) continue;
		
			// rock objects always block
			if(tile && tile.object === 'rock2') continue;
			*/

			const key = `${n.q},${n.r},${nextUsedLand}`;
			if (visited.has(key)) continue;
			visited.add(key);

			results.push({ q: n.q, r: n.r });

			// Only continue BFS from water, or from land if we just entered it
			if (!isLand) {
				queue.push({
					q: n.q,
					r: n.r,
					distance: distance + 1,
					usedLand: nextUsedLand
				});
			}
		}
	}

	return results;
}


// use findFastestRoute to get the route from a to b.
function getReachableHexes2(startHex, maxRange = 5) {
	const visited = new Set([`${startHex.q},${startHex.r}`]);
	const results = [];

	// Queue entries: { q, r, distance }
	const queue = [{
		q: startHex.q,
		r: startHex.r,
		distance: 0
	}];

	while (queue.length > 0) {
		const { q, r, distance } = queue.shift();

		if (distance === maxRange) continue;

		const neighbors = getHexNeighbors(q, r);

		for (const n of neighbors) {
			const key = `${n.q},${n.r}`;
			if (visited.has(key)) continue;

			visited.add(key);

			// Land blocks movement
			if (!isHexWater(n.q, n.r)) continue;

			// Units block movement
			const unitBlocking = gameState.units.some(
				u => u.q === n.q && u.r === n.r
			);
			if (unitBlocking) continue;

			results.push({ q: n.q, r: n.r });

			queue.push({
				q: n.q,
				r: n.r,
				distance: distance + 1
			});
		}
	}

	return results;
}


let validSeaMoveHexes = [];
let BOAT_MOVE_DIST = 6; // move dist per day
let BOAT_MOVE_DAYS = 7; // days until explosion.
let MAX_BOAT_MOVE_DIST = BOAT_MOVE_DIST*BOAT_MOVE_DAYS; // max dist to show with findfastestroute()


function updateHighlights() {
	// Clear all highlights
	highlightedPool = [];
	validMoveHexes = [];
	invalidMoveHexes = [];
	validSeaMoveHexes = [];
	
	enemyHighlightedPool = [];
	
	let poolStartHex = null;
	if (selectedUnit) {
		poolStartHex = selectedUnit;
		if(isTypeBoat(selectedUnit.type)){
			validSeaMoveHexes = getReachableHexes(poolStartHex, BOAT_MOVE_DIST);
		}
	} else if (selectedHex) {
		poolStartHex = selectedHex;
		console.warn("poolStartHex",poolStartHex);
	}

	
	const myPlayer = getMyPlayer();
	if (!myPlayer) return;

	// --- 1. Find the connected pool ---
	if (poolStartHex) {
		const tile = getTileAt(poolStartHex.q, poolStartHex.r);
		if (tile) {
			if(tile.ownerIndex === myPlayer.playerIndex){
				// Run BFS to find all connected friendly hexes
				const queue = [{q: poolStartHex.q, r: poolStartHex.r}];
				const visited = new Set([`${poolStartHex.q},${poolStartHex.r}`]);
				
				while (queue.length > 0) {
					const current = queue.shift();
					highlightedPool.push(current);
					
					for (const n of getHexNeighbors(current.q, current.r)) {
						const nKey = `${n.q},${n.r}`;
						const nTile = getTileAt(n.q, n.r);
						if (nTile && nTile.ownerIndex === myPlayer.playerIndex && !visited.has(nKey)) {
							visited.add(nKey);
							queue.push(n);
						}
					}
				}
			}else if(tile.ownerIndex !== -1){
				// create highlight for enemy pools:
				
				// Run BFS to find all connected friendly hexes
				const queue = [{q: poolStartHex.q, r: poolStartHex.r}];
				const visited = new Set([`${poolStartHex.q},${poolStartHex.r}`]);
				
				while (queue.length > 0) {
					const current = queue.shift();
					enemyHighlightedPool.push(current);
					
					for (const n of getHexNeighbors(current.q, current.r)) {
						const nKey = `${n.q},${n.r}`;
						const nTile = getTileAt(n.q, n.r);
						if (nTile && nTile.ownerIndex === tile.ownerIndex && !visited.has(nKey)) {
							visited.add(nKey);
							queue.push(n);
						}
					}
				}
			}
		}
	}
	
	// todo: make highlight for build too.
	// change selectedUnit to unit with custom values with level etc.
	let unit = {level:-1};
	if(selectedUnit){
		unit.level = selectedUnit.level;
	}
	if(placingUnit){
		unit.level = getUnitInfo(placingUnit.type).level;
		console.log(unit.level);
	}
	
	// --- 2. Highlight movement options (only if a unit is selected) ---
	//if (selectedUnit) {
	if(unit.level !== -1){
		const borderHexes = new Map(); // Use Map to avoid duplicates, key 'q,r'
		
		// Add all empty hexes *in* the pool as valid moves
		for (const hex of highlightedPool) {
			// removing this fixes bug not allowing moving around selected unit:
			// todo: might actually make another bug that allows moving always to neighbours...
			//if (hex.q === selectedUnit.q && hex.r === selectedUnit.r) continue;
			if (!getUnitAt(hex.q, hex.r)) {
				// todo: move this elsewhere.. might fuck up stuff.
				validMoveHexes.push(hex);
			}
			
			// While we're here, find all neighbors to build the border set
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nKey = `${n.q},${n.r}`;
				const nTile = getTileAt(n.q, n.r);
				// If neighbor exists, is not water, and is not in our pool
				// nTile && nTile.type !== 'water'
				if (!isTileWater(nTile) && !highlightedPool.some(p => p.q === n.q && p.r === n.r)) {
					borderHexes.set(nKey, n);
				}
			}
		}
		
		// Now check all border hexes for validity
		for (const [key, hex] of borderHexes.entries()) {
			const toTile = getTileAt(hex.q, hex.r); // We know this tile exists and isn't water
			const targetUnit = getUnitAt(hex.q, hex.r);
			const shieldLevel = getShieldLevelFromTile(toTile, myPlayer.playerIndex);


			if (targetUnit) {
				if (targetUnit.ownerIndex === myPlayer.playerIndex){
					continue; // Should be impossible
				}
				if (unit.level > shieldLevel && unit.level > targetUnit.level) {
					validMoveHexes.push(hex);
				} else {
					invalidMoveHexes.push(hex);
				}
			} else { // No target unit
				if (toTile.ownerIndex !== -1) { // Enemy land
					if (unit.level > shieldLevel) {
						validMoveHexes.push(hex);
					} else {
						invalidMoveHexes.push(hex);
					}
				} else { // Unowned land
					// Shields don't apply to unowned land
					validMoveHexes.push(hex);
				}
			}
		}
	}
}



function openBuildPopup(type) {
	placingUnit = null;
	
	// dont deselect unit if building boats.
	// todo: make better check for boats only...
	//if(type !== "other"){
		//deselectUnit();
	//}
	//deselectHex();
	
	const data = UNITS[type];//(type === 'soldier') ? SOLDIER_DATA : CASTLE_DATA;
	console.warn(data);
	const poolSavings = getSelectedPoolSavings();
	
	buildSoldierBtn.classList.remove("cancel");
	buildCastleBtn.classList.remove("cancel");
	buildOtherBtn.classList.remove("cancel");
	
	let buildprefix = "Buy";
	let buildsuffix = type;
	if(type === "castle"){
		buildprefix = "Build"; // build castle
		buildsuffix = "castle";
	}else if(type === "soldier"){
		buildprefix = "Recruit"; // recruit warrior
		buildsuffix = "warrior";
	}else if(type === "other"){
		buildprefix = "Build"; // build item
		buildsuffix = "item";
	}
	buildPopupTitle.textContent = `${buildprefix} ${buildsuffix}`;
	buildPopupList.innerHTML = '';
	
	for (const key in data) {
		
		const item = data[key];
		//const canAfford = poolSavings >= item.cost;
		let canAfford = canAffordCheck(poolSavings, item.cost);
		let isDisabled = false;
		
		let extraInfo = "";
		let countInfo = "";
		
		let totalMines = getMyPlayer().totalMines;
		let totalBoats = getMyPlayer().totalBoats;
		
		if(item.type === "boat" || item.type === "mine"){
			if(!selectedUnit){
				extraInfo = "<br>(Select Unit)";
			}
				if(item.type === "mine"){
					countInfo = " ("+totalMines+"x)";
				}else if(item.type === "boat"){
					countInfo = " ("+totalBoats+"x)";
				}
			
		}
		
		if(item.type === "boat" && !gameState.settings.useBoats){
			isDisabled = true;
			extraInfo = "<br>(Disabled)";
		}
		if(item.type === "mine" && !gameState.settings.useLandmines){
			isDisabled = true;
			extraInfo = "<br>(Disabled)";
		}
		
		if(item.type === "mine" && totalMines < 1){
			isDisabled = true;
		}
		if(item.type === "boat" && totalBoats < 1){
			isDisabled = true;
		}
		
		// boats can be built only if an unit was selected:
		if(item.type === "boat" && !selectedUnit){
			canAfford = false;
		}
		const itemEl = document.createElement('div');
		itemEl.className = 'build-item';
		if (!canAfford){
			//itemEl.classList.add('disabled');
			isDisabled = true;
		}
		if(type === "other"){
			// must have unit selected to use mines or boats.
			// todo: make specific rules per "other" units.
			if(!selectedUnit){
				//itemEl.classList.add('disabled');
				isDisabled = true;
			}
		}
		if(isDisabled){
			itemEl.classList.add('disabled');
		}
		
		let imagePath = getImagePath(item);
		// <span>${item.name} (Lvl ${item.level})</span>
		itemEl.innerHTML = `
			<span class="elem-left"><img src="${imagePath}" width="50"></span>
			<span class="elem-center cost"><span style="color:white">${item.visibleName}${extraInfo}</span></span>
			<span class="elem-count cost" style="width:40px"><span style="color:white">${countInfo}</span></span>
			<span class="elem-right cost"><span style="color:white">Cost:</span> ${item.cost}${item.wage ? `<br><span style="color:white">Wage:</span> ${item.wage}` : ''}</span>
		`;
		
		if (canAfford && !isDisabled) {
			itemEl.onclick = () => {
				placingUnit = {
					type: item.name, // "peasant" etc.
					cost: item.cost,
					poolHex: getSelectedPoolHex(), // not needed here? called in  handleHexClick() also.
				};
				updateHighlights();
				
				playSound('startmove');

				console.log("placingUnit");
				console.log(placingUnit);
				console.log("type");
				console.log(type);
				if(type === 'soldier'){
					buildSoldierBtn.classList.add("cancel");
				}else if(type === 'castle'){
					buildCastleBtn.classList.add("cancel");
				}else if(type === 'other'){
					buildOtherBtn.classList.add("cancel");
				}
				//buildPopup.style.display = 'none';
				hideBuildPopup();
			};
		}
		buildPopupList.appendChild(itemEl);
	}
	
	//buildPopup.style.display = 'block';
	showBuildPopup();
}


function getUnitInfo(unitType){
	return UNITS.ALL[unitType] ?? null;
}

function unitTypeExists(unitType){
	for (const key in UNITS.ALL) {
		if(key === unitType){
			return true;
		}
	}
	//if(SOLDIER_DATA[unitType] || CASTLE_DATA[unitType]){
	//	return true;
	//}
	return false;
}

function getUnitLevel(unitType){
	let unitInfo = getUnitInfo(unitType);
	if(unitInfo){
		return unitInfo.level;
	}
	//if(SOLDIER_DATA[unitType]){
	//	return SOLDIER_DATA[unitType].level;
	//}
	//if(CASTLE_DATA[unitType]){
	//	return CASTLE_DATA[unitType].level;
	//}
	return 0; // fallback.
}

function getUnitCost(unitType){
	let unitInfo = getUnitInfo(unitType);
	console.warn("unitInfo", unitType);
	console.warn(unitInfo);
	if(unitInfo){
		return unitInfo.cost;
	}
	/*
	if(SOLDIER_DATA[unitType]){
		return SOLDIER_DATA[unitType].cost;
	}
	if(CASTLE_DATA[unitType]){
		return CASTLE_DATA[unitType].cost;
	}
	*/
	return 0; // fallback.
}



// iscastle is_castle
function isTypeCastle(unitType){
	return getUnitInfo(unitType)?.type === 'castle';
}
function isTypeSoldier(unitType){
	return getUnitInfo(unitType)?.type === 'soldier';
}
function isTypeBoat(unitType){
	return getUnitInfo(unitType)?.type === 'boat';
}
function isTypeMine(unitType){
	return getUnitInfo(unitType)?.type === 'mine';
}

function getUnitType(unitType){
	return getUnitInfo(unitType)?.type ?? null;
}

function isCastle(unit){
	return unit && unit.internalType === 'castle';
}
function isSoldier(unit){
	return unit && unit.internalType === 'soldier';
}

function isTileMinePlayerMine(tile, playerIndex){
	let foundEnemyMine = false;
	if(tile.object && getUnitType(tile.object) === "mine"){
		if(tile.objectOwnerIndexes !== undefined){
			for(let i = 0; i < tile.objectOwnerIndexes.length; i++){
				// if there was mine set by any other player than you:
				if(tile.objectOwnerIndexes[i] !== playerIndex){
					foundEnemyMine = true;
					break;
				}
			}
		}
	}
	return !foundEnemyMine;
}



function getShieldLevelFromTile(tile, perspectiveOwnerIndex){
	let maxShield = 0;
	const neighbours = tile.neighbours;
	for(let i = 0; i < neighbours.length; i++){
	//for (const n of getHexNeighbors(q, r)) {
		const neigh = neighbours[i];
		if(neigh !== -1){
			const nTile = gameState.map.tilesData[neigh];
			const unit = getUnitAt(nTile.q, nTile.r);
			if (unit && tile.ownerIndex === unit.ownerIndex){
				if (unit.ownerIndex !== perspectiveOwnerIndex) {
					// It's an enemy unit
					maxShield = Math.max(maxShield, unit.level);
				}
			}
		}
	}
	return maxShield;
}


function getShieldLevel(q, r, perspectiveOwnerIndex) {
	const tile = getTileAt(q, r);
	if(tile){
		return getShieldLevelFromTile(tile, perspectiveOwnerIndex);
	}else{
		return 0; // fallback if tile doesnt exist.
	}
}


function getShieldingUnits(q, r, perspectiveOwnerIndex, compareUnitLevel) {
	const tile = getTileAt(q, r);
	let unitsShielding = [];
	
	if(tile){
		const unit = getUnitAt(q, r);
		if (unit && tile.ownerIndex === unit.ownerIndex){
			if (unit.ownerIndex !== perspectiveOwnerIndex) {
				// It's an enemy unit
				if(compareUnitLevel <= unit.level){
					unitsShielding.push(unit);
				}
			}
		}
		for (const n of getHexNeighbors(q, r)) {
			const unit = getUnitAt(n.q, n.r);
			if (unit && tile.ownerIndex === unit.ownerIndex){
				if (unit.ownerIndex !== perspectiveOwnerIndex) {
					// It's an enemy unit
					if(compareUnitLevel <= unit.level){
						unitsShielding.push(unit);
					}
				}
			}
		}
	}
	return unitsShielding;
}





function goodMove(action, target = null){
	const move = { valid: true, action: action, target: target };
	//console.warn(move);
	return move;
}
function badMove(reason){
	const move = { valid: false, reason: reason };
	//console.warn(move);
	return move;
}



// --- HOST-SIDE VALIDATION ---

function isMoveValid(unit, toHex, player) {
	if (unit.hasMoved){
		return badMove('Unit has already moved');
	}
	if(!unitTypeCanMove(unit.type)){
		return badMove('Unit type cannot move');
	}
	
	// BOAT UNITS MOVEMENT:
	if(isTypeBoat(unit.type)){
		
		let poolStartHex = {q: unit.q, r: unit.r}; 
		let validHexes = getReachableHexes(poolStartHex, BOAT_MOVE_DIST);
		
		// wont allow moving onto land unless its next to water (landing checked later).
		if(!validHexes.some(h => h.q === toHex.q && h.r === toHex.r)){
			return badMove('out_of_range');
		}
		
		
		const targetUnit = getUnitAt(toHex.q, toHex.r);
		
		/////////////////
		// unloading aka landing validation:
		//
		let loadedUnit = unit.loadedUnit;
		
		let toTile = getTileAt(toHex.q, toHex.r);
		
		if(loadedUnit){
			
			if(getTileType(toTile) === 'land'){
				//if (toTile.object && toTile.object === 'rock2'){
				//	return badMove('blocked by rock');
				//}
				if(!isUnitNextToHex(unit, toHex)){
					return badMove('out_of_range');
				}
				
				if (toTile.object && toTile.object === 'rock2' && loadedUnit.level < 2){
					return badMove('low_level');
				}
				
				const shieldLevel = getShieldLevelFromTile(toTile, player.playerIndex);

				if (targetUnit) {
					if (targetUnit.ownerIndex === player.playerIndex) {
						return badMove('Cannot move onto own unit.'); // Should be caught by pool check, but safe
					}
					if (loadedUnit.level > shieldLevel && loadedUnit.level > targetUnit.level) {
						return goodMove('unload_unit_attack', targetUnit);
					} else {
						return badMove('low_level');
					}
				}
				// No target unit
				if (toTile.ownerIndex !== -1) { // It's enemy land
					if (loadedUnit.level > shieldLevel) {
						return goodMove('unload_unit');
					} else {
						// todo: think again....
						if(toTile.ownerIndex !== loadedUnit.ownerIndex){
							return badMove('low_level');
						}else{
							return goodMove('unload_unit');
						}
					}
				} else { // It's unowned land
					// New rule: Shields do not block movement to unowned land
					return goodMove('unload_unit');
				}
				
				return goodMove('unload_unit');
			}else{
				// WATER TILE:
				
				// dont allow moving onto other boats:
				// todo: probably not needed here anymore since units are checked earlier.
				if(targetUnit){
					return badMove('not_empty');
				}
				// just move the boat:
				return goodMove('move');
			}
		}else{
			// NO LOADED UNIT:
			
			// dont allow moving onto other boats:
			// todo: probably not needed here anymore since units are checked earlier.
			if(targetUnit){
				return badMove('not_empty');
			}
			if(getTileType(toTile) === 'land'){
				return badMove('cannot move on land without loaded unit');
			}else{
				// WATER TILE:
				
				// just move the boat:
				return goodMove('move');
			}
		}
		
		// todo: probably remove this or make logic structure better.
		// just move the boat:
		return goodMove('move');
	}
	
	
	// OTHER UNIT TYPES:
	
	const toTile = getTileAt(toHex.q, toHex.r);
	if (!isTileLand(toTile)){
		return badMove('only land type allowed.');
	}
	
	if (toTile.object && toTile.object === 'rock2' && unit.level < 2){
		return badMove('low_level');
	}
	
	
	const targetUnit = getUnitAt(toHex.q, toHex.r);

	// Find the unit's entire pool
	const unitPool = [];
	const queue = [{q: unit.q, r: unit.r}];
	const visited = new Set([`${unit.q},${unit.r}`]);
	
	while(queue.length > 0) {
		const current = queue.shift();
		unitPool.push(current);
		
		for (const n of getHexNeighbors(current.q, current.r)) {
			const nKey = `${n.q},${n.r}`;
			const nTile = getTileAt(n.q, n.r);
			if (nTile && nTile.ownerIndex === player.playerIndex && !visited.has(nKey)) {
				visited.add(nKey);
				queue.push(n);
			}
		}
	}
	
	// --- Case 1: Moving onto own tile (inside the pool) ---
	const isMovingInPool = unitPool.some(h => h.q === toHex.q && h.r === toHex.r);
	if (isMovingInPool) {
		if (targetUnit){
			return badMove('Cannot move onto own unit.');
		}
		return goodMove('move');
	}

	// --- Case 2: Moving outside the pool ---
	// Check if toHex is a neighbor of *any* hex in the pool
	let isBorderHex = false;
	for (const poolHex of unitPool) {
		if (getHexDistance(poolHex.q, poolHex.r, toHex.q, toHex.r) === 1) {
			isBorderHex = true;
			break;
		}
	}

	if (!isBorderHex) {
		return badMove('out_of_range');
	}
	
	// It's a valid border hex, now check shields and targets
	const shieldLevel = getShieldLevelFromTile(toTile, player.playerIndex);

	if (targetUnit) {
		if (targetUnit.ownerIndex === player.playerIndex) {
			return badMove('Cannot move onto own unit.'); // Should be caught by pool check, but safe
		}
		if (unit.level > shieldLevel && unit.level > targetUnit.level) {
			return goodMove('attack', targetUnit);
		} else {
			return badMove('low_level');
		}
	}
	
	// No target unit
	if (toTile.ownerIndex !== -1) { // It's enemy land
		if (unit.level > shieldLevel) {
			return goodMove('move');
		} else {
			// todo: think again....
			if(toTile.ownerIndex !== unit.ownerIndex){
				return badMove('low_level');
			}else{
				return goodMove('move');
			}
		}
	} else { // It's unowned land
		// New rule: Shields do not block movement to unowned land
		return goodMove('move');
	}
}


function getVisibleObjectAt(q, r){
	let tile = getTileAt(q, r);
	if(tile.object){
		// object is same as unitType when placing object instead of unit.
		if(!isUnitTypeInvisibleObject(tile.object)){
			return true;
		}
	}
	return false;
}


// --- HOST-SIDE VALIDATION ---
// unitType = unit type being built (horse, peasant, etc..)
// hex      = where he builds it
// player   = who builds it
let prevhex = "";

let placementframe = 0;

// isvalidplacement
// unitType = what unit to build 
// hex = where to build
// fromHex = unit actually, but contains q,r coordinates.
function isPlacementValid(unitType, hex, player, poolHex, log_enabled = true, fromHex = null) {
	console.warn("isPlacementValid CALLED");
	if(!unitTypeExists(unitType)){
		console.error("unit_not_exist", unitType);
		return badMove("unit_not_exist"); // unit type doesnt exist!
	}
	
	if(isTypeBoat(unitType)){
		console.warn(unitType);
		if(!fromHex){
			return badMove('unit not selected');
		}
		if(!isHexNextToHex(fromHex, hex)){
			return badMove('out_of_range');
		}
		// todo: add this check too:
		//if (!canAffordCheck(actionPool.totalSavings, unitCost)) {
		//	return badMove("not_enough_money");
		//}
		if(!isHexWater(hex.q, hex.r)){
			return badMove('not_water');
		}
		if(getUnitAt(hex.q, hex.r)){
			return badMove('not_empty');
		}
		return goodMove('move');
	}else if(isUnitTypeObject(unitType)){
		// action.action_build_object
		// more logic here.
		if(!fromHex){
			return badMove('unit not selected');
		}
		if(!isHexNextToHex(fromHex, hex)){
			return badMove('out_of_range');
		}
		
		let tile = getTileAt(hex.q, hex.r);

		
		if (!isTileLand(tile)){
			return badMove('not_land');
		}

		
		if(tile.object && tile.objectOwnerIndexes !== undefined && tile.objectOwnerIndexes.includes(player.playerIndex)){
			return badMove('already_has_mine');
		}
		
		if(getUnitAt(hex.q, hex.r)){
			return badMove('not_empty');
		}
		// dont allow placing on visible objects.
		// if there already is a mine, it should be replaced silently. 
		//   owner of mine will see his mine disappearing.
		//   maybe should also give ownerIndex for the objects, so you can see your own mines.
		//   tile.objectOwnerIndex could be the key. cant use tile.ownerIndex since its used for tiles ownership.
		//   remember to edit compressed commands for replays, maybe put ownerindex and objectownerindex inside string separated by space.
		if(getVisibleObjectAt(hex.q, hex.r)){
			return badMove('has_visible_object');
		}
		return goodMove('move');
	}
	//placementframe++;
	//console.log("placementframe: "+placementframe);

	//return  isMoveValid(unit, hex, player);
	
	//console.warn("isPlacementValid: selectedPool");
	//console.warn(selectedPool);
	

	
	let unitLevel = getUnitLevel(unitType);
	let unitCost = getUnitCost(unitType);


	let actionPool;

	
	if(isHost()){
		// weird, before this worked fine with clients too, now only host can use this.
		actionPool = findSelectedPool(poolHex, findEconomyPools(player.playerIndex, log_enabled), player.playerIndex);
	}else{
		actionPool = findSelectedPool(poolHex, localPlayerPools, player.playerIndex);
	}
	
	
	if (!canAffordCheck(actionPool.totalSavings, unitCost)) {
		return badMove("not_enough_money");
	}
	
	let logallowed = prevhex !== (hex.q+","+hex.r);
	if(logallowed){
		//console.log("unitType = "+unitType);
		//console.log("hex = "+hex.q+","+hex.r);
		//console.log("player.id = "+player.id);
		prevhex = hex.q+","+hex.r;
	}
	
	
	const tile = getTileAt(hex.q, hex.r);
	if (!isTileLand(tile)){
		return badMove("not_land"); // Must be on land
	}
	if (tile.object && tile.object === 'rock2' && unitLevel < 2){
		return badMove('low_level');
	}
	
	
	// if there is an unit on the hex:
	const hexUnit = getUnitAt(hex.q, hex.r);
	if (hexUnit){
		//console.log("hexUnit exists:");
		//console.log(hexUnit);
		
		// checks for castles and soldiers placement too.
		if(hexUnit.ownerIndex === player.playerIndex){
			return badMove("not_empty"); // Must be empty
		}else{
			// if trying to kill enemy player:
			// todo: probably need to check if trying to place castle, 
			//       so it wont allow placing castle on top of enemy soldier.
			

			// Check if any neighbour is my land:
			// and the neighbour hex is in actionPool
			let isNeighborOwned = false;
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nTile = getTileAt(n.q, n.r);
				if (nTile && nTile.ownerIndex === player.playerIndex && isHexInPool(actionPool, nTile)) {
					isNeighborOwned = true;
					break;
				}
			}
			// if not in build radius:
			if (!isNeighborOwned){
				return badMove("out_of_range");
			}else{
				// only soldiers can kill other units
				if(isTypeSoldier(unitType)){
					// if it was in build radius:
					let shieldLevel = getShieldLevelFromTile(tile, player.playerIndex);
					// if the enemy unit level was higher than placed unit level:
					if(shieldLevel >= unitLevel || hexUnit.level >= unitLevel){
						return badMove("low_level");
					}else{
						return goodMove('attack', hexUnit);
					}
				}
			}
		}
	}
	
	// if new unit is a castle:
	if (isTypeCastle(unitType)) {
		// if not your tile or not in your selected pool:
		if (tile.ownerIndex !== player.playerIndex || !isHexInPool(actionPool, hex)){
			if(logallowed){
				//console.log("trying to place castle");
			}
			return badMove("not_my_hex"); // Must own hex
		}
		// if there is object:
		// original game allows placing castles on objects.
		//if (tile.object){
		//	return badMove("tile has object"); // not sure if original game had this rule: Must be clear (no tree/grass)
		//}
	} else {
		// if new unit is a soldier:
		// Rules are "neighbouring land I own, or in the land I own"
		
		// if new place is not your land:
		if (tile.ownerIndex !== player.playerIndex) {
			if(logallowed){
				//console.log("trying to place soldier");
			}
			
			// Check if any neighbour is my land:
			// and is in actionPool
			let isNeighborOwned = false;
			for (const n of getHexNeighbors(hex.q, hex.r)) {
				const nTile = getTileAt(n.q, n.r);
				if (nTile && nTile.ownerIndex === player.playerIndex && isHexInPool(actionPool, nTile)) {
					isNeighborOwned = true;
					break;
				}
			}
			
			// if not in build radius:
			if (!isNeighborOwned){
				return badMove("out_of_range");
			}else{
				// if it was in build radius:
				let shieldLevel = getShieldLevelFromTile(tile, player.playerIndex);
				// if the enemy unit level was higher than placed unit level:
				if(shieldLevel >= unitLevel){
					return badMove("low_level");
				}
			}
		}else{
			// was my land, check if its in selected pool:
			if(!isHexInPool(actionPool, hex)){
				return badMove("not_my_hex");
			}
		}
	}
	
	
	return goodMove('move');
}




function isAiPlayer(playerIndex){
	let player = getPlayerByIndex(playerIndex);
	return player && player.isAI;
}


// gets the amount of money you get by selling a soldier.
function getUnitSellPrice(unit){
	let unitInfo = getUnitInfo(unit.type);//SOLDIER_DATA[unit.type];
	if(unitInfo){
		return unitInfo.sell;
	}
	return 0;
}


// Example usage:
//const tileChangedUpdates = [
//   { type: 'tile_ changed', q: 1, r: 2, ownerId: 5 },
//   { type: 'tile_ changed', q: 1, r: 2, object: null }
//];
// Output:
// [{ type: 'tile_ changed', q: 1, r: 2, ownerId: 5, object: null }]
//
//const tileChangedUpdates = [
//   { type: 'tile_ changed', q: 1, r: 2, ownerId: 5 },
//   { type: 'tile_ changed', q: 1, r: 3, object: null }
//];
// Output:
// [{ type: 'tile_ changed', q: 1, r: 2, ownerId: 5 }]
// [{ type: 'tile_ changed', q: 1, r: 3, object: null }]
function mergeUpdates(updates) {
	const merged = [];

	const map = new Map(); // key will be `${q},${r}`

	for (const update of updates) {
		const key = `${update.q},${update.r}`;
		if (!map.has(key)) {
			map.set(key, { ...update }); // clone the object
		} else {
			Object.assign(map.get(key), update); // merge new properties
		}
	}

	return Array.from(map.values());
}

// push to updates all tile_changed updates that were merged into one:
function pushMergedUpdates(updates, updatesList){
	let mergedTileUpdates = mergeUpdates(updatesList);
	for(let i = 0; i < mergedTileUpdates.length; i++){
		updates.push(mergedTileUpdates[i]);
	}
}


function actionAllowedForEveryone(action){
	if(action.type === ACTION.action_edit_tile){
		return true;
	}
	return false;
}


// HOST-ONLY function
// NOTE: MUST use playerId here.
function executeAction(playerId, action) {
	console.log("executeAction", action);

	if (!isHost()) return;
	//console.log("executeAction 2");
	
	const player = getPlayer(playerId);
	const playerIndex = getPlayerIndex(playerId);
	
	if(!actionAllowedForEveryone(action)){
		if (!player || player.id !== getCurrentTurnPlayer()?.id) {
			console.warn(`Action from wrong player: ${playerId}`);
			return;
		}
	}
	
	//console.log("executeAction 3");
	
	let updates = []; // Array of update messages to broadcast
	let sounds = []; // Array of sounds to broadcast
	actionForUndo = null;
	undoDisabled = false;
	
	let checkPlayers = [];

	switch (action.type) {
		case ACTION.action_sell: {
			if(gameState.settings.gameOver) return;
			// sell unit
			
			//console.log("executeAction: action_sell");
			
			const { unitId, poolHex } = action;
			console.log("poolHex");
			console.log(poolHex);
			
			const unit = gameState.units.find(u => u.id === unitId);
			// dont sell if not your unit:
			// dont sell if unit already moved:
			if (!unit || 
				unit.ownerIndex !== playerIndex || 
				unit.hasMoved){
				return;
			}
			
			let sellPrice = getUnitSellPrice(unit);
			
			actionForUndo = {
				type: 'sell', 
				soldUnit: unit, 
				sellPrice: sellPrice,
				poolHex: poolHex,
			};
			
			let actionPool = findSelectedPool(poolHex, findEconomyPools(playerIndex), playerIndex);

			console.log("actionPool:");
			console.log(actionPool);

			addCost(actionPool, sellPrice, poolHex, action.type);
			
			// remove unit:
			updates.push({ type: ACTION.unit_removed, unitId: unit.id, FText: sellPrice });
			
			if(!isAiPlayer(playerIndex)){
				sounds.push({name:'sell', q: unit.q, r: unit.r, action: action.type, level: unit.level});
			}
			break;
		}
		case ACTION.action_move: {
			if(gameState.settings.gameOver) return;
			// move unit
			
			console.warn("executeAction action_move");
			
			const { unitId, toQ, toR, poolHex } = action;
			console.log("poolHex");
			console.log(poolHex);
			
			
			
			const unit = gameState.units.find(u => u.id === unitId);
			let unitCopy = {...unit}; // used when killing current unit.
			if (!unit || unit.ownerIndex !== playerIndex) return;
			
			let pq = unit.q;
			let pr = unit.r;
			
			
			const moveCheck = isMoveValid(unit, { q: toQ, r: toR }, player);
			
			if (moveCheck.valid) {
				console.warn("executeAction action_move moveCheck", moveCheck);
				
				
				if(isTypeBoat(unit.type)){
					const fromQ = unit.q;
					const fromR = unit.r;

					actionForUndo = {
						type: 'move',
						unitId: unit.id,
						fromQ, 
						fromR,
						toQ, 
						toR,
						route: unit.route,
					};
					
					// Move unit
					//unit.q = toQ;
					//unit.r = toR;
					//unit.hasMoved = 1;
					updates.push({ type: ACTION.unit_moved, unitId: unit.id, q: toQ, r: toR, hasMoved: 1 });
					
					sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
					
				}else{

					let actionPool = findSelectedPool(poolHex, findEconomyPools(playerIndex), playerIndex);

					const fromQ = unit.q;
					const fromR = unit.r;
					const toTile = getTileAt(toQ, toR);
					const oldOwnerIndex = toTile.ownerIndex;
					const oldObject = toTile.object;
					const oldSavings = toTile.savings;
					
					let hexClaimed = false;
					let didClaimEnemy = (oldOwnerIndex !== -1 && oldOwnerIndex !== playerIndex);
					
					actionForUndo = {
						type: 'move',
						unitId: unit.id,
						fromQ, 
						fromR,
						toQ, 
						toR,
						didClaim: oldOwnerIndex !== playerIndex,
						oldSavings: oldSavings,
						oldOwnerIndex: oldOwnerIndex,
						clearedObject: oldObject,
						poolHex: poolHex,
					};
					
					let killMovedUnit = false;
					
					// add all tile changes into this, so only one tile_changed update is needed:
					let tileChangedUpdates = [];
					
					
					if (moveCheck.action === 'attack') {
						const targetUnit = moveCheck.target;
						actionForUndo.killedUnit = { ...targetUnit }; // Store copy
						//gameState.units = gameState.units.filter(u => u.id !== targetUnit.id);
						updates.push({ type: ACTION.unit_removed, unitId: targetUnit.id });
						if(!isAiPlayer(playerIndex)){
							if(targetUnit.internalType === 'castle'){ // CASTLE_DATA[targetUnit.type]
								sounds.push({name:'killCastle', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
							}else{
								sounds.push({name:'kill', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
							}
						}
						
						//console.warn("moveCheck.action === 'attack'");
					}
					
					//console.warn("actionForUndo1");
					//console.warn(actionForUndo);
					
					// Move unit
					
					unit.q = toQ;
					unit.r = toR;
					unit.hasMoved = 1;
					updates.push({ type: ACTION.unit_moved, unitId: unit.id, q: toQ, r: toR, pq: pq, pr: pr, hasMoved: 1 });
					
					let allowHexClaim = true;
					
					
					// Claim hex
					if (toTile.ownerIndex !== playerIndex) {
						//setTileOwnerByIndex(toTile, playerIndex);
						//toTile.savings = 0; // update host data.

						
						//tileChangedUpdates.push({ type: ACTION.tile_changed, q: toQ, r: toR, ownerIndex: playerIndex });
						hexClaimed = true;
						
						if(!isAiPlayer(playerIndex)){
							if (!toTile.object) {
								if(!actionForUndo.killedUnit){
									sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
								}
							}
						}
					}else{
						// if moved inside own pool, play also sound.
						if(!isAiPlayer(playerIndex)){
							if (!toTile.object) {
								if(!actionForUndo.killedUnit){
									sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
								}
							}
						}
					}
					
					if (toTile.object) {

		
						if(toTile.object === 'tree'){
							sounds.push({name:'claimTree', q: toQ, r: toR, action: action.type});
						}else if(toTile.object === 'grass'){
							sounds.push({name:'claimGrass', q: toQ, r: toR, action: action.type});
						}else if(toTile.object === 'rock2'){
							sounds.push({name:'claimRock', q: toQ, r: toR, action: action.type});
						}else if(toTile.object === 'mine1'){
							sounds.push({name:'claimMine', q: toQ, r: toR, action: action.type});
							killMovedUnit = true;
							allowHexClaim = false;
						}else if(toTile.object === 'landmine'){
							// only explode if its not your mine:
							if(!isTileMinePlayerMine(toTile, playerIndex)){
								sounds.push({name:'claimMine', q: toQ, r: toR, action: action.type});
								killMovedUnit = true;
								allowHexClaim = false;
							}else{
								if(!actionForUndo.killedUnit){
									sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
								}
							}
						}else{
							if(!actionForUndo.killedUnit){
								sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
							}
						}

						// add tree claiming money:
						let moneyAdded = 0;
						if(toTile.object === 'tree'){
							moneyAdded = 1;
						}else if(toTile.object === 'rock2'){
							moneyAdded = 5;
						}
						
						// handle mines:
						//if(toTile.object === 'mine1'){
							//killMovedUnit = true;

							/*
							toTile.object = 'dead'; // Turn to dead (crosses)
							toTile.actionTurnNumber = gameState.turn.turnNumber;
							
							// add animation info for host:
							toTile.creationTime = msNowFloor(); 
							toTile.animationFinished = 0; // ensure no animation will be visible.
							toTile.animationStyle = 1; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
							
							updates.push({ 
								type: ACTION.object_changed, 
								q: toQ, 
								r: toR, 
								object: toTile.object,
								animationStyle: toTile.animationStyle,
							});
							*/
						//}
						
						if(moneyAdded){
							addCost(actionPool, moneyAdded, poolHex, action.type);
						}
						
						toTile.object = null;

						tileChangedUpdates.push({ type: ACTION.tile_changed, q: toQ, r: toR, object: null, FText: moneyAdded });
					}
					
					if(hexClaimed && allowHexClaim){
						tileChangedUpdates.push({ type: ACTION.tile_changed, q: toQ, r: toR, ownerIndex: playerIndex });
					}
					
					if(killMovedUnit){
						actionForUndo.killedUnit = unitCopy; // Store copy
						updates.push({ type: ACTION.unit_removed, unitId: unitCopy.id });
						
						// clear undo stack when unit died by move:
						preventUndo();
					}
					
					
					// push to updates all tile_changed updates that were merged into one:
					pushMergedUpdates(updates, tileChangedUpdates);
					
					
					// action_move:
					// if claimed an enemy tile, check if anyone dies:
					if(hexClaimed && oldOwnerIndex !== -1){ // nobody can die if claimed non-owned land.
						//checkPlayers.push(oldOwnerIndex);
						
						// old owner = oldOwnerIndex
						let pools = findEconomyPools(oldOwnerIndex);
						let killdata = calculateBalanceAndKillSoldiers(pools);
						
						if(killdata.batchActions && killdata.batchActions.length > 0){
							let batchActions = killdata.batchActions;
							//let poolsAfter = killdata.poolsAfter;
							//let poolsBefore = killdata.poolsBefore;
							//actionForUndo.batchActions = batchActions;
							//actionForUndo.poolsBefore = poolsBefore;
							updates.push(...batchActions);
							
							sounds.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_move});
						}
						// put batchActions into undo history with the current actionForUndo,
						// maybe add new key for it like actionForUndo.poolActions = batchActions ?
						// and then put those batchActions into updates so they will be sent to all players?
						// for undo it has to remember the pool before changing it, so when undoing, it has to revert back to
						// savings before soldiers died (and make soldiers alive again and remove the 'dead' object).
						
						// clear undo stack when units died by pool splitting:
						preventUndo();
					}
					
					
					// dont allow undo if claiming enemy tile:
					if(didClaimEnemy){
						preventUndo();
					}
					
					
				}
			}
			break;
		}
		case ACTION.action_unload_unit: {
			if(gameState.settings.gameOver) return;
			
			console.warn("executeAction action_unload_unit");
			console.warn(action);
			
			const { unitId, toQ, toR } = action;
			
			let unit = getUnitById(unitId);
			let loadedUnit = unit.loadedUnit;
			
			let tile = getTileAt(toQ, toR);
			
			if(getTileType(tile) === 'land'){
				
				let poolHex = {q: tile.q, r: tile.r};
				
				// double check move validity:
				const moveCheck = isMoveValid(unit, { q: toQ, r: toR }, player);
				console.warn("unload_unit moveCheck");
				console.warn(moveCheck);
				
				if(moveCheck.valid){
					// todo: test these later:
					// moveCheck.action === 'unload_unit_attack'
					// moveCheck.action === 'unload_unit'
			
					const oldOwnerIndex = tile.ownerIndex;
					const oldObject = tile.object;
					const oldSavings = tile.savings;
					
					let tileChangedUpdates = [];
					
					actionForUndo = {
						type: 'unload_unit', 
						unit: unit, // the unit that unloads an unit.
						loadedUnit: loadedUnit, // the unit to be unloaded.
						didClaim: tile.ownerIndex !== playerIndex,
						oldSavings: oldSavings,
						oldOwnerIndex: oldOwnerIndex,
						clearedObject: oldObject,
						poolHex: poolHex,
						
						actionPlayerIndex: playerIndex, // who did this action, used for starvation undoing only.
					};
					
					let newUnit = loadedUnit;
					newUnit.id = newUnitID();
					newUnit.q = toQ;
					newUnit.r = toR;
					newUnit.hasMoved = false;
					
					let unitCopy = {...newUnit}; // used for mines killing.
					

					
					let playMoveUnit = true;
					let didClaimEnemy = false;
					let killAddedUnit = false;
					
					// if claimed a tile:
					if (tile.ownerIndex !== playerIndex) {
						if(tile.ownerIndex !== -1){
							didClaimEnemy = true;
						}
						setTileOwnerByIndex(tile, playerIndex);
						tile.savings = 0; // update to host data.
						
						tileChangedUpdates.push({ type: ACTION.tile_changed, q: toQ, r: toR, ownerIndex: playerIndex });
					}
					

					// check if the unloaded unit killed some other unit:
					if (moveCheck.action === 'unload_unit_attack') {
						const targetUnit = moveCheck.target;
						actionForUndo.killedUnit = { ...targetUnit }; // Store copy
						//gameState.units = gameState.units.filter(u => u.id !== targetUnit.id);
						updates.push({ type: ACTION.unit_removed, unitId: targetUnit.id });
						
						if(!isAiPlayer(playerIndex)){
							if(targetUnit.internalType === 'castle'){
								sounds.push({name:'killCastle', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
							}else{
								sounds.push({name:'kill', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
							}
							playMoveUnit = false;
						}
					}
					
					// if claimed object:
					if (tile.object) {
						
						
					/*
						if(tile.object === 'tree'){
							sounds.push({name:'claimTree', q: toQ, r: toR, action: action.type});
						}else if(tile.object === 'grass'){
							sounds.push({name:'claimGrass', q: toQ, r: toR, action: action.type});
						}else if(tile.object === 'rock2'){
							sounds.push({name:'claimRock', q: toQ, r: toR, action: action.type});
						}else if(tile.object === 'mine1'){
							sounds.push({name:'claimMine', q: toQ, r: toR, action: action.type});
						}else{
							playMoveUnit = true;
						}
						*/

						if(tile.object === 'tree'){
							sounds.push({name:'claimTree', q: toQ, r: toR, action: action.type});
						}else if(tile.object === 'grass'){
							sounds.push({name:'claimGrass', q: toQ, r: toR, action: action.type});
						}else if(tile.object === 'rock2'){
							sounds.push({name:'claimRock', q: toQ, r: toR, action: action.type});
						}else if(tile.object === 'mine1'){
							sounds.push({name:'claimMine', q: toQ, r: toR, action: action.type});
							killAddedUnit = true;
						}else if(tile.object === 'landmine'){
							// only explode if its not your mine:
							if(!isTileMinePlayerMine(tile, playerIndex)){
								sounds.push({name:'claimMine', q: toQ, r: toR, action: action.type});
								killAddedUnit = true;
							}else{
								// if not killed unit, just play move sound? not sure about this logic.
								if(!actionForUndo.killedUnit){
									sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
								}
							}
						}else{
							if(!actionForUndo.killedUnit){
								sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
							}
						}
				
						// add tree claiming money:
						let moneyAdded = 0;
						if(tile.object === 'tree'){
							moneyAdded = 1;
						}else if(tile.object === 'rock2'){
							moneyAdded = 5;
						}
						
						// handle mines:
						//if(tile.object === 'mine1'){
						//	killAddedUnit = true;
						//}
						if(moneyAdded){
							// todo: find player pools first.
							let actionPool = findSelectedPool(poolHex, findEconomyPools(playerIndex), playerIndex);
							addCost(actionPool, moneyAdded, poolHex, action.type);
						}
						
						actionForUndo.clearedObject = tile.object;
						tile.object = null;

						tileChangedUpdates.push({ type: ACTION.tile_changed, q: toQ, r: toR, object: null, FText: moneyAdded });
					}
					
					
					
					//let addedUnitWasKilled = false;
					//actionForUndo.addedUnitWasKilled = addedUnitWasKilled;
					
					updates.push({ type: ACTION.unit_added, unit: newUnit });
					
					// send unload message to delete the load and set hasMoved to true:
					updates.push({ type: ACTION.unit_unloaded, unitId: unitId });
					//updates.push({ type: ACTION.unit_move_reset, hasMoved: true, unitId: targetUnitId});
					
					
					if(killAddedUnit){
						// dont add killed unit or it will create that unit after undo...
						updates.push({ type: ACTION.unit_removed, unitId: unitCopy.id });
						
						// clear undo stack when unit died by move:
						preventUndo();
					}
					
	
					if(playMoveUnit){
						sounds.push({name:'moveunit', q: toQ, r: toR, action: action.type});
					}
					
					// push to updates all tile_changed updates that were merged into one:
					pushMergedUpdates(updates, tileChangedUpdates);
					
					// todo: for now prevent undo until the unload boat undo is fixe:
					preventUndo();
				}
			}
			
		}
		break;
		case ACTION.action_edit_tile: {
			if(gameState.settings.gameOver) return;
			
			console.warn("action_edit_tile");
			if(!player.isSpectator){
				updates.push({ type: ACTION.tile_edited, hex: action.hex, tileType: action.tileType, playerIndex: playerIndex});
			}
		}
		break;
		case ACTION.action_load_unit: {
			if(gameState.settings.gameOver) return;
			
			console.warn("executeAction action_load_unit");
			console.warn(action);
			
			const { unitId, targetUnitId, poolHex } = action;
			
			let unit = getUnitById(unitId);
			let targetUnit = getUnitById(targetUnitId);
			
			if(!targetUnit.loadedUnit){
				
				actionForUndo = {
					type: 'load_unit', 
					poolHex: poolHex,
					unit: unit, // the unit to be loaded into boat.
					targetUnit: targetUnit, // the boat being loaded.
					actionPlayerIndex: playerIndex, // who did this action, used for starvation undoing only.
				};
				
				updates.push({ type: ACTION.unit_loaded, unitId: unitId, targetUnitId: targetUnitId});
				
				updates.push({ type: ACTION.unit_removed, unitId: unitId });
				//updates.push({ type: ACTION.unit_move_reset, hasMoved: true, unitId: targetUnitId});
				
				sounds.push({name:'moveunit', q: unit.q, r: unit.r, action: action.type});
			}
			
		}
		break;
		case ACTION.action_build_object: {
			if(gameState.settings.gameOver) return;
			
			console.warn("executeAction action_build_object");
			console.warn(action);

			console.warn(player);
			console.warn(playerIndex);
			// unitType actually the object name in tile.object. using the other_units unit.name for the tile.object here.
			const { unitType, q, r, poolHex, unitId } = action;
			
			let hex = {q, r};
			
			// prevent using disabled units:
			if(!gameState.settings.useLandmines && isTypeMine(unitType)){
				console.warn("mines disabled");
				return;
			}
			// must have mines to build:
			if(player.totalMines < 1){
				console.warn("not enough mines");
				return;
			}
			
			
			let unit = getUnitById(unitId);
			if(!unit){
				console.warn("selected unit not found");
				return;
			}
			
			console.log("poolHex");
			console.log(poolHex); // from which pool
			console.log("q, r");
			console.log(q, r); // to which hex
			
			if(!isUnitTypeObject(unitType)){
				console.warn("action_build_object: not an object: "+unitType);
				return;
			}
			
			const data = getUnitInfo(unitType);//SOLDIER_DATA[unitType] || CASTLE_DATA[unitType];
			if (!data) return;
			
			
			
			let actionPool = findSelectedPool(poolHex, findEconomyPools(playerIndex), playerIndex);

			const buildCheck = isPlacementValid(unitType, hex, player, poolHex, true, unit);

			if (buildCheck.valid) {
				let totalSavings = actionPool.totalSavings;
				
				if (canAffordCheck(totalSavings, data.cost)) {
					
					if(getUnitType(unitType) === "mine"){
						console.warn("mine DETECTED");
						
						const tile = getTileAt(q, r);
						
						if(tile){
							
							deductCost(actionPool, data.cost, poolHex, action.type);
							
							//let unit = getUnitById(unitId);
							
							let addedObjectOwnerIndex = playerIndex;
							// tile.objectOwnerIndexes has list of current object owner indexes.
							
							actionForUndo = {
								type: 'build_object', 
								poolHex: poolHex,
								cost: data.cost,
								hex: hex,
								unitId: unitId, // the builder unit id.
								oldObject: tile.object, // if you undo, you must keep the old object and not clear it.
								addedObjectOwnerIndex: addedObjectOwnerIndex,
								actionPlayerIndex: playerIndex, // who did this action, used for starvation undoing only.
							};
							
							// clear already existing object if any (mainly enemy mines, silently replace them).
							// not sure if they should just explode instead, or become visible.
							// if explodes, its too easy to just check if any tiles have mines, could just undo and place new mine...
							// or just silently not replace it at all, so the original owner still sees his mine there.
							// or not... if you place a mine and you wont see it because there already was a mine, then it feels bugged.
							// maybe could make the owners into array, so the mine can have multiple owners...
							// so if i place mine on enemy mine that i dont see, then we both see the mine there.
							// i think thats the best, so a list of owners should be there...
							
							// so...
							// if there already is a mine, just add your playerIndex to array.
							// if you undo, remove your playerIndex from the array.
							//if (tile.object) {
							//	actionForUndo.clearedObject = tile.object;
							//	tile.object = unitType; // not sure if this is necessary here.
							//}
						
							updates.push({ type: ACTION.unit_move_reset, hasMoved: true, unitId: unitId});
							
							// decrease mines count:
							updates.push({
								type: ACTION.player_changed, 
								playerIndex: playerIndex, 
								totalMines: player.totalMines-1, // guaranteed to be >=1 here.
							});
							
							updates.push({ type: ACTION.tile_changed, q: q, r: r, object: unitType, addedObjectOwnerIndex: addedObjectOwnerIndex });
							
							sounds.push({name:'moveunit', q: q, r: r, action: action.type});
						}else{
							console.warn("tile does not exist for ", unitType);
						}
					}
				}
			}
		}
		break;
		case ACTION.action_build: {
			if(gameState.settings.gameOver) return;
			// build unit
			
			
			//console.log("executeAction action_build");
			
			const { unitType, q, r, poolHex, unitId } = action;
			
			let unit = getUnitById(unitId);
			
			// prevent using disabled units:
			if(!gameState.settings.useBoats && isTypeBoat(unitType)){
				return;
			}
			
			if(isTypeBoat(unitType)){
				// must have mines to build:
				if(player.totalBoats < 1){
					console.warn("not enough boats");
					return;
				}
				if(!unit){
					console.warn("selected unit not found");
					return;
				}
			}
			
			
			console.log("poolHex");
			console.log(poolHex); // from which pool
			console.log("q, r");
			console.log(q, r); // to which hex
			
			const data = getUnitInfo(unitType);//SOLDIER_DATA[unitType] || CASTLE_DATA[unitType];
			if (!data) return;
			
			let actionPool = findSelectedPool(poolHex, findEconomyPools(playerIndex), playerIndex);

			

			const buildCheck = isPlacementValid(unitType, {q, r}, player, poolHex, true, unit);

			if (buildCheck.valid) {

				let totalSavings = actionPool.totalSavings;
				
				
				if (canAffordCheck(totalSavings, data.cost)) {
					
					deductCost(actionPool, data.cost, poolHex, action.type);
					
					if(isTypeBoat(unitType)){
						console.warn("BOAT DETECTED");
						
						const newUnit = {
							id: newUnitID(),
							ownerIndex: playerIndex,
							q: q, 
							r: r,
							type: unitType,
							level: data.level,
							hasMoved: 1,
							internalType: data.type,
						};
						
						actionForUndo = {
							type: 'build', 
							unit: newUnit, 
							cost: data.cost, 
							didClaim: false, 
							poolHex: poolHex,
							unitId: unitId, // the builder unit id.
							actionPlayerIndex: playerIndex, // who did this action, used for starvation undoing only.
						};
						
						updates.push({ type: ACTION.unit_move_reset, hasMoved: true, unitId: unitId});
						
						// decrease boats count:
						updates.push({
							type: ACTION.player_changed, 
							playerIndex: playerIndex, 
							totalBoats: player.totalBoats-1, // guaranteed to be >=1 here.
						});
						updates.push({ type: ACTION.unit_added, unit: newUnit });
						
						sounds.push({name:'moveunit', q: q, r: r, action: action.type});
						
					}else{
						const tile = getTileAt(q, r);
						const oldOwnerIndex = tile.ownerIndex;
						const oldObject = tile.object;
						const oldSavings = tile.savings;
						
						const newUnit = {
							id: newUnitID(),
							ownerIndex: playerIndex,
							oldOwnerIndex: oldOwnerIndex,
							q: q, 
							r: r,
							type: unitType,
							level: data.level,
							hasMoved: 1,
							internalType: data.type,
						};
						let unitCopy = {...newUnit}; // used for mines killing.
						
						let killAddedUnit = false;
						
						//console.log("action_build: gameState.units.push(newUnit);");
						//console.log(newUnit);
						
						let tileChangedUpdates = [];
						
						//gameState.units.push(newUnit); // if used here then host gets the unit double!
						
						let didClaim = false;
						let didClaimEnemy = false;
						let allowHexClaim = true;
						
						let playMoveUnit = false;
						
						// 'moveunit' sound type, castlebuild or just moveunit:
						let moveUnitType = 0; // 0 = move, 1 = build
						if(isCastle(newUnit)){
							moveUnitType = 1;
						}
						
						if (isSoldier(newUnit) && tile.ownerIndex !== playerIndex) {
							didClaim = true;
							if(tile.ownerIndex !== -1){
								didClaimEnemy = true;
							}
							//setTileOwnerByIndex(tile, playerIndex);
							//tile.savings = 0; // update to host data.
							
							
							//tileChangedUpdates.push({ type: ACTION.tile_changed, q: q, r: r, ownerIndex: playerIndex });
							
							if(!isAiPlayer(playerIndex)){
								if (!tile.object) {
									playMoveUnit = true;
									//sounds.push({name:'moveunit', q: q, r: r, action: action.type});
								}
							}
						}else{
							if(!isAiPlayer(playerIndex)){
								if (!tile.object) {
									playMoveUnit = true;
									//sounds.push({name:'moveunit', q: q, r: r, action: action.type});
								}
							}
						}
						
						actionForUndo = {
							type: 'build', 
							unit: newUnit, 
							cost: data.cost, 
							didClaim: didClaim, 
							oldSavings: oldSavings,
							oldOwnerIndex: oldOwnerIndex,
							clearedObject: null,
							poolHex: poolHex,
							actionPlayerIndex: playerIndex, // who did this action, used for starvation undoing only.
						};
						
						
						actionForUndo.clearedObject = null;
						
						
						if (tile.object) {
							
							playMoveUnit = true;
							
							//if(moveUnitType == 0){
								if(tile.object === 'tree'){
									sounds.push({name:'claimTree', q: q, r: r, action: action.type});
								}else if(tile.object === 'grass'){
									sounds.push({name:'claimGrass', q: q, r: r, action: action.type});
								}else if(tile.object === 'rock2'){
									sounds.push({name:'claimRock', q: q, r: r, action: action.type});
								}else if(tile.object === 'mine1'){
									sounds.push({name:'claimMine', q: q, r: r, action: action.type});
									killAddedUnit = true;
									allowHexClaim = false;
								}else if(tile.object === 'landmine'){
									// only explode if its not your mine:
									if(!isTileMinePlayerMine(tile, playerIndex)){
										sounds.push({name:'claimMine', q: q, r: r, action: action.type});
										killAddedUnit = true;
										allowHexClaim = false;
									}else{
										// if not killed unit, just play move sound? not sure about this logic.
										if(!actionForUndo.killedUnit){
											sounds.push({name:'moveunit', q: q, r: r, action: action.type});
										}
									}
								}else{
									if(!actionForUndo.killedUnit){
										sounds.push({name:'moveunit', q: q, r: r, action: action.type});
									}
									//playMoveUnit = true;
								}
							//}else{
							//	playMoveUnit = true;
							//}
							
							/*
							if(moveUnitType == 0){
								if(tile.object === 'tree'){
									sounds.push({name:'claimTree', q: q, r: r, action: action.type});
								}else if(tile.object === 'grass'){
									sounds.push({name:'claimGrass', q: q, r: r, action: action.type});
								}else if(tile.object === 'rock2'){
									sounds.push({name:'claimRock', q: q, r: r, action: action.type});
								}else if(tile.object === 'mine1'){
									sounds.push({name:'claimMine', q: q, r: r, action: action.type});
								}else{
									playMoveUnit = true;
									//sounds.push({name:'moveunit', q: q, r: r, action: action.type});
								}
							}else{
								playMoveUnit = true;
							}
							*/
						
							

							// add tree claiming money:
							let moneyAdded = 0;
							if(tile.object === 'tree'){
								moneyAdded = 1;
							}else if(tile.object === 'rock2'){
								moneyAdded = 5;
							}
							
							// handle mines:
							//if(tile.object === 'mine1'){
								////actionForUndo.killedUnit = unitCopy; // Store copy
								////updates.push({ type: ACTION.unit_removed, unitId: unitCopy.id });
								
								//killAddedUnit = true;
							//}
							if(moneyAdded){
								addCost(actionPool, moneyAdded, poolHex, action.type);
							}
							
							actionForUndo.clearedObject = tile.object;
							tile.object = null;

							tileChangedUpdates.push({ type: ACTION.tile_changed, q: q, r: r, object: null, FText: moneyAdded });
						}
						/*
						actionForUndo = {
							type: 'build', 
							unit: newUnit, 
							cost: data.cost, 
							didClaim: didClaim, 
							oldSavings: oldSavings,
							oldOwnerIndex: oldOwnerIndex,
							clearedObject: clearedObject,
							poolHex: poolHex,
							actionPlayerIndex: playerIndex, // who did this action, used for starvation undoing only.
						};
						*/

						if(didClaim && allowHexClaim){
							tileChangedUpdates.push({ type: ACTION.tile_changed, q: q, r: r, ownerIndex: playerIndex });
						}
						
						if (buildCheck.action === 'attack') {
							const targetUnit = buildCheck.target;
							actionForUndo.killedUnit = { ...targetUnit }; // Store copy
							//gameState.units = gameState.units.filter(u => u.id !== targetUnit.id);
							updates.push({ type: ACTION.unit_removed, unitId: targetUnit.id });
							
							if(!isAiPlayer(playerIndex)){
								if(targetUnit.internalType === 'castle'){ // CASTLE_DATA[targetUnit.type]
									sounds.push({name:'killCastle', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
								}else{
									sounds.push({name:'kill', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
								}
								playMoveUnit = false;
							}
						}
						
						if(playMoveUnit){
							if(moveUnitType){
								sounds.push({name:'build'+newUnit.level, q: q, r: r, action: action.type});
							}else{
								sounds.push({name:'moveunit', q: q, r: r, action: action.type});
							}
						}
							
						
						console.warn("actionForUndo");
						console.warn(actionForUndo);
						
						// if batchActions kills your unit, should just add the cross instead?
						// calculateBalanceAndKillSoldiers doesnt take into account the new unit wages...
						// ...most probably. so it should be taken as parameter to
						// calculateBalanceAndKillSoldiers() ?
						//updates.push({ type: ACTION.unit_added, unit: newUnit });
						
						
						let addedUnitWasKilled = false;
						
						
						
						// action_build:
						// if claimed enemy tile, check if any enemy dies:
						// Note: must check for attacking player pools too.
						if(didClaimEnemy){ // (not non-owned tile.)
							// check if the enemy tile owner will die.
							//checkPlayers.push(oldOwnerIndex);
							
							// check enemy pools:
							// old owner = oldOwnerIndex
							let pools = findEconomyPools(oldOwnerIndex);
							let killdata = calculateBalanceAndKillSoldiers(pools);
							
							if(killdata.batchActions && killdata.batchActions.length > 0){
								
								console.warn("pool units were killed due to starvation");
								
								let batchActions = killdata.batchActions;
								//let poolsAfter = killdata.poolsAfter;
								//let poolsBefore = killdata.poolsBefore;
								//actionForUndo.batchActions = batchActions;
								//actionForUndo.poolsBefore = poolsBefore;
								updates.push(...batchActions);
								
								sounds.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_move});
								
								preventUndo();
							}
							// put batchActions into undo history with the current actionForUndo,
							// maybe add new key for it like actionForUndo.poolActions = batchActions ?
							// and then put those batchActions into updates so they will be sent to all players?
							// for undo it has to remember the pool before changing it, so when undoing, it has to revert back to
							// savings before soldiers died (and make soldiers alive again and remove the 'dead' object).
						}
						let killedByStarvation = false;
						
						if(isSoldier(newUnit)){
							// if placed soldier, check if that owner will die even if not claimed any hex.
							//checkPlayers.push(playerIndex);
							
							// if placed soldier, check if your soldiers will die:
							let pools = findEconomyPools(playerIndex);
							let killdata = calculateBalanceAndKillSoldiers(pools);
							
							console.warn("check if added unit was killed:");
							console.warn(killdata);
							
							if(killdata.batchActions && killdata.batchActions.length > 0){
								let batchActions = killdata.batchActions;
								
								console.warn("added unit was killed due to starvation");
								//addedUnitWasKilled = true;
								killAddedUnit = true;
								killedByStarvation = true;
								
								

								
								// add silent kill explosion:
								//sounds.push({name: 'silentDiedByStarving', q: q, r: r, action: action.type});
								
								
								//let poolsAfter = killdata.poolsAfter;
								//let poolsBefore = killdata.poolsBefore;
								
								//if(!actionForUndo.batchActions){
								//	actionForUndo.batchActions = [];
								//}
								//actionForUndo.batchActions.push(...batchActions);

								////updates.push({ type: ACTION.unit_added, unit: newUnit });
								
								//actionForUndo.poolsBefore = poolsBefore;
								updates.push(...batchActions);
								
								sounds.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_move});
								
								
								preventUndo();
							}
						}
					
						
						// TODO... fix this: the newly built unit doesnt die with the others:
						// for undo it must know to give back the undo money.
						// now when my units dies, this new unit stays alive.
						//actionForUndo.addedUnitWasKilled = addedUnitWasKilled;
						
						updates.push({ type: ACTION.unit_added, unit: newUnit });
						
						if(killAddedUnit){
							// dont add killed unit or it will create that unit after undo...
							//actionForUndo.killedUnit = { ...unitCopy };
							if(killedByStarvation){
								
								// add cross & blood at same object_change process:
								updates.push({ 
									type: ACTION.object_changed, 
									q: newUnit.q, 
									r: newUnit.r, 
									object: 'dead',
									animationStyle: 1,
								});
								
								
								updates.push({ type: ACTION.unit_removed, unitId: unitCopy.id });
							}else{
								updates.push({ type: ACTION.unit_removed, unitId: unitCopy.id });
							}
							
							// clear undo stack when unit died by move:
							preventUndo();
						}
						
						
						/*
						if(!addedUnitWasKilled){
							updates.push({ type: ACTION.unit_added, unit: newUnit });
						}else{

							// TODO: think how to fix this unit add/remove...
							//actionForUndo.unit = null; // dont tell we added unit since we didnt.
							
							// kill also the added unit:
							tile.object = 'dead'; // Turn to dead (crosses)
							tile.actionTurnNumber = gameState.turn.turnNumber;
							
							// add animation info for host:
							tile.creationTime = msNowFloor(); 
							tile.animationFinished = 0; // ensure no animation will be visible.
							tile.animationStyle = 1; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
							
							// just add the cross object:
							// TODO: make this into the actionForUndo instead...?
							tileChangedUpdates.push({ 
								type: ACTION.object_changed, 
								q: tile.q, 
								r: tile.r, 
								object: tile.object,
								animationStyle: tile.animationStyle,
							});
							
							
							//tileChangedUpdates.push({ type: ACTION.tile_changed, q: toQ, r: toR, object: tile.object });
							
						}
						*/
						
						
						// push to updates all tile_changed updates that were merged into one:
						pushMergedUpdates(updates, tileChangedUpdates);
						
						
						// dont allow undo if claiming enemy tile:
						if(didClaimEnemy){
							preventUndo();
						}
					}
				}
			}else{
				console.error("buildCheck failed:");
				console.error(buildCheck);
			}

			
			break;
		}
		
		case ACTION.action_undo: {
			if(gameState.settings.gameOver) return;
			// undo move
			
			//console.log("executeAction action_undo");
			
			const lastAction = currentTurnActions.pop();
			

			// if there was no undo left, break:
			if (!lastAction){
				break;
			}
			
			let poolHex = lastAction.poolHex;
			console.log("poolHex");
			console.log(poolHex);
			
			console.log("lastAction:");
			console.log(lastAction);
			
			console.log("playerId:");
			console.log(playerId);
			
			let actionPool = findSelectedPool(poolHex, findEconomyPools(playerIndex), playerIndex);


			let tileChangedUpdates = [];
			
			let unitActionHex = null; // used for sounds coords only.
			
			if (lastAction.type === 'move') {
				const unit = gameState.units.find(u => u.id === lastAction.unitId);
				if (unit) {
					unit.q = lastAction.fromQ;
					unit.r = lastAction.fromR;
					unit.hasMoved = 0;
					let route = lastAction.route ?? undefined;
					updates.push({ type: ACTION.unit_moved, unitId: unit.id, q: unit.q, r: unit.r, hasMoved: 0, wasUndo: 1, route: route });
					
					unitActionHex = {q: unit.q, r: unit.r};
				}
				if (lastAction.didClaim) {
					const tile = getTileAt(lastAction.toQ, lastAction.toR);
					if (tile) {
						setTileOwnerByIndex(tile, lastAction.oldOwnerIndex);
						tile.savings = lastAction.oldSavings; // update host data.
						tileChangedUpdates.push({ type: ACTION.tile_changed, q: lastAction.toQ, r: lastAction.toR, ownerIndex: tile.ownerIndex });
					}
				}
				if (lastAction.clearedObject) {
					const tile = getTileAt(lastAction.toQ, lastAction.toR);
					if (tile) {
						// undo tree claiming money:
						let moneyAdded = 0;
						if(lastAction.clearedObject === 'tree'){
							moneyAdded = 1;
						}else if(lastAction.clearedObject === 'rock2'){
							moneyAdded = 5;
						}
						if(moneyAdded){
							deductCost(actionPool, moneyAdded, poolHex, action.type);
						}
						
						tile.object = lastAction.clearedObject;

						tileChangedUpdates.push({ type: ACTION.tile_changed, q: lastAction.toQ, r: lastAction.toR, object: tile.object });
						
					}
				}
				if (lastAction.killedUnit) {
					//gameState.units.push(lastAction.killedUnit);
					//addUnit(lastAction.killedUnit);
					updates.push({ type: ACTION.unit_added, unit: lastAction.killedUnit });
					unitActionHex = {q: lastAction.killedUnit.q, r: lastAction.killedUnit.r};
				}
				
				
	
				//////////////////////////////////
				// rollback the multiple actions that were generated for died soldiers by starvation:
				if(lastAction.batchActions){
					for(let i = 0; i < lastAction.batchActions.length; i++){
						let batchAction = lastAction.batchActions[i];
						
						if(batchAction.type === ACTION.object_changed){
							// remove object (cross):
							updates.push({
								type: ACTION.object_changed, 
								q: batchAction.q, 
								r: batchAction.r, 
								object: null,
							});
						}else if(batchAction.type === ACTION.unit_removed){
							// add removed unit back:
							batchAction.unit.wasSpawned = 0; // so the animations will work normally.
							updates.push({
								type: ACTION.unit_added, 
								unit: batchAction.unit, 
							});
						}
						
						// updates.push({ type: ACTION.unit_added, unit: lastAction.killedUnit });
					}
				}
				
				/*
				tile.object = 'dead'; // Turn to dead (crosses)
				tile.actionTurnNumber = gameState.turn.turnNumber;
				
				// add animation info for host:
				tile.creationTime = msNowFloor(); 
				tile.animationFinished = 0; // ensure no animation will be visible.
				tile.animationStyle = 1; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
				
				batchActions.push({ 
					type: ACTION.object_changed, 
					q: soldier.q, 
					r: soldier.r, 
					object: tile.object,
					animationStyle: tile.animationStyle,
				});
				batchActions.push({ 
					type: ACTION.unit_removed, 
					unitId: soldier.id,
					unit: soldier,
				});
				
				let pools = findEconomyPools(oldOwnerIndex);
				let killdata = calculateBalanceAndKillSoldiers(pools);
				
				let batchActions = killdata.batchActions;
				let poolsAfter = killdata.poolsAfter;
				let poolsBefore = killdata.poolsBefore;
				actionForUndo.batchActions = batchActions;
				actionForUndo.poolsBefore = poolsBefore;
				updates.push(...batchActions);
				*/
			

				
				
			} else if (lastAction.type === 'build') {
				//if(!lastAction.addedUnitWasKilled){
					updates.push({ type: ACTION.unit_removed, unitId: lastAction.unit.id });
					unitActionHex = {q: lastAction.unit.q, r: lastAction.unit.r};
				//}
				
	
				console.log("addCost to actionPool, cost = "+lastAction.cost);
				console.log(actionPool);

				addCost(actionPool, lastAction.cost, poolHex, action.type);
				
				// handle boats add undo:
				if(isTypeBoat(lastAction.unitType)){
					// give back boats count:
					updates.push({
						type: ACTION.player_changed, 
						playerIndex: playerIndex, 
						totalBoats: player.totalBoats+1, // guaranteed to be >=1 here.
					});
				}
				
				if (lastAction.didClaim) {
					const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
					if (tile) {
						setTileOwnerByIndex(tile, lastAction.oldOwnerIndex);
						tile.savings = lastAction.oldSavings; // update host data.
						tileChangedUpdates.push({type: ACTION.tile_changed, q: lastAction.unit.q, r: lastAction.unit.r, ownerIndex: tile.ownerIndex });
						
					}
				}
				if (lastAction.killedUnit) {
					//gameState.units.push(lastAction.killedUnit);
					//addUnit(lastAction.killedUnit);
					updates.push({ type: ACTION.unit_added, unit: lastAction.killedUnit });
					unitActionHex = {q: lastAction.killedUnit.q, r: lastAction.killedUnit.r};
				}
				
				if (lastAction.clearedObject) {
					const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
					if (tile) {
						// undo tree claiming money:
						let moneyAdded = 0;
						if(lastAction.clearedObject === 'tree'){
							moneyAdded = 1;
						}else if(lastAction.clearedObject === 'rock2'){
							moneyAdded = 5;
						}
						if(moneyAdded){
							deductCost(actionPool, moneyAdded, poolHex, action.type);
						}
						
						tile.object = lastAction.clearedObject;

						tileChangedUpdates.push({ type: ACTION.tile_changed, q: lastAction.unit.q, r: lastAction.unit.r, object: tile.object });
					}
				}else{
					/*
					if(lastAction.addedUnitWasKilled){
						const tile = getTileAt(lastAction.unit.q, lastAction.unit.r);
						if (tile) {
							tile.object = null;

							tileChangedUpdates.push({ type: ACTION.tile_changed, q: lastAction.unit.q, r: lastAction.unit.r, object: tile.object });
						}
					}
					*/
				}
				

				//////////////////////////////////
				// rollback the multiple actions that were generated for died soldiers by starvation:
				if(lastAction.batchActions){
					for(let i = 0; i < lastAction.batchActions.length; i++){
						let batchAction = lastAction.batchActions[i];
						
						if(batchAction.type === ACTION.object_changed){
							// remove object (cross):
							updates.push({
								type: ACTION.object_changed, 
								q: batchAction.q, 
								r: batchAction.r, 
								object: null,
							});
						}else if(batchAction.type === ACTION.unit_removed){
							// add removed unit back:
							batchAction.unit.wasSpawned = 0; // so the animations will work normally.
							updates.push({
								type: ACTION.unit_added, 
								unit: batchAction.unit, 
							});
						}
						
						// updates.push({ type: ACTION.unit_added, unit: lastAction.killedUnit });
					}
				}
				
				if(lastAction.unitId !== undefined){
					updates.push({ type: ACTION.unit_move_reset, hasMoved: false, unitId: lastAction.unitId});
				}
				

			} else if (lastAction.type === 'load_unit'){
				updates.push({ type: ACTION.unit_added, unit: lastAction.unit });
				updates.push({ type: ACTION.unit_load_reset, unitId: lastAction.targetUnit.id});
				
				updates.push({ type: ACTION.unit_move_reset, hasMoved: false, unitId: lastAction.unit.id});
				
			} else if (lastAction.type === 'build_object'){
				addCost(actionPool, lastAction.cost, poolHex, action.type);
				
				// give used mine back:
				let player = getPlayerByIndex(lastAction.actionPlayerIndex);
				updates.push({
					type: ACTION.player_changed, 
					playerIndex: playerIndex, 
					totalMines: player.totalMines+1,
				});
				
				updates.push({ type: ACTION.unit_move_reset, hasMoved: false, unitId: lastAction.unitId});
				
				const tile = getTileAt(lastAction.hex.q, lastAction.hex.r);
				if (tile) {
					tile.object = lastAction.oldObject ?? null;
					
					/*
					if(tile.objectOwnerIndexes !== undefined){
						// remove previously added owner index:
						tile.objectOwnerIndexes = tile.objectOwnerIndexes.filter(n => n !== lastAction.addedObjectOwnerIndex);
						// delete info if no owners set after undo:
						if(tile.objectOwnerIndexes.length === 0){
							delete tile.objectOwnerIndexes;
						}
					}
					
					oldObject: tile.object, // if you undo, you must keep the old object and not clear it.
					addedObjectOwnerIndex: addedObjectOwnerIndex,
					*/
					

					tileChangedUpdates.push({ type: ACTION.tile_changed, q: lastAction.hex.q, r: lastAction.hex.r, object: tile.object, removedObjectOwnerIndex: lastAction.addedObjectOwnerIndex });
				}
			
			} else if (lastAction.type === 'sell') {
				// handle un-selling the unit.

				console.log("actionPool:");
				console.log(actionPool);

				deductCost(actionPool, lastAction.sellPrice, poolHex, action.type);

				//gameState.units.push(lastAction.soldUnit);
				//addUnit(lastAction.soldUnit);
				console.warn("lastAction.soldUnit");
				console.warn(lastAction.soldUnit);
				updates.push({ type: ACTION.unit_added, unit: lastAction.soldUnit, wasUndo: 1 });
				
				unitActionHex = {q: lastAction.soldUnit.q, r: lastAction.soldUnit.r};
				
			}
			
			
			// push to updates all tile_changed updates that were merged into one:
			pushMergedUpdates(updates, tileChangedUpdates);
			
			if(!isAiPlayer(playerIndex)){
				let qq = 0;
				let rr = 0;
				if(unitActionHex){
					qq = unitActionHex.q;
					rr = unitActionHex.r;
				}
				sounds.push({name:'moveunit', q: qq, r: rr, action: action.type});
			}
			break;
		}
		case ACTION.action_end_turn: {
			if(gameState.settings.gameOver) return;
			// end turn
			
			console.warn("executeAction action_end_turn");
			
			executeEndTurn(playerIndex);
			
			//console.warn("clearing all undo counters");
			// clear undo counter for all players:
			broadcast({ 
				type: ACTION.undo_counter, 
				// no value needed, will be reset for all players.
			});

			if(!isAiPlayer(playerIndex)){
				broadcast({ type: ACTION.sound, name: "move", q:0, r:0, playerIndex: -1, action: action.type});
			}
			
			/////////////////////////////////////////////////
			// STOP HERE
			return; // end turn handles its own broadcasts
		}
		case ACTION.check_balance: {
			console.warn("executeAction from handleClientData: check_balance");
			console.warn(action.checkPlayers);
/*
			// this must be called AFTER all moves have been applied to the gameState.
			// sent after every important move player made (action_move/action_build).
			// check if soldiers will die due to negative balance: (savings+income)-wages
			
			for(let i = 0; i < action.checkPlayers.length; i++){
				let pools = findEconomyPools(action.checkPlayers[i]);
				let killdata = calculateBalanceAndKillSoldiers(pools);
				
				if(killdata.batchActions.length > 0){
					let batchActions = killdata.batchActions;
					let poolsAfter = killdata.poolsAfter;
					let poolsBefore = killdata.poolsBefore;
					actionForUndo.batchActions = batchActions;
					actionForUndo.poolsBefore = poolsBefore;
					updates.push(...batchActions); // TODO: should make this in multiple_actions instead.
					
					sounds.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_move});
				}
			}
			*/
		}
		break;
	}
	

	
	//console.log("executeAction endswitch");

	if (actionForUndo && !undoDisabled) {
		currentTurnActions.push(actionForUndo);
	}
	
	// update undo counter to player who made an action, for all actions except action_end_turn
	// not actually needed to check this since action_end_turn has return, so code wont reach here...
	if(action.type !== ACTION.action_end_turn){
		//console.warn("player '"+playerId+"' undo stack:");
		//console.warn(currentTurnActions);
		sendToPlayer(playerId, { 
			type: ACTION.undo_counter, 
			playerIndex: playerIndex,
			undoCounter: currentTurnActions.length,
		});
	}
	
	// send check balance for died soldiers at very end, so the gameState has time to update:
	//if(checkPlayers.length > 0){
	//	updates.push({ type: ACTION.check_balance, checkPlayers: checkPlayers });
	//}
	// send all updates to all players:
	for (const update of updates) {
		broadcast(update);
	}
	const uniqueSounds = [...new Set(sounds)];
	for (const sound of uniqueSounds) {
		broadcast({ type: ACTION.sound, playerIndex: playerIndex, ...sound});
	}
	
	
	//console.log("executeAction endswitch 2");
	
	// Send savings updates to all affected players
	//affectedPlayers.forEach(pid => updatePlayerSavings(pid));
	
	// send savings update to ALL players: (was bugged before, so host didnt get update).
	for(let p = 0; p < gameState.players.length; p++){
		updatePlayerSavings(gameState.players[p].playerIndex);
	}
	
	//console.log("executeAction endswitch 3");
	
	// non-synced updates executed on every action:
	setProtectedTiles();
	
	//console.log("executeAction endswitch 4");
}




// =================================================================
// --- ECONOMY & TURN LOGIC (HOST-SIDE)
// =================================================================
function updatePlayerSavings(playerIndex) {
	let logallowed = true;
	if(getPlayerByIndex(playerIndex).isAI){
		logallowed = false;
	}
	
	if(logallowed){
		console.log("updatePlayerSavings");
	}
	
	const newPools = findEconomyPools(playerIndex);
	//let newTotalSavings = 0;
	
	// create pools info array:
	let poolsInfo = [];
	for(let p = 0; p < newPools.length; p++){
		let pool = newPools[p];
		poolsInfo.push({
			totalIncome: pool.totalIncome,
			totalSavings: pool.totalSavings,
			totalWages: pool.totalWages,
		});
	}
	
	//console.log("updatePlayerSavings 2: newPools.len = "+newPools.length);
	
	//newPools.forEach(pool => newTotalSavings += pool.totalSavings);
	
	if(logallowed){
		console.log("poolsInfo:");
		console.log(poolsInfo);
	}
	
	sendToPlayer(getPlayerId(playerIndex), { 
		type: ACTION.savings_update, 
		//total: Math.floor(newTotalSavings),
		//total: newTotalSavings,
		poolsInfo: poolsInfo,
	});
}


function drawText(x, y, text, color = "#FFFFFF"){
	ctx.fillStyle = color;
	ctx.fillText(text, x, y);
}


function tileGivesIncome(tile){
	if(tile.object && tile.object !== 'dead' && getUnitType(tile.object) !== "mine"){
		// if object was set, and it is not dead or mine (so it is tree or grass)
		return false;
	}else{
		return true;
	}
}


// HOST-ONLY: clients doesnt know tiles savings.
// CLIENTS can only use this to know their pool sizes etc. not for money.
function findEconomyPools(playerIndex, log_enabled = false) {
	// Finds all contiguous land areas for a given player
	const pools = [];
	const visited = new Set(); // 'q,r,t'
	
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const qq = tile.q;
		const rr = tile.r;
		let elem = `${qq},${rr},${t}`;

		if (tile.ownerIndex !== playerIndex || visited.has(elem)) {
			continue;
		}
		
		// Start a new pool
		const pool = {
			hexes: [], // {q, r, tile}
			soldiers: [],
			totalSavings: 0, // recalculated from tile.savings
			totalIncome: 0,
			totalWages: 0
		};
		
		const queue = [elem]; // 'q,r,t'
		visited.add(elem);
		
		while (queue.length > 0) {
			const currentKey = queue.shift();
			const [q, r, tileIndex] = currentKey.split(',').map(Number);
			const currentTile = gameState.map.tilesData[tileIndex];
			
			pool.hexes.push({ q, r, tile: currentTile });
			pool.totalSavings += currentTile.savings;
			//console.warn(currentTile.savings);
			
			// Add income if no grass/tree on it, cross (dead) gives income for now.
			if (tileGivesIncome(currentTile)) {
				pool.totalIncome += gameRules.tileIncome;
			}
			
			// Check for soldier
			const unit = getUnitAt(q, r);
			
			
			if (unit && isSoldier(unit)) {
			//if (unit && isSoldier(unit) && SOLDIER_DATA[unit.type]) {
				const unitInfo = getUnitInfo(unit.type);
				if(unitInfo){
					pool.soldiers.push(unit);
					pool.totalWages += unitInfo.wage;
				}
			}
			
			// Check neighbors
			for (const n of getHexNeighbors(q, r)) {
				const nTile = getTileAt(n.q, n.r);
				
				if (nTile && nTile.ownerIndex === playerIndex){
					const nKey = `${n.q},${n.r},${nTile.tileIndex}`;
					if(!visited.has(nKey)) {
						visited.add(nKey);
						queue.push(nKey);
					}
				}
			}
		}
		pools.push(pool);
	}
	if(log_enabled){
		console.warn("findEconomyPools for playerIndex "+playerIndex);
		console.warn(pools);
	}
	return pools;
}




// uses pool.totalSavings to distribute savings per hex.
function distributePoolSavings(pools) {
	// Normalize input so we always work with an array:
	if (!Array.isArray(pools)) {
		pools = [pools];
	}

	for (const pool of pools) {
		if (!pool || pool.hexes.length === 0) continue;
		
		const count = pool.hexes.length;
		const total = pool.totalSavings;
		
		// 1. Calculate the standard share per tile
		const share = total / count;
		
		// 2. Track exactly how much we have handed out so far
		let distributedSoFar = 0;

		for (let i = 0; i < count; i++) {
			const hex = pool.hexes[i];

			// tile.savings += ... basically.
			if (i === count - 1) {
				// --- THE FIX ---
				// The last tile doesn't get the division result.
				// It gets the difference. This absorbs the 0.00000002 error.
				
				hex.tile.savings = total - distributedSoFar;
			} else {
				hex.tile.savings = share;
				distributedSoFar += share;
			}

		}
	}
}



function canAffordCheck(savings, cost) {
	return savings >= cost - EPSILON;
}






function deductCost(pools, cost, preferredHex = null, actionType = "unknown") {
	console.log("deductCost: " + cost);

	// Normalize input so we always work with an array:
	if (!Array.isArray(pools)) {
		pools = [pools];
	}

	if (pools.length > 0 && pools[0].hexes.length > 0) {
		let targetTile = pools[0].hexes[0].tile; // Default fallback

		// If a safe hex is provided, try to find it in the pool
		if (preferredHex) {
			const match = pools[0].hexes.find(h => h.q === preferredHex.q && h.r === preferredHex.r);
			if (match) {
				targetTile = match.tile;
			}
		}

		targetTile.savings -= cost;
		console.log(`Charged ${cost} from tile ${targetTile.q},${targetTile.r}`);
	}
}


function addCost(pools, cost, preferredHex = null, actionType = "unknown") {
	console.log("addCost on action '"+actionType+"': " + cost);

	// Normalize input so we always work with an array:
	if (!Array.isArray(pools)) {
		pools = [pools];
	}

	if (pools.length > 0 && pools[0].hexes.length > 0) {
		let targetTile = pools[0].hexes[0].tile; // Default fallback

		// If a safe hex is provided, try to find it in the pool
		if (preferredHex) {
			const match = pools[0].hexes.find(h => h.q === preferredHex.q && h.r === preferredHex.r);
			if (match) {
				targetTile = match.tile;
			}
		}

		targetTile.savings += cost;
		console.log(`Refunded ${cost} to tile ${targetTile.q},${targetTile.r}`);
	}
}


function getNextPlayerIndexAndProcessEndOfDay(currentIndex){
	let nextIndex = currentIndex;
	// get next player index:
	let counter = 0;
	let alreadyAdvanced = false;
	do {
		nextIndex = (nextIndex + 1) % gameState.players.length;
		
		// make sure to process end of day even if a player is dead.
		if(!alreadyAdvanced && nextIndex === gameState.turn.startPlayerIndex){
			
			processEndOfDay();
			alreadyAdvanced = true; // do this only once, in case everyone is dead/spectator.
		}
		
		counter++;
	} while ((gameState.players[nextIndex].isSpectator || gameState.players[nextIndex].isDead) && counter < 100);

	if(counter >= 99){
		return 0; // give first player turn if no valid players found.
	}else{
		return nextIndex;
	}
}


function getNextPlayerIndex(currentIndex){
	let nextIndex = currentIndex;
	// get next player index:
	let counter = 0;
	do {
		nextIndex = (nextIndex + 1) % gameState.players.length;
		counter++;
	} while ((gameState.players[nextIndex].isSpectator || gameState.players[nextIndex].isDead) && counter < 1000);

	return nextIndex;
}


// this is host function.
function advanceToNextPlayer(){
	if(gameState.settings.gameOver) return;
	
	console.warn("advanceToNextPlayer");
	// advance to next player and process end of day:
	gameState.turn.currentPlayerIndex = getNextPlayerIndexAndProcessEndOfDay(gameState.turn.currentPlayerIndex);

	updateGameUI();
}



function random(min, max) {
  return Math.floor(randomFunc() * (max - min + 1)) + min;
}

function randomItem(arr){
	return arr[random(0, arr.length-1)];
}

// find_ai_best_move findaibestmove aifindbestmove aimove ai_move ai_turn
// ai turn ai move
function ai_find_best_move2(player) {
	//console.log("ai_find_best_move (improved)");

	let bestMove = null;
	let bestScore = -Infinity;

	for (let i = 0; i < gameState.units.length; i++) {
		const unit = gameState.units[i];
		if (unit.hasMoved || unit.ownerIndex !== player.playerIndex){
			continue;
		}

		const possibleMovesTemp = findUnitPossibleMoves(unit, player);
		const possibleMoves = [];

		for (const tile of possibleMovesTemp) {
			//const tile = getTileAt(tile.q, tile.r);
			const check = isMoveValid(unit, tile, player);
			if (check.valid){
				possibleMoves.push({tile:tile, poolHex:{q:unit.q, r:unit.r}});
			}
		}

		for (const moveInfo of possibleMoves) {
			//const tile = getTileAt(moveInfo.move.q, moveInfo.move.r);
			const tile = moveInfo.tile;
			let score = 0;

			
			// === Base scoring ===
			// Prefer new land
			if (tile.ownerIndex === undefined || tile.ownerIndex === -1){
				score += 5;
			}

			if (tile.ownerIndex !== undefined){
				// Prefer enemy tiles
				if (tile.ownerIndex !== player.playerIndex) score += 10;

				// ----------------------------------------------------------------------------------
				//  === Terrain & Economy Restoration Scoring (NEW FOCUS) === 
				// ----------------------------------------------------------------------------------
				
				if (tile.object === "grass") {
					if (tile.ownerIndex === player.playerIndex) {
						// Clear grass from our tile to restore income.
						score += 5; 
					} else {
						// Claim and clear grass on neutral/enemy tile for better future income/expansion.
						score += 3; 
					}
				}
				
				if (tile.object === "tree") {
					if (tile.ownerIndex === player.playerIndex) {
						// Clear tree from our tile to restore income (highest priority).
						score += 5;
					} else {
						// Clearing a tree on neutral/enemy land is slightly useful for future income.
						
						// dont try to seek for trees...
						//score += 1; 
					}
				}
			}
			// ----------------------------------------------------------------------------------

			// === Attack scoring ===
			const enemyUnit = gameState.units.find(u => u.q === tile.q && u.r === tile.r);
			if (enemyUnit) {
				if (unit.level > enemyUnit.level) {
					score += 25; // easy kill
				} else {
					score -= 20; // risky
				}
			}

			// === Territorial influence ===
			//const neighbors = getHexNeighbors(tile.q, tile.r);
			const neighbours = tile.neighbours;
			let enemyAdj = 0;
			let friendlyAdj = 0;
			for (const neigh of neighbours) {
				if(neigh !== -1){
					//const nt = getTileAt(n.q, n.r);
					const nTile = gameState.map.tilesData[neigh];
					if (nTile.ownerIndex !== undefined){
						if (nTile.ownerIndex !== player.playerIndex){
							enemyAdj++;
						}else{
							friendlyAdj++;
						}
					}
					
				}
			}
			score += enemyAdj * 2;
			score += friendlyAdj;

			if (score > bestScore) {
				bestScore = score;
				bestMove = {
					type: ACTION.action_move,
					unitId: unit.id,
					toQ: tile.q,
					toR: tile.r,
					poolHex: moveInfo.poolHex,
				};
			}
		}
	}

	if (bestMove) {
		console.log("AI selected best move:", bestMove, "score:", bestScore);
		return bestMove;
	}

	// fallback
	return null;
}




function ai_find_best_move(player) {
	//console.log("ai_find_best_move (improved)");

	let bestMove = null;
	let bestScore = -Infinity;

	for (let i = 0; i < gameState.units.length; i++) {
		const unit = gameState.units[i];
		if (unit.hasMoved || unit.ownerIndex !== player.playerIndex) continue;

		const possibleMovesTemp = findUnitPossibleMoves(unit, player);
		const possibleMoves = [];

		for (const move of possibleMovesTemp) {
			const tile = getTileAt(move.q, move.r);
			if (!tile || tile.ownerIndex === player.playerIndex) continue;
			const check = isMoveValid(unit, move, player);
			if (check.valid) possibleMoves.push({move:move, poolHex:{q:unit.q, r:unit.r}});
		}

		for (const moveInfo of possibleMoves) {
			const tile = getTileAt(moveInfo.move.q, moveInfo.move.r);
			let score = 0;

			// === Base scoring ===
			// Prefer new land
			if (tile.ownerIndex === -1) score += 5;

			// Prefer enemy tiles
			if (tile.ownerIndex !== -1 && tile.ownerIndex !== player.playerIndex) score += 10;

			// === Attack scoring ===
			const enemyUnit = gameState.units.find(u => u.q === moveInfo.move.q && u.r === moveInfo.move.r);
			if (enemyUnit) {
				if (unit.level > enemyUnit.level) {
					score += 25; // easy kill
				} else {
					score -= 20; // risky
				}
			}

			// === Territorial influence ===
			// More valuable if this move borders more enemy land (potential cutoff)
			const neighbors = getHexNeighbors(moveInfo.move.q, moveInfo.move.r);
			let enemyAdj = 0;
			for (const n of neighbors) {
				const nt = getTileAt(n.q, n.r);
				if (nt && nt.ownerIndex !== -1 && nt.ownerIndex !== player.playerIndex) enemyAdj++;
			}
			score += enemyAdj * 2;

			// === Economy safety ===
			// Slightly prefer staying near friendly land (less isolation)
			const friendlyAdj = neighbors.filter(n => {
				const nt = getTileAt(n.q, n.r);
				return nt && nt.ownerIndex === player.playerIndex;
			}).length;
			score += friendlyAdj;

			if (score > bestScore) {
				bestScore = score;
				bestMove = {
					type: ACTION.action_move,
					unitId: unit.id,
					toQ: moveInfo.move.q,
					toR: moveInfo.move.r,
					poolHex: moveInfo.poolHex,
				};
			}
		}
	}

	if (bestMove) {
		console.log("AI selected best move:", bestMove, "score:", bestScore);
		return bestMove;
	}

	// fallback
	return null;
}




// ai turn delay ai aidelay aiturn
let AI_DELAY_START = 50; // enough delay so animations have time to finish?
let AI_DELAY_MOVE = 50;

let batchActionsAI = [];

let useBatchMoves = 1;

// 1. Create a helper to let the browser "breathe" (render one frame)
const yieldToMainThread = () => new Promise(resolve => setTimeout(resolve, 0));


// 2. Mark function as ASYNC
async function executeAIMoveSequentially(player) {
    if (!isHost() || gameState.settings.gameOver) return;

    const currentPlayer = gameState.players[gameState.turn.currentPlayerIndex];
    if (!currentPlayer || currentPlayer.id !== player.id || !currentPlayer.isAI) {
        return;
    }

    // --- START BATCH MODE ---
    isAiBatching = true;
    aiBatchBuffer = [];
    console.log(`AI ${player.name} starting batch calculation...`);

    let keepPlaying = true;
    let movesCount = 0;
    const MAX_MOVES = 200;

    // Start a timer to track how long we've been calculating
    let startTime = performance.now();

    while (keepPlaying && movesCount < MAX_MOVES) {
        const bestMove = ai_find_best_move(player);

        if (bestMove) {
            handleClientData(player.id, bestMove);
            movesCount++;
            
            // --- THE MAGIC FIX ---
            // Every 5 moves (or if 16ms has passed), pause for 0ms to let the UI update.
            // This prevents the "Freezing" / "Page Unresponsive" warning.
            if (movesCount % 5 === 0 || (performance.now() - startTime) > 15) {
                await yieldToMainThread(); 
                startTime = performance.now(); // Reset timer
                
                // CRITICAL: Re-check game state after resuming!
                // Since we paused, the game state *might* have changed (e.g. game over).
                if (gameState.settings.gameOver) {
                    keepPlaying = false; 
                    break;
                }
            }
        } else {
            keepPlaying = false;
        }
    }
	
	

    handleClientData(player.id, { type: ACTION.action_end_turn });

    // --- END BATCH MODE ---
    isAiBatching = false;
	

    if (aiBatchBuffer.length > 0) {
        const bigMessage = {
            type: ACTION.multiple_actions,
            actions: aiBatchBuffer
        };

        for (const [peerId, conn] of connections.entries()) {
            conn.send(bigMessage);
        }
        
        console.log(`AI Batch sent: ${aiBatchBuffer.length} sub-actions.`);
    }

    aiBatchBuffer = []; 
}


function executeAIMoveSequentially1(player) {
	if (!isHost() || gameState.settings.gameOver) return;

	// Double-check if it's still this AIs turn
	const currentPlayer = gameState.players[gameState.turn.currentPlayerIndex];
	if (!currentPlayer || currentPlayer.id !== player.id || !currentPlayer.isAI) {
		return;
	}

	// --- START BATCH MODE ---
	isAiBatching = true;
	aiBatchBuffer = []; // Clear buffer

	console.log(`AI ${player.name} starting batch calculation...`);

	let keepPlaying = true;
	let movesCount = 0;
	const MAX_MOVES = 200; // Safety guard against infinite loops

	// 1. Calculate and Execute all moves locally
	while (keepPlaying && movesCount < MAX_MOVES) {
		const bestMove = ai_find_best_move(player);

		if (bestMove) {
			// executeAction -> broadcast -> handleHostData (Updates State) -> Pushes to aiBatchBuffer
			handleClientData(player.id, bestMove);
			movesCount++;
		} else {
			// No more valid moves found
			keepPlaying = false;
		}
	}

	// 2. End the Turn
	// executeEndTurn -> broadcast -> handleHostData (Updates State) -> Pushes to aiBatchBuffer
	handleClientData(player.id, { type: ACTION.action_end_turn });

	// --- END BATCH MODE ---
	isAiBatching = false;

	// 3. Send Buffer to Clients
	if (aiBatchBuffer.length > 0) {
		const bigMessage = {
			type: ACTION.multiple_actions,
			actions: aiBatchBuffer // Contains all unit_moved, tile_changed, sound, etc.
		};

		// Send one big message to all clients
		for (const [peerId, conn] of connections.entries()) {
			conn.send(bigMessage);
		}
		
		console.log(`AI Batch sent: ${aiBatchBuffer.length} sub-actions.`);
	}

	aiBatchBuffer = []; // Cleanup
}





// checkaiturn
function checkForAITurn(){
	//console.log("checkForAITurn");
	// Only the host should control the AI
	if (!isHost() || gameState.settings.gameOver) return;
	
	//console.log("checkForAITurn 2");

	const currentPlayer = gameState.players[gameState.turn.currentPlayerIndex];

	// If the current player is an AI, trigger their move sequence
	if (currentPlayer && currentPlayer.isAI && !currentPlayer.isDead) {
		console.log(`Starting AI turn for: ${currentPlayer.name}`);
		
		// Start the sequential move execution
		// Add a small initial delay to allow the "turn changed" message to settle, so you can see the AI player changing
		setTimeout(() => {
			batchActionsAI = [];
			executeAIMoveSequentially(currentPlayer);
		}, AI_DELAY_START); // Small delay before first move, so you can see the AI player changing
	}
}



// return only milliseconds from performance timer.
function msNowFloor(){
	return Math.floor(performance.now());
}



// this is host function.
function processEndOfDay(){
	
	let weekChanged = false;

	let weekBefore = 1+Math.floor((gameState.turn.turnNumber - 1) / 7);
	
	gameState.turn.turnNumber++;

	let weekAfter = 1+Math.floor((gameState.turn.turnNumber - 1) / 7);
	
	if(weekBefore !== weekAfter){
		weekChanged = true;
	}
	
	let batchActions = [];
	console.warn("Day ended, new day starts. process trees, grasses etc.");
	
	
	
	// kill boats after they run out of time:
	for(let i = 0; i < gameState.units.length; i++){
		let unit = gameState.units[i];
		
		if(unit.dayBuilt !== undefined){
			let daysPassed = gameState.turn.turnNumber - unit.dayBuilt;
			
			if(daysPassed > unit.maxDays){
				// kill unit and explode:
				let killData = killUnit(unit);
				batchActions.push(...killData);
			}
		}
	}
	
	
	if(weekChanged){
		// each week, give mines for all players:
		for(let i = 0; i < gameState.players.length; i++){
			let player = gameState.players[i];
			if(!player.isSpectator && !player.isDead){
				let newMines = (player.totalMines??0) + gameState.settings.minesPerWeek;
				let newBoats = (player.totalBoats??0) + gameState.settings.boatsPerWeek;
				if(newMines > gameState.settings.maxMines) newMines = gameState.settings.maxMines;
				if(newBoats > gameState.settings.maxBoats) newBoats = gameState.settings.maxBoats;
				
				batchActions.push({
					type: ACTION.player_changed, 
					playerIndex: player.playerIndex, 
					totalMines: newMines,
					totalBoats: newBoats,
				});
			}
		}
	}
	
	// process:
	// - crosses turning into grass.
	// - grass spreading randomly.
	// - new trees spawning randomly.
	
	// cross becomes grass in... 4 turns
	// grass Â´grows 1-3 pieces per turn, chance is 50 for one piece?
	// trees grow more the more land there is, i think max is 2 per turn.
	let grassGrow = {};
	let landtilesCount = 0;
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];

		// add random trees to land tiles without any objects or units:
		if(getTileType(tile) === 'land'){
			landtilesCount++;
			
			// check if there is object on tile for grass/cross functionality:
			if(tile.object && tile.actionTurnNumber){

				let turnDiff = gameState.turn.turnNumber - tile.actionTurnNumber;
	
				if(tile.object === 'dead'){
					// turn crosses into grass after 4 turns:
					if(turnDiff >= 4){
						tile.object = 'grass';
						tile.actionTurnNumber = gameState.turn.turnNumber;
						
						// add animation info for host:
						tile.creationTime = msNowFloor(); 
						tile.animationFinished = 0; // ensure no animation will be visible.
						tile.animationStyle = 2; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
						
						batchActions.push({ 
							type: ACTION.object_changed, 
							q: tile.q, 
							r: tile.r, 
							object: tile.object,
							// add animation info: (other animation vars will be set on client side)
							animationStyle: tile.animationStyle,
						});
					}
				}else if(tile.object === 'grass'){
					// spread grass 
					let neigh = getHexNeighbors(tile.q, tile.r);
					for(let i = 0; i < neigh.length; i++){
						let n = neigh[i];
						const nTile = getTileAt(n.q, n.r);
						if(getTileType(nTile) === 'land'){
							// dont allow grow if there is an object:
							let allowGrow = !nTile.object;
							// allow if there is an invisible mine:
							if(isTypeMine(nTile.object)){
								allowGrow = true;
							}
							
							if(allowGrow){
								// a land tile without any objects yet.
								// check if there is any units on this tile:
								if(!getUnitAt(n.q, n.r)){
									// ready to use random chance for growing:
									if(randomFunc() < 0.08){
										// set this tile as possible growing for grass:
										grassGrow[`${nTile.q},${nTile.r}`] = nTile;
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	
	console.log("spread grass:");
	
	// spread grass, using keyed array so it wont spread into too far away, just neighbours:
	for (const key in grassGrow) {
		if (grassGrow.hasOwnProperty(key)) {
			let nTile = grassGrow[key]; // was neighbour tile, so using nTile still here.
			nTile.object = 'grass';
			nTile.actionTurnNumber = gameState.turn.turnNumber;
			
			// add animation info for host:
			nTile.creationTime = msNowFloor(); 
			nTile.animationFinished = 0; // ensure no animation will be visible.
			nTile.animationStyle = 2; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
			
			batchActions.push({ 
				type: ACTION.object_changed, 
				q: nTile.q, 
				r: nTile.r, 
				object: nTile.object,
				// add animation info: (other animation vars will be set on client side)
				animationStyle: nTile.animationStyle,
			});
		}
	}



	
	
	let treesPercent = 2/240; // 0.00833
	let maxTrees = Math.round(landtilesCount*treesPercent);
	let minTrees = 1;
	if(maxTrees > 4) maxTrees = 4;
	
	// if maxtrees is 0, add randomly 0 or 1 trees
	if(maxTrees == 0){
		minTrees = 0;
		maxTrees = random(0,random(0,1));
	}else if(maxTrees == 1){
		minTrees = 0;
		maxTrees = random(0,1);
	}else if(maxTrees == 2){
		minTrees = 0;
		maxTrees = random(0,1);
	}else if(maxTrees == 3){
		minTrees = 0;
		maxTrees = random(0,1);
	}else if(maxTrees == 4){
		minTrees = 1;
		maxTrees = random(1,2);
	}
	let curMaxTrees = random(minTrees, maxTrees);
	
	console.log("maxTrees: "+maxTrees+", curMaxTrees: "+curMaxTrees);
	
	// grow trees growtrees spawntrees()
	// add random trees: 
	const tiles = gameState.map.tilesData;
	for (let i = 0; i < curMaxTrees; i++) {
		let found = 0;
		let tile = null;
		for(let tries = 0; tries < 100; tries++){
			let rti = random(0, tiles.length - 1);
			tile = tiles[rti];
			// if(tile.type === 'water'
			if(!isTileLand(tile) || tile.object || getUnitAt(tile.q, tile.r)){
				continue;
			}else{
				found = 1;
				break;
			}
		}
		
		if(found){
			console.log("found free tile:");
			console.log(tile);
			// add tree:
			tile.object = 'tree';
			tile.actionTurnNumber = gameState.turn.turnNumber;
			
			// set animation info for host:
			tile.creationTime = msNowFloor(); 
			tile.animationFinished = 0; // ensure no animation will be visible.
			tile.animationStyle = 1; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
			
			batchActions.push({ 
				type: ACTION.object_changed, 
				q: tile.q, 
				r: tile.r, 
				object: tile.object, 
				// add animation info: (other animation vars will be set on client side)
				animationStyle: tile.animationStyle,
			});
			console.warn("tree spawned at "+tile.q+tile.r);
		}else{
			console.log("looped 1000 times and found no free tiles.");
		}
	}
	
	console.log("processEndOfDay done, save game:");
	
	
	if(batchActions.length > 0){
		broadcast({ 
			type: ACTION.multiple_actions, 
			actions: batchActions,
		});
	}
	
}



/*

game logic:
click next turn:
savings = savings + (income - wages)

initially: (1 peasant (wage 3))

savings: 21
income: 5
wages: -3
balance: 23

click buy knight (cost 20, wage 8) ->
savings: 1
income: 5
wages: -11
balance: -5 ((1+5)-11 = -5)

place knight: (1 peasant, 1 knight)
*all units dies*
savings: 0
income: 5
wages: 0
balance: 5
*/

// allows 1/100000 values, basically 1000 tiles possible to own with 2 decimal precision.
// EPSILON  = 0.000001
// accepted : 0.00001 value
function clampMoney(money) {
	let rounded = Math.round(money * 1e5) / 1e5;

	// eliminate -0 and negative float noise only
	if (Object.is(rounded, -0) || (rounded < 0 && rounded > -1e-5)){
		rounded = 0;
	}
	//console.warn(money, rounded);

	return rounded;
}



/*
clampMoney(-0.0000001);
clampMoney(-0.000001);
clampMoney(-0.000003999);
clampMoney(-0.00001); // >= accepted
clampMoney(-0.0001);
clampMoney(-0.001);
clampMoney(-0.01);
clampMoney(-0.1);
clampMoney(-1);
clampMoney(0);
clampMoney(1);
clampMoney(0.1);
clampMoney(0.01);
clampMoney(0.001);
clampMoney(0.0001);
clampMoney(0.00001); // <= accepted
clampMoney(0.000001);
clampMoney(0.0000001);
*/





function calculateBalanceAndKillSoldiers(pools, addedUnit = null){
	// check if soldiers will be killed.
	
	// send actions in one array to speed up messages and avoiding clutter.
	let batchActions = [];
	
	let allSoldiersKilled = [];
	let poolsBefore = deepClone(pools);
	

	// add income and deduct wages:
	for (let pool of pools) {
		pool.totalSavings += pool.totalIncome;
		pool.totalSavings -= pool.totalWages;
		
		// avoid -0.000001 negative values or 0.000001 positive values (EPSILON):
		pool.totalSavings = clampMoney(pool.totalSavings);
		
		if (pool.totalSavings < 0) {
		//if (pool.totalSavings-pool.totalWages < 0) {
			// Bankrupt!
			pool.totalSavings = 0;
			// todo: update modified info to localplayer?
			for (const soldier of pool.soldiers) {
				allSoldiersKilled.push(soldier);
			}
		}
	}

	
	// kill soldiers kill units:
	if(allSoldiersKilled.length > 0){
		// --- 2. Kill soldiers & turn to crosses ---
		for (const soldier of allSoldiersKilled) {
			let tile = getTileAt(soldier.q, soldier.r);
			if (tile) {
				tile.object = 'dead'; // Turn to dead (crosses)
				tile.actionTurnNumber = gameState.turn.turnNumber;
				
				// add animation info for host:
				tile.creationTime = msNowFloor(); 
				tile.animationFinished = 0; // ensure no animation will be visible.
				tile.animationStyle = 1; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
				
				batchActions.push({ 
					type: ACTION.object_changed, 
					q: soldier.q, 
					r: soldier.r, 
					object: tile.object,
					animationStyle: tile.animationStyle,
				});
				batchActions.push({ 
					type: ACTION.unit_removed, 
					unitId: soldier.id,
					unit: soldier, // only used for undoing.
				});
			}
			
			console.warn("allSoldiersKilled");
			console.warn(allSoldiersKilled);

			//gameState.units = gameState.units.filter(u => u.id !== soldier.id);
			//broadcast({ type: ACTION.unit_removed, unitId: soldier.id });
		}
		

		// send sound for died soldiers just once:
		//batchActions.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_end_turn});
	}
	
	return {batchActions: batchActions, poolsAfter: pools, poolsBefore: poolsBefore};
}





function calculateBalanceAndKillSoldiers1(pools){
	// check if soldiers will be killed:
	// send actions in one array to speed up messages and avoiding clutter.
	let batchActions = [];
	
	let allSoldiersKilled = [];
	

	// add income and deduct wages:
	for (let pool of pools) {
		pool.totalSavings += pool.totalIncome;
		pool.totalSavings -= pool.totalWages;
		
		if (pool.totalSavings < 0) {
			// Bankrupt!
			pool.totalSavings = 0;
			// todo: update modified info to localplayer?
			for (const soldier of pool.soldiers) {
				allSoldiersKilled.push(soldier);
			}
		}
	}

	
	// kill soldiers kill units:
	if(allSoldiersKilled.length > 0){
		// --- 2. Kill soldiers & turn to crosses ---
		for (const soldier of allSoldiersKilled) {
			let tile = getTileAt(soldier.q, soldier.r);
			if (tile) {
				tile.object = 'dead'; // Turn to dead (crosses)
				tile.actionTurnNumber = gameState.turn.turnNumber;
				
				// add animation info for host:
				tile.creationTime = msNowFloor(); 
				tile.animationFinished = 0; // ensure no animation will be visible.
				tile.animationStyle = 1; // 1 = appear from bottom to up, 2 = appear from zero size to normal size
				
				batchActions.push({ 
					type: ACTION.object_changed, 
					q: soldier.q, 
					r: soldier.r, 
					object: tile.object,
					animationStyle: tile.animationStyle,
				});
				batchActions.push({ 
					type: ACTION.unit_removed, 
					unitId: soldier.id,
				});
			}
			
			console.warn("allSoldiersKilled");
			console.warn(allSoldiersKilled);

			//gameState.units = gameState.units.filter(u => u.id !== soldier.id);
			//broadcast({ type: ACTION.unit_removed, unitId: soldier.id });
		}
		

		// send sound for died soldiers just once:
		//batchActions.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_end_turn});
	}
	
	return {batchActions: batchActions, pools: pools};
}



/*

game logic:
click next turn:
savings = savings + (income - wages)

initially: (1 peasant (wage 3))

savings: 21
income: 5
wages: -3
balance: 23

click buy knight (cost 20, wage 8) ->
savings: 1
income: 5
wages: -11
balance: -5

place knight: (1 peasant, 1 knight)
*all units dies*
savings: 0
income: 5
wages: 0
balance: 5
*/


// kill and return actions array:
function killPlayer(playerIndex){
	let player = getPlayerByIndex(playerIndex);
	player.isDead = true;

	let batchActions = [];
	
	batchActions.push({ type: ACTION.player_killed, playerIndex: playerIndex });

	let killedUnits = killPlayerUnits(playerIndex);
	if(killedUnits.length > 0){
		batchActions.push(...killedUnits);
	}

	return batchActions;
}

// for testing: kill and broadcast:
function killPlayerNow(playerIndex){
	let batchActions = killPlayer(playerIndex);
	
	if(batchActions.length > 0){
		broadcast({ 
			type: ACTION.multiple_actions, 
			actions: batchActions,
		});
	}
}


function remainingHumanPlayers(){
	let remaining = [];
	for(let i = 0; i < gameState.players.length; i++){
		let player = gameState.players[i];
		if(!player.isSpectator && !player.isDead && !player.isAI){
			remaining.push(player);
		}
	}
	return remaining.length;
}


function getLastRemainingPlayer(){
	let remaining = [];
	for(let i = 0; i < gameState.players.length; i++){
		let player = gameState.players[i];
		if(!player.isSpectator && !player.isDead){
			remaining.push(player);
		}
	}
	if(remaining.length === 1){
		return remaining[0];
	}else if(remaining.length === 0){
		return -1; // no players left, play defeat sound.
	}else{
		return null;
	}
}



// HOST-SIDE
function executeEndTurn(playerIndex) {
	// --- 1. Apply income and wages for current player ---
	const player = getPlayerByIndex(playerIndex);
	let pools = findEconomyPools(playerIndex);
	
	console.log("executeEndTurn");
	
	/*
	// add income and deduct wages:
	for (let pool of pools) {
		pool.totalSavings += pool.totalIncome;
		pool.totalSavings -= pool.totalWages;
		// todo make this right... just quick fix to make it playable in some way...
		if (pool.totalSavings < 0) {
			// Bankrupt!
			pool.totalSavings = 0;
		}
	}
	*/
	
	
	
	// this should be executed at every move/build, not end of the turn:
	let killdata = calculateBalanceAndKillSoldiers(pools);
	let batchActions = killdata.batchActions;
	pools = killdata.poolsAfter;
	
	// send sound for died soldiers just once:
	if(batchActions.length > 0){
		batchActions.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_end_turn});
	}
	
	
	//let batchActions = [];
	
	// --- 3. Reset "hasMoved" for all *this player's* units ---
	gameState.units.forEach(u => {
		if (u.ownerIndex === playerIndex) {
			if (u.hasMoved) {
				u.hasMoved = 0;
				batchActions.push({ type: ACTION.unit_move_reset, unitId: u.id, hasMoved: 0 });
			}
		}
	});
	
	// check game end for players:
	for(let p = 0; p < gameState.players.length; p++){
		let player = gameState.players[p];
		
		if(!player.isDead && !player.isSpectator){
			let doKill = false;
			
			let totalUnits = 0;
			for(let u = 0; u < gameState.units.length; u++){
				let unit = gameState.units[u];
				if(unit.ownerIndex === player.playerIndex){
					if(unit.internalType === "soldier"){
						totalUnits++;
					}
				}
			}
			
			if(gameState.settings.gameEndRule === ENDRULE_NO_SOLDIERS){
				if(totalUnits === 0){
					doKill = true;
				}
			}else if(gameState.settings.gameEndRule === ENDRULE_NO_SOLDIERS_NO_MONEY){
				if(totalUnits === 0){
					// check if player has any hex with an income:
					let foundIncomeTile = false;
					for(let t = 0; t < gameState.map.tilesData.length; t++){
						let tile = gameState.map.tilesData[t];
						if(tile.ownerIndex === player.playerIndex){
							if(tileGivesIncome(tile)){
								foundIncomeTile = true;
								break;
							}
						}
					}
					// none of the tiles had income:
					if(!foundIncomeTile){
						// check if any pool has enough savings to buy anything:
						//let pools = findEconomyPools(player.playerIndex);

						let canBuy = false;
						for(let i = 0; i < pools.length; i++){
							let pool = pools[i];
							if(canBuyAnything(pool.totalSavings)){
								canBuy = true;
							}
						}
						if(!canBuy){
							doKill = true;
						}
					}
				}
			}
			
			if(doKill){
				console.warn("PLAYER HAS DIED: "+player.name);
				// send ACTION.player_killed message and set player as dead:
				batchActions.push(...killPlayer(player.playerIndex));
			
				let allStats = [];
				for(let i = 0; i < gameState.players.length; i++){
					allStats.push(getPlayerStats(i));
				}
				
				let remainingHumans = remainingHumanPlayers();

				if(remainingHumans === 0){
					gameState.settings.gameOver = true;

					batchActions.push({
						type: ACTION.game_over,
						winnerPlayerIndex: -1, // -1 = no winner, AI's won.
						allStats: allStats,
					});
				}else{
					let winner = getLastRemainingPlayer();
					if(winner !== null){
						let winnerPlayerIndex = -1;
						if(winner !== -1){
							winnerPlayerIndex = winner.playerIndex;
						}
						gameState.settings.gameOver = true;
						
						batchActions.push({
							type: ACTION.game_over,
							winnerPlayerIndex: winnerPlayerIndex,
							allStats: allStats,
						});
					}
				}
					
				/*
				player.isDead = true;
				
				batchActions.push({ type: ACTION.player_killed, playerIndex: player.playerIndex });
				
				// maybe should kill units with a delay? or not...
				batchActions.push(...killPlayerUnits(player.playerIndex));
				*/
			}
		}
	}
	

	if(!gameState.settings.gameOver){
		// --- 4. Grow Grass / Spawn Trees (random events) ---
		// TODO: Add grass spreading and tree spawning logic
		
		// --- 5. Advance Turn ---
		// this will update dead soldiers into grass, so need to call this BEFORE updatePlayerSavings
		advanceToNextPlayer();
		console.warn("advanceToNextPlayer");
		
		//////////////////////////////////
		// Distribute final savings
		distributePoolSavings(pools);
		updatePlayerSavings(playerIndex); // Update savings *after* calcs
		
		
		//console.log("gameState.turn.currentPlayerIndex");
		//console.log(gameState.turn.currentPlayerIndex);
		
		
		currentTurnActions = []; // Clear undo stack
		
		batchActions.push({ 
			type: ACTION.turn_changed, 
			currentPlayerIndex: gameState.turn.currentPlayerIndex, 
			turnNumber: gameState.turn.turnNumber 
		});
	}
	
	
	// send whatever messages we built:
	if(batchActions.length > 0){
		broadcast({ 
			type: ACTION.multiple_actions, 
			actions: batchActions,
		});
	}
	
	
	if(!gameState.settings.gameOver){
		// --- 6. Check for AI turn ---
		// NEW: This will now start the AI's sequential turn
		checkForAITurn(); // start AI turn if it is his turn.
	}
}




const uiRightTopRow = document.getElementById('ui-right-top-row-id');
const uiRightButtonRow1 = document.getElementById('ui-right-button-row1-id');


function spectatorUiMode(){
	//uiRight.style.display = "none";
	// make transparent panel:
	uiRight.classList.remove('ui-panel');
	uiRight.classList.add('ui-panel-trans');
	
	// hide unnecessary buttons and ui elements:
	uiRightTopRow.style.display = "none";
	uiRightButtonRow1.style.display = "none";
	undoBtn.style.display = "none";
	endTurnBtn.style.display = "none";
	nextUnitBtn.style.display = "none";
	previousUnitBtn.style.display = "none";
}




function addUnit(unit){
	// wasSpawned true if spawned at game load.
	
	// set times for host:
	if(unit.internalType === 'castle'){
		unit.creationTime = msNowFloor(); 
		unit.animationFinished = 0; // ensure no animation will be visible.
		unit.animationStyle = 1; // 1 = appear from bottom to up, 0 = no animation.
	}else if(unit.internalType === 'soldier'){
		unit.creationTime = msNowFloor(); 
		unit.animationFinished = 0; // ensure no animation will be visible.
		unit.animationStyle = 2; // 2 = appear from zero size to normal size, 0 = no animation.
		if(!unit.name){
			unit.name = findNextFreeRandomUnitName(unit.ownerIndex);
		}
	}else if(unit.internalType === 'boat'){
		unit.creationTime = msNowFloor(); 
		unit.animationFinished = 0; // ensure no animation will be visible.
		unit.animationStyle = 2; // 2 = appear from zero size to normal size, 0 = no animation.
		unit.maxDays = BOAT_MOVE_DAYS; // how many days until it explodes
		unit.dayBuilt = gameState.turn.turnNumber; // which turn it was made. used to calculate remaining days.
		if(!unit.name){
			unit.name = findNextFreeRandomUnitName(unit.ownerIndex);
		}
	}
	gameState.units.push(unit);
}



function doBloodSplash(ep, splat = true){

	//////////////////
	// create splat trails explosion:
	ep.color = "#AA0000";
	ep.shapeMode = 1; // circles
	ep.initialSpeed = 6;
	ep.toFloor = 1;
	ep.fadeAtGround = 1;
	ep.life = 4;

	// different amount for different level units:
	if(ep.level == 1){
		ep.amount = 60;
	}else if(ep.level == 2){
		ep.amount = 70;
	}else if(ep.level == 3){
		ep.amount = 80;
	}else{
		ep.amount = 80; // for any other higher level in case more were added later.
	}
	createExplosion(ep);
	
	if(splat){
		//////////////////
		// create normal secondary explosion:
		ep.color = "#CC0000";
		ep.initialSpeed = 2;
		ep.upSpeedMulti = 0.6;
		ep.toFloor = 0;
		ep.fadeAtGround = 1;
		ep.life = 2;
		
		createExplosion(ep);
	}
	
	return ep;
}

function doMineExplosion(ep, speed = 6){

	//////////////////
	// create splat trails explosion:
	ep.color = "#FFFF00";
	ep.shapeMode = 1; // circles
	ep.initialSpeed = speed;
	ep.toFloor = 1;
	ep.fadeAtGround = 1;
	ep.life = 4;

	// different amount for different level units:
	if(ep.level == 1){
		ep.amount = 60;
	}else if(ep.level == 2){
		ep.amount = 70;
	}else if(ep.level == 3){
		ep.amount = 80;
	}else{
		ep.amount = 80; // for any other higher level in case more were added later.
	}
	createExplosion(ep);
	
	//////////////////
	// create normal secondary explosion:
	/*
	ep.color = "#FFFF00";
	ep.initialSpeed = 2;
	ep.upSpeedMulti = 0.6;
	ep.toFloor = 0;
	ep.fadeAtGround = 1;
	ep.life = 2;
	
	createExplosion(ep);
	*/
	
	return ep;
}



// {name: 'kill', q: 33, r: 44, level: 1, playerIndex: 1}
function makeExplosionBySoundMessage(data){

	//const { x, y } = axialToPixel(data.q, data.r);
	const x = axialToPixelX(data.q, data.r);
	const y = axialToPixelY(data.q, data.r);
	
	let level = 1;
	if(data.level){
		level = data.level;
	}
		
	let ep = {
		x: x,
		y: y,
		color: "#FFFFFF",
		shapeMode: 0,
		fadeMode: "slow",
		amount: 30,
		initialSpeed: 5,
		life: 1.3,
		decay: {min:0.01, max:0.03},
		rotationSpeed: {min:-0.2, max:0.2},
		level: level,
	};

	let doExplosion = 0;
	
	// NOTE: "diedByStarving" sound is sent only once, so its explosion
	//       is created in object_changed message.
	if(data.name === 'kill'){
		doExplosion = 0; // explosions are created here, dont call it again.
		ep = doBloodSplash(ep);
		
	}else if(data.name === 'silentDiedByStarving'){
		// no sound attached.
		doExplosion = 0; // explosions are created here, dont call it again.
		// same as diedByStarving explosion:
		createExplosion({
			type: "crossExplosion", // (death by starvation)
			x: x,
			y: y,
			color: "#FF0000",
			shapeMode: 1, // circles
			initialSpeed: 2,
			amount: 30,
			life: 2,
			decay: {min:0.005, max:0.015},
			fadeMode: "slow",
			rotationSpeed: {min:0, max:0},
		});
		
	}else if(data.name === 'killSimple'){ 
		// diedByStarving calls this and sends to ACTION.unit_removed to create explosion.
		// using crossExplosion to make the dying explosion.
		doExplosion = 0; // explosions are created here, dont call it again.
		ep.color = "#AA0000";
		ep.shapeMode = 1; // circles
		ep.initialSpeed = 6;
		ep.toFloor = 1;
		ep.fadeAtGround = 1;
		ep.life = 4;
		ep.amount = 20;
		
	}else if(data.name === 'boatExplosion'){
		doExplosion = 0;
		
		ep.color = "#ad896b"; // wood
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 5;
		ep.amount = 40;
		
		createExplosion(ep);
		
		doMineExplosion(ep, 3); // yellow stripes, lower range than mine explosion.
		
	}else if(data.name === 'killCastleSimple'){
		doExplosion = 1;
		
		ep.color = "#E3A7B6";
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 5;
		ep.amount = 20;
		
	}else if(data.name === 'claimMine'){
		doExplosion = 0; // explosions are created here, dont call it again.
		
		ep = doBloodSplash(ep);
		ep = doMineExplosion(ep);
		
	}else if(data.name === 'kill2'){
		doExplosion = 1;
		
		ep.color = "#AA0000";
		ep.shapeMode = 1; // circles
		ep.initialSpeed = 2;
		ep.upSpeedMulti = 0.6;
		ep.toFloor = 0;
		ep.fadeAtGround = 1;
		ep.life = 2;

		//ep.decay = {min:0.005, max:0.015};

		// different amount for different level units:
		if(ep.level == 1){
			ep.amount = 80;
		}else if(ep.level == 2){
			ep.amount = 90;
		}else if(ep.level == 3){
			ep.amount = 100;
		}else{
			ep.amount = 100; // for any other higher level in case more were added later.
		}
	}else if(data.name === 'killCastle'){
		doExplosion = 1;
		
		ep.color = "#E3A7B6";
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 5;

		// different amount for different level units:
		if(ep.level == 1){
			ep.amount = 40;
		}else if(ep.level == 2){
			ep.amount = 60;
		}else if(ep.level == 3){
			ep.amount = 80;
		}else{
			ep.amount = 80; // for any other higher level in case more were added later.
		}
	}else if(data.name === 'claimRock'){
		doExplosion = 0;
		
		ep.color = "#888888";
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 4;
		ep.amount = 40;
		
		createExplosion(ep);
		
		ep.color = "#666666";
		ep.initialSpeed = 1.5;
		ep.upSpeedMulti = 1;
		ep.toFloor = 0;
		ep.fadeAtGround = 1;
		ep.life = 2;
		ep.rotationSpeed = {min:0,max:0};
		ep.amount = 50;
		
		createExplosion(ep);

	}else if(data.name === 'claimGrass'){
		doExplosion = 1;
		
		ep.color = "#73923E";
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 2.5;
		ep.amount = 40;
	}else if(data.name === 'claimTree'){
		doExplosion = 1;
		
		ep.color = "#65A51D";
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 2.5;
		ep.amount = 50;
	}else if(data.name === 'sell'){
		doExplosion = 1;
		
		ep.color = "#FFFF00";
		ep.shapeMode = 1; // circles
		ep.initialSpeed = 5;

		// different amount for different level units:
		if(ep.level == 1){
			ep.amount = 20;
		}else if(ep.level == 2){
			ep.amount = 50;
		}else if(ep.level == 3){
			ep.amount = 80;
		}else if(ep.level == 4){
			ep.amount = 110;
		}else{
			ep.amount = 110; // for any other higher level in case more were added later.
		}
	}else if(data.name === 'build1' || data.name === 'build2' || data.name === 'build3'){
		doExplosion = 1;
		
		ep.level = parseInt(data.name[5], 10);
		
		let newcolor = "#FFFFFF";
		if(data.playerIndex !== -1){
			let player = getPlayerByIndex(data.playerIndex);
			let basecolor = darkenHexColor(blendHexColor(player.color, "#888888", 0.3), 0.3);
			if(ep.level == 1){
				// create darker and grayer hex color from player.color:
				newcolor = basecolor;
			}else if(ep.level == 2){
				newcolor = blendHexColor(basecolor, "#FFFFFF", 0.2);
			}else if(ep.level >= 3){
				newcolor = blendHexColor(basecolor, "#FFFFFF", 0.4);
			}
		}
		ep.color = newcolor;
		ep.shapeMode = 0; // triangles+squares
		ep.initialSpeed = 2;
		ep.amount = 60;
		ep.life = 2;
		ep.decay = {min:0.005, max:0.015};
		ep.fadeMode = "slow";
		ep.rotationSpeed = {min:0, max:0};
	}

	if(doExplosion){
		createExplosion(ep);
	}
}


function killUnit(unit){
	let arr = [];
	arr.push({ type: ACTION.unit_removed, unitId: unit.id, explosion: "boatExplosion" });
	arr.push({ type: ACTION.sound, name: "killBoat", q:0, r:0, playerIndex: -1, action: ACTION.unit_removed});
	return arr;
}



function killPlayerUnits(playerIndex){
	let arr = [];
	let soldiersKilled = 0;
	let castlesKilled = 0;
	for(let i = 0; i < gameState.units.length; i++){
		let unit = gameState.units[i];
		if(unit.ownerIndex === playerIndex){
			let explosion = "";
			if(unit.internalType === "castle"){
				explosion = "killCastleSimple";
				castlesKilled++;
			}else if(unit.internalType === "soldier"){
				explosion = "killSimple";
				soldiersKilled++;
			}
			arr.push({ type: ACTION.unit_removed, unitId: unit.id, explosion: explosion });
			//makeExplosionBySoundMessage
		}
	}
	if(soldiersKilled > 0){
		arr.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.player_killed});
	}
	if(castlesKilled > 0){
		arr.push({ type: ACTION.sound, name: "killCastle", q:0, r:0, playerIndex: -1, action: ACTION.player_killed});
	}
	return arr;
}


function killPlayerTiles(playerIndex){
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		if(tile.ownerIndex === playerIndex){
			tile.ownerIndex = -1; // remove ownership instantly, animate using deadOwnerIndex for color.
			tile.savings = 0;
			
			tile.isDying = true;
			tile.deadStartTime = performance.now();
			tile.deadOwnerIndex = playerIndex; // for animation texture/color.
		}
	}
}


// =================================================================
// --- GAME STATE SYNC (NETWORKING)
// =================================================================
//
// CLIENT-SIDE: Received data from host
//
function handleHostData(data) {
	let needsUIUpdate = false;
	
	//console.log("handleHostData: data.type = "+data.type);
	
	switch (data.type) {
		case ACTION.ping: {
			// respond to ping for the host:
			sendToHost({ type: ACTION.pong, time: Date.now(), playerIndex: getMyPlayer().playerIndex });
			console.warn("received ping from host.");
		}
		break;
		case ACTION.check_balance: {
			// called at the very last after action_move/action_build messages have been processed.
			if(isHost()){
				console.warn("handleHostData: check_balance");
				// checkPlayers
				console.warn(data.checkPlayers);
				
				//sendToHost({ type: ACTION.check_balance, checkPlayers: data.checkPlayers });
/*
				// this must be called AFTER all moves have been applied to the gameState.
				// sent after every important move player made (action_move/action_build).
				// check if soldiers will die due to negative balance: (savings+income)-wages
				
				for(let i = 0; i < action.checkPlayers.length; i++){
					// NOTE: findEconomyPools is HOST ONLY Function.
					let pools = findEconomyPools(action.checkPlayers[i]);
					let killdata = calculateBalanceAndKillSoldiers(pools);
					
					if(killdata.batchActions.length > 0){
						let batchActions = killdata.batchActions;
						let poolsAfter = killdata.poolsAfter;
						let poolsBefore = killdata.poolsBefore;
						actionForUndo.batchActions = batchActions;
						actionForUndo.poolsBefore = poolsBefore;
						updates.push(...batchActions); // TODO: should make this in multiple_actions instead.
						
						sounds.push({ type: ACTION.sound, name: "diedByStarving", q:0, r:0, playerIndex: -1, action: ACTION.action_move});
					}
				}
			*/
			}
		}
		break;
		case ACTION.multiple_actions: {
			console.warn("multiple_actions received: ");
			console.warn(data.actions);
			// handle batch of actions in one run, so there is less individual messages sent to clients.
			if(data.actions !== undefined && data.actions.length > 0){
				for(let i = 0; i < data.actions.length; i++){
					handleHostData(data.actions[i]);
				}
			}
			return; // dont process anything after.
		}
		break;
		case ACTION.game_start: {
			REPLAY_ENABLED = 0;
			
			GAME_START_TIME = msNowFloor();
			
			closeGameSettings();
			
			markDirty();
			gameState = data.state;
			
			// update localPlayer index (only valid after game starts, since players could be kicked before start):
			localPlayer.playerIndex = getPlayerIndex(localPlayer.id);

			
			// save initial gameState for replaying the games later.
			INITIAL_STATE = deepClone(gameState);
	
			showPage('game');
			
			
			updateGameUI();
			if(isMyTurn()){
				//centerAndSelectFirstUnit();
				// probably better to not select it, since if it was not my turn,
				// then its ambiguous which unit should be selected/centered,
				// so its more logical if none of the players gets unit selected at start.
				startZoomPos = centerFirstUnit(); // dont select unit, just center to it.
			}else{
				startZoomPos = centerFirstUnit(); // dont select unit, just center to it.
			}
			console.warn("startZoomPos");
			console.warn(startZoomPos);
			startZoom();
			
			addCurrentTurnChatMessage();
		}
		break;
		case ACTION.replay_start: {
			REPLAY_ENABLED = 1;
			
			GAME_START_TIME = msNowFloor();
			
			markDirty();
			gameState = data.state;
			showPage('game');
			updateGameUI();

			centerFirstUnit();
			
			if(isHost()){
				replayHistory(NETWORK_HISTORY);
			}
			
			console.warn("replay_start");
		}
		break;
		case ACTION.full_state: {
			// for spectators, send full state:
			gameState = data.state;
			console.warn("handleHostData full_state");
			
			if (!localPlayer.isSpectator) {
				localPlayer.isSpectator = true;
				localPlayer.color = SPECTATOR_COLOR;
				localPlayer.textColor = SPECTATOR_COLOR;
				spectatorUiMode();
				console.log("localPlayer");
				console.log(localPlayer);
				addSystemChatMessage("Joined as spectator");
				
				//alert("Game in progress. Joining as spectator.");
			}
			showPage('game');
			
			startZoomPos = centerFirstUnit();
			startZoom(true);
				
			updateGameUI();
		}
		break;
		case ACTION.player_changed: {
			console.warn("player_changed:");
			console.warn(data);
			
			let player = getPlayerByIndex(data.playerIndex);
			if(player){
				if(data.totalMines !== undefined){
					player.totalMines = data.totalMines;
				}
				if(data.totalBoats !== undefined){
					player.totalBoats = data.totalBoats;
				}
			}
		}
		break;
		case ACTION.settings_update: {
			console.warn("settings_update");
			
			// dont allow settings update if game has started.
			if(!gameStarted()){
				gameState.settings = data.settings;
				
				updateSettingsInputs();
				
				updateLobbyUI();
			}
		}
		break;
		case ACTION.lobby_update: {
			gameState.settings = data.settings;
			gameState.players = data.players;

			gameState.map = data.map;
			lobbyLoadedMapImg.src = data.map.imageData;
			
			
			updateSettingsInputs();

			
			updateLobbyUI();
		}
		break;
		case ACTION.map_update: {
			gameState.map = data.map;
			lobbyLoadedMapImg.src = data.map.imageData;
			updateLobbyUI();
		}
		break;
		case ACTION.chat: {
			data.message = data.message.slice(0, MAX_MESSAGE_LEN);
			if(data.fromPlayerIndex !== undefined){
				let fromPlayer = getPlayerByIndex(data.fromPlayerIndex);
				
				addChatMessage(fromPlayer.name, data.message, data.isSpectator, data.textColor);
				
				if(fromPlayer.playerIndex !== getMyPlayer().playerIndex){
					playSound("message");
				}
			}else{
				// not sure if this else is even possible...
				addChatMessage("", data.message, data.isSpectator, data.textColor);
				playSound("message");
			}
		}
		break;
		case ACTION.lobby_chat: {
			
			data.message = data.message.slice(0, MAX_MESSAGE_LEN);
			if(data.fromPlayerIndex !== undefined){
				let fromPlayer = getPlayerByIndex(data.fromPlayerIndex);
				
				addLobbyChatMessage(fromPlayer.name, data.message, data.isSpectator, data.textColor);
				
				if(fromPlayer.playerIndex !== getMyPlayer().playerIndex){
					playSound("message");
				}
			}else{
				addLobbySystemChatMessage(data.message);
			}
		}
		break;
		case ACTION.system_message:
			addSystemChatMessage(data.message);
			if(data.quittedPlayerIndex !== undefined){
				let player = getPlayerByIndex(data.quittedPlayerIndex);
				if(!player.isSpectator){
					if(!gameState.settings.gameOver){
						playSound("quit"); // dont play annoying quit sound if game already was over.
					}else{
						playSound("message");
					}
				}else{
					playSound("message");
				}
			}
		break;
		case ACTION.undo_counter: {
			let playerIndex = data.playerIndex;
			
			//console.warn("undo_counter");
			//console.warn(data);
			
			// if no playerIndex defined, it means reset.
			if(playerIndex === undefined){
				//console.warn("undo counter resetted");
				localPlayer.undoCounter = 0;
				undoBtn.classList.add("disabled");
				
			}else if(localPlayer.playerIndex === playerIndex){
				// update my undo counter:
				localPlayer.undoCounter = data.undoCounter;
				
				// enable/disable undo button:
				undoBtn.classList.remove("disabled");
				if(!localPlayer.undoCounter){
					undoBtn.classList.add("disabled");
				}
				//console.warn("undo counter updated: "+data.undoCounter);
			}
		}
		break;
		case ACTION.unit_unloaded: {
			if(data.unitId !== undefined){
				let unit = getUnitById(data.unitId);
	
				// unload the unit by removing loadedUnit:
				delete unit.loadedUnit;
				// set unloading unit as moved:
				unit.hasMoved = true;
				
				needsUIUpdate = true;
				updateHighlights();
			}
		}
		break;
		case ACTION.unit_loaded: {
			if(data.unitId !== undefined && data.targetUnitId !== undefined){
				let unit = getUnitById(data.unitId);
				let targetUnit = getUnitById(data.targetUnitId);
				// load the unit:
				targetUnit.loadedUnit = unit;
				
				needsUIUpdate = true;
				updateHighlights();
			}
		}
		break;
		case ACTION.tile_edited: {
			console.warn("tile_edited");
			let hex = data.hex;
			let type = data.tileType;
			
			if(!getTileAt(hex.q, hex.r)){
				setTileAt(hex.q, hex.r, {type:type, ownerIndex: -1, object: null, savings: 0});
			}else{
				let tile = getTileAt(hex.q, hex.r);
				tile.type = type;//tile.type === "water" ? "land" : "water";
				tile.ownerIndex = -1;
				tile.object = null;
				tile.savings = 0;
			}
			console.log("clicked hex: ");
			console.log(hex);
			console.log(getTileAt(hex.q, hex.r));

			updateTileAndNeighbourOutlines(hex.q, hex.r);
		}
		break;
		case ACTION.tile_changed: {
			const tile = getTileAt(data.q, data.r);
			if (tile) {
				let oldObject = tile.object;
				
				if (data.ownerIndex !== undefined){
					setTileOwnerByIndex(tile, data.ownerIndex);
					
					tile.isAppearing = true;
					tile.appearStartTime = performance.now();
					
					// delete dying animations, or else that would be rendered instead of claiming animation:
					delete tile.isDying;
					delete tile.deadStartTime;
					delete tile.deadOwnerIndex;
					
					// cant delete here because undo would fuck it up for not remembering the list of owners.
					//delete tile.objectOwnerIndexes;

				}
				// if savings were changed due to claiming tile; claimed tile will reset savings to zero.
				// NOT NEEDED FOR CLIENTS! clients doesnt need to know individual tiles savings.
				//if (data.savings !== undefined){
				//	tile.savings = data.savings;
				//}
				if (data.object !== undefined){
					tile.object = data.object;
					
					// for added mines:
					if(data.addedObjectOwnerIndex !== undefined){
						// initialize client side animation info:
						tile.creationTime = msNowFloor();
						tile.animationFinished = 0;
						tile.animationStyle = 2;
					}
				}
				
				// add new object owner:
				if(data.addedObjectOwnerIndex !== undefined){
					
					// clear old owners if there were no previous object (mine) set,
					//   or tile.objectOwnerIndexes was not set:
					if(!oldObject || tile.objectOwnerIndexes === undefined){
						tile.objectOwnerIndexes = [];
					}
					tile.objectOwnerIndexes.push(data.addedObjectOwnerIndex);
				}
				if(data.removedObjectOwnerIndex !== undefined){
					if(tile.objectOwnerIndexes !== undefined){
						tile.objectOwnerIndexes = tile.objectOwnerIndexes.filter(n => n !== data.removedObjectOwnerIndex);
						// delete info if no owners set after undo:
						if(tile.objectOwnerIndexes.length === 0){
							delete tile.objectOwnerIndexes;
						}
					}
				}
				
				
				// spawn Floating Text:
				if(data.FText !== undefined && data.FText > 0){ // only show non-zero values.
					spawnFloatingText({
						x: axialToPixelX(data.q, data.r),
						y: axialToPixelY(data.q, data.r),
						text: `+${data.FText}`,
						color: "yellow"
					});
				}
			}
			needsUIUpdate = true;
			updateHighlights();
			
			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.object_changed: {
			const tile = getTileAt(data.q, data.r);
			if (tile) {
				if (data.object !== undefined){
					tile.object = data.object;
					// remove previous mine object owners, since we replaced it with grass:
					if(data.object === 'grass'){
						delete tile.objectOwnerIndexes;
					}
					
					////////////////
					// create explosion if unit died:
					// associated sound is "diedByStarving" which is sent only once
					// so we have to create explosion here to get the coordinates.
					if(data.object === 'dead'){
						tile.actionTurnNumber = gameState.turn.turnNumber;
						
						const { x, y } = axialToPixel(data.q, data.r);
						
						let ep = {
							type: "crossExplosion", // (death by starvation)
							x: x,
							y: y,
							color: "#FF0000",
							shapeMode: 1, // circles
							initialSpeed: 2,
							amount: 30,
							life: 2,
							decay: {min:0.005, max:0.015},
							fadeMode: "slow",
							rotationSpeed: {min:0, max:0},
						};
						
						createExplosion(ep);
					}
				}
				
				if(data.animationStyle !== undefined){
					// initialize client side animation info:
					tile.creationTime = msNowFloor();
					tile.animationFinished = 0;
					tile.animationStyle = data.animationStyle;
				}
			}
			needsUIUpdate = true;
			
			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.unit_added: {
			let unit = data.unit;
			console.log("unit_added: gameState.units.push(data.unit);");
			console.log(unit);
			addUnit(unit);
			needsUIUpdate = true;
			updateHighlights();
			
			pushLastActionHexCheckParams(
				unit.ownerIndex, 
				data.wasUndo ?? 0, 
				unit.q, 
				unit.r, 
				unit.id, 
				"#FFFF00"
			);

			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.unit_removed: {
			
			let unit = getUnitById(data.unitId);
			
			// spawn Floating Text:
			if(data.FText !== undefined && data.FText > 0){ // only show non-zero values.
				spawnFloatingText({
					x: axialToPixelX(unit.q, unit.r),
					y: axialToPixelY(unit.q, unit.r),
					text: `+${data.FText}`,
					color: "yellow"
				});
			}
			
			if(data.explosion !== undefined){
				//sounds.push({name:'killCastle', q: targetUnit.q, r: targetUnit.r, action: action.type, level:targetUnit.level});
				makeExplosionBySoundMessage({name:data.explosion, q:unit.q, r:unit.r, action: ACTION.unit_removed, level: getUnitLevel(unit.type)});
			}
			
			// remove unit:
			gameState.units = gameState.units.filter(u => u.id !== data.unitId);
			
			needsUIUpdate = true;
			updateHighlights();

			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.player_kicked: {
			if(localPlayer.id === data.playerId){
				localPlayer.hasBeenKicked = true;
				console.warn("you have been kicked from the game");
				alert("you have been kicked from the game");
				showPage("start");
				return;
			}
		}
		break;
		case ACTION.game_over: {
			// show popup of winning player, and popup for losers.

			// winnerPlayerIndex is -1 if game was over when lost to an AI (no humans left in game): 
			let winnerPlayerIndex = data.winnerPlayerIndex;

			let myPlayer = getMyPlayer();
			let myIndex = myPlayer.playerIndex;
			gameState.settings.gameOver = true;
			
			console.warn("ACTION.game_over");
			
			if(!REPLAY_ENABLED){
			
				let fireworksEnabled = false;
				
				if(winnerPlayerIndex === myIndex){
					// you have won the game!
					// play win sound.
					fireworksEnabled = true;
					//playSound("victory");
					myPlayer.isWinner = true;
					endgamePopupTitle.textContent = "Victory!";
					endgamePopupMessage.textContent = "You have won the game!";
					endgamePopupTitle.style.color = "#FFFF00";
				}else{
					// you have lost the game!
					// play lose sound.
					fireworksEnabled = false;
					//playSound("defeat");
					endgamePopupTitle.textContent = "Defeat!";
					endgamePopupMessage.textContent = "You have been defeated!";
					endgamePopupTitle.style.color = "#FF0000";
				}
				
				// update stats:
				let myStats = data.allStats[myIndex]; // getPlayerStats(myIndex);
				endgamePopupStatsHexes.textContent = myStats.hexes;
				endgamePopupStatsSoldiers.textContent = myStats.soldiers;
				endgamePopupStatsWages.textContent = myStats.wages;
				endgamePopupStatsMoney.textContent = formatPoolDecimal(myStats.money);
				
				// wont work without this or requestAnimationFrame()
				//setTimeout(function(){
				//	openEndgamePopup();
				//}, 1);
				requestAnimationFrame(() => {
					openEndgamePopup(fireworksEnabled);
				});
			}
			
			updateGameUI();
		}
		break;
		case ACTION.player_killed: {
			let player = getPlayerByIndex(data.playerIndex);
			
			// cant check if(!player.isDead) here since it will be dead on host side immediately...
			// and it is required for checkaiturn function to be dead...
			//if(!player.isDead){
			player.isDead = true;
			
			// unsynced animations (clients wont get tile updates any other way):
			killPlayerTiles(data.playerIndex);
			// units will be killed with unit_removed messages by host, 
			//   so explosions will also be triggered for clients,
			//   and they will be removed properly for all players.
			//killPlayerUnits(data.playerIndex);

			addSystemChatMessage(`>>> Player ${player.name} has died!`, "#FFFFFF");
			//}
		}
		break;
		
		case ACTION.unit_load_reset: {
			const unit = gameState.units.find(u => u.id === data.unitId);
			if (unit) {
				delete unit.loadedUnit;
			}
			needsUIUpdate = true;
			updateHighlights();
			
			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.unit_move_reset: {
			const unit = gameState.units.find(u => u.id === data.unitId);
			if (unit) {
				unit.hasMoved = data.hasMoved;
			}
			needsUIUpdate = true;
			updateHighlights();
			
			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.unit_moved: {
			const unit = gameState.units.find(u => u.id === data.unitId);
			if (unit) {
				if(isTypeBoat(unit.type)){
					let startHex = {q:unit.q, r:unit.r};
					let endHex = {q:data.q, r:data.r};
					
					if(data.route !== undefined){
						// revert back to previous route when undoing:
						unit.route = data.route;
					}else{
						// calculate new route:
						unit.route = findFastestRoute(startHex, endHex, MAX_BOAT_MOVE_DIST);
					}
					console.warn("unit.route");
					console.warn(unit.route);
				}else{
					// store previous position for seeing from where they moved:
					if(data.pq !== undefined){
						unit.pq = data.pq;
						unit.pr = data.pr;
					}else{
						//delete unit.pq;
						//delete unit.pr;
					}
				}
	
				// set new position:
				unit.q = data.q;
				unit.r = data.r;
				unit.hasMoved = data.hasMoved;
				
				pushLastActionHexCheckParams(
					unit.ownerIndex, 
					data.wasUndo ?? 0, 
					unit.q, 
					unit.r, 
					unit.id, 
					"#FFFFFF"
				);
			}
			needsUIUpdate = true;
			updateHighlights();
			
			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.turn_changed: {
			gameState.turn.currentPlayerIndex = data.currentPlayerIndex;
			gameState.turn.turnNumber = data.turnNumber;
			
			clearLastActionMoves(gameState.turn.currentPlayerIndex);

			deselectUnit();
			//deselectHex();
			updateHighlights();
			updateGameUI();

			addCurrentTurnChatMessage();
			
			//updateLocalPoolsInfo();
		}
		break;
		case ACTION.sound: {
			let play = true;
			// dont play sounds for AI players:
			if(data.playerIndex && data.playerIndex !== -1){
				let player = getPlayerByIndex(data.playerIndex);
				if(player.isAI){
					play = false;
				}
			}
			if(play){
				playSound(data.name);
			}
			
			// create explosion based on which sound was received on which coordinate.
			if(data.action !== ACTION.action_undo){
				makeExplosionBySoundMessage(data);
			}
		}
		break;
		case ACTION.savings_update: {
			// this is kinda useless, since the client should calculate them themselves to get full array of pool hexes for being able to know which pool is clicked.
			//myCurrentSavings = data.total;
			let poolsInfo = data.poolsInfo; // array of pools savings/income/wages info.
			//playerSavings.textContent = myCurrentSavings;
			
			//console.warn("##############################################################################");
			//console.warn("##############################################################################");
			console.warn("## savings_update:");
			//console.warn("##############################################################################");
			//console.warn("##############################################################################");
			console.warn(data);
		
			// update local player pools for being able to select a pool and display its pool info:
			// todo: make sure the poolsInfo array matches with localPlayerPools array... could get glitchy if it was updated between send/receice commands??
			localPlayerPools = findEconomyPools(localPlayer.playerIndex);
			for(let p = 0; p < poolsInfo.length; p++){
				let poolInfo = poolsInfo[p];
				// update by copying to localPlayerPools:
				let pool = localPlayerPools[p];
				pool.totalIncome = poolInfo.totalIncome;
				pool.totalSavings = poolInfo.totalSavings;
				pool.totalWages = poolInfo.totalWages;
			}
			selectedPool = findSelectedPool(selectedHex);
			updateSelectedPoolUi();
			
			console.log("localPlayerPools:");
			console.log(localPlayerPools);
			console.log("selectedPool:");
			console.log(selectedPool);
		}
		break;
		case ACTION.start_game_check: {
			console.log("start_game_check");
			openSettingsCheck();
		}
		break;
	}
	
	// non-synced updates executed on every action:
	setProtectedTiles();
	
	
	if(!REPLAY_ENABLED){
		// add only these messages to NETWORK_HISTORY:
		switch (data.type) {
			case ACTION.chat:
				data.message = data.message.slice(0, MAX_MESSAGE_LEN);
				addNetworkHistory(data);
			break;
			case ACTION.tile_changed:
			case ACTION.object_changed:
			case ACTION.unit_added:
			case ACTION.unit_removed:
			case ACTION.unit_moved:
			case ACTION.player_killed:
			case ACTION.player_changed:
			case ACTION.game_over:
			//case ACTION.turn_changed: 
			case ACTION.sound: {
				//console.warn("XXYY: handleHostData:");
				//console.warn("XXYY: "+JSON.stringify(data));
				
				addNetworkHistory(data);
				
				// save game one last time when game ends:
				if(data.type === ACTION.game_over){
					if(gameSettings.autosave){
						saveGameToDB(gameState);
					}
				}
				//NETWORK_HISTORY.push({...data, _TS: new Date()});
			}
			break;
			case ACTION.turn_changed:
				//console.warn("XXYY: handleHostData:");
				//console.warn("XXYY: "+JSON.stringify(data));
				
				addNetworkHistory(data);
				//NETWORK_HISTORY.push({...data, _TS: new Date()});
				
				// Save this game state (for host and client)
				// note: clients doesnt have tile.savings etc defined, 
				//       but it shouldnt affect replaying the game.
				//       IT WILL make it unplayable though, so loading the game wont work.
				// maybe catch savings_update as well, so it will keep track of pools savings?
				//gameState.networkHistory = NETWORK_HISTORY;
				if(gameSettings.autosave){
					saveGameToDB(gameState);
				}
				
				//console.warn("XXYY: game saved, network history saved.");
			break;
		}
	}

	
	if (needsUIUpdate) {
		updateGameUI();
	}
}

// removed updateLocalPoolsInfo() since it broke the savings update. updateLocalPoolsInfo was originally fixing savings update when soldiers died, but i moved distributePoolSavings/updatePlayerSavings AFTER the units deaths/grass convert had been processed (after advanceToNextPlayer).
function updateLocalPoolsInfo(){
	// try to fix pools not updating wages when soldiers died etc...
	localPlayerPools = findEconomyPools(localPlayer.playerIndex);
	selectedPool = findSelectedPool(selectedHex);
	updateSelectedPoolUi();
}



//
// HOST-SIDE: Received data from a client
//
// NOTE: MUST use playerId (peerId) here, players array is not built yet when using this.
function handleClientData(peerId, data) {
	console.log("handleClientData");

	const player = getPlayer(peerId);
	if (!player) return;
	
	//console.log("handleClientData 2");
	
	switch (data.type) {
		case ACTION.pong: {
			// received answer from ACTION.ping
			let player = getPlayerByIndex(data.playerIndex);
			player.lastPong = data.time;
			console.warn("received pong from player "+player.name);
		}
		break;
		case ACTION.join:
			player.name = data.name;
			
			if (!gameStarted()) {
				let colors = getNextFreeColors();
				player.color = colors.color;
				player.textColor = colors.textColor;
				player.isSpectator = data.isSpectator;
			} else {
				player.color = "#FFFFFF";
				player.textColor = "#FFFFFF";
				player.isSpectator = true; // Always spectator if game in progress
			}
			// playerIndex updated at game_start message.
			
			console.warn("player joined: "+player.id);
			
			
			let specflag = player.isSpectator ? " as a spectator" : "";
			
			// If player "takes" a loaded name, update that
			if (data.loadedPlayerName) {
				const p = loadedGameState.players.find(lp => lp.name === data.loadedPlayerName);
				if (p) p.isTaken = true;
			}
			broadcastLobbyState();
			
			if(gameStarted()){
				addSystemChatMessage(`${player.name} has joined${specflag}.`, "#AAAAFF");
			}else{
				broadcast({
					type: ACTION.lobby_chat,
					message: `${player.name} has joined${specflag}.`,
				});
				playSound("join");
				//addLobbySystemChatMessage(`${player.name} has joined${specflag}.`);
			}
			break;
		case ACTION.player_update:
			if(data.name !== undefined){
				player.name = data.name;
			}
			if(data.color !== undefined){
				player.color = data.color;
			}
			if(data.textColor !== undefined){
				player.textColor = data.textColor;
			}
			if(data.textureType !== undefined){
				player.textureType = data.textureType;
			}
			
			//console.warn("player_update");
			//console.warn(data);
			//console.log(player);
			broadcastLobbyState();
			break;
		case ACTION.chat:
			data.message = data.message.slice(0, MAX_MESSAGE_LEN);
			broadcast({
				type: ACTION.chat,
				fromPlayerIndex: player.playerIndex,
				isSpectator: player.isSpectator,
				message: data.message,
				color: player.color,
				textColor: player.textColor,
			});
		break;
		case ACTION.lobby_chat:
			data.message = data.message.slice(0, MAX_MESSAGE_LEN);
			broadcast({
				type: ACTION.lobby_chat,
				fromPlayerIndex: player.playerIndex,
				isSpectator: player.isSpectator,
				message: data.message,
				color: player.color,
				textColor: player.textColor,
			});
		break;
		case ACTION.host_quit:
			console.warn("host has quit the game. showing popup to continue game or quit.");
		break;
		
		// All game actions
		case ACTION.action_sell:
		case ACTION.action_move:
		case ACTION.action_build:
		case ACTION.action_undo:
		case ACTION.action_end_turn:
		case ACTION.check_balance:
		case ACTION.action_build_object:
		case ACTION.action_load_unit:
		case ACTION.action_unload_unit:
		case ACTION.action_edit_tile:
			//console.log("handleClientData executeAction "+data.type);
			if (gameStarted()) {
				executeAction(peerId, data);
			}
			break;
	}
	
	
}


function addPlayer(player){
	player.playerIndex = gameState.players.length;
	player.isDead = false; // reset dead state.
	gameState.players.push(player);
}


// only used before game starts, and should be used only there.
// if a player needs to be kicked during game, then he should be set as a spectator and possibly muted too.
function removePlayer(peerId){
	gameState.players = gameState.players.filter(player => player.id !== peerId);
	rebuildPlayerIndexes();
}




function newPeer(myPeerId = null){
	if(myPeerId){
		console.log("newPeer(): myPeerId = "+myPeerId);
	}else{
		console.log("newPeer(): myPeerId = null");
		myPeerId = getUID(); // create new shorter id, so peerjs server wont create its own long id.
	}
	selectedServerIndex = parseInt(serverNameInput.value, 10);
	let selectedServer = serversList[selectedServerIndex];

	peer = new Peer(myPeerId, selectedServer.config);
	
	if(selectedServer.config.host){
		console.warn(`connecting to ${selectedServer.config.host}${selectedServer.config.path}`);
	}else{
		console.warn(`connecting to peerjs.com`);
	}
	console.warn(selectedServer.config);
}

// =================================================================
// --- PEERJS NETWORKING
// =================================================================
function initPeerJS() {
	try {
		// This peer is for clients, or for the host to override
		newPeer();

		peer.on('open', (id) => {
			myPeerId = id;
			
			// initializing when connection is opened. players list is not yet created.
			localPlayer.id = id;
			
			connectionStatus.textContent = 'Connected to server.';
			console.log('My peer ID is: ' + id);
			// Enable buttons
			hostBtn.disabled = false; // DOMContentLoaded sets to false so we can still host while waiting for connection.
			joinBtn.disabled = false;
			spectateBtn.disabled = false;
		});
		
		// NO 'connection' listener here. Clients don't accept connections.
		
		peer.on('error', (err) => {
			console.error('PeerJS Error:', err);
			connectionStatus.textContent = `Error: ${err.message}`;
			alert(`Connection Error: ${err.message}\nTry refreshing or check your connection.`);
		});
		
	} catch (err) {
		console.error("Failed to initialize PeerJS:", err);
		connectionStatus.textContent = "PeerJS failed to load. Use HTTPS.";
	}
}


function setupConnection(conn) {
	connections.set(conn.peer, conn); // must be here instantly or color/nick changes wont work.
	
	conn.on('open', () => {
		console.log(`Data connection opened with ${conn.peer}`);
		//connections.set(conn.peer, conn);

		// If we are host, add new player and send lobby state
		if (isHost()) {
			// HOST only, handle incoming joinings
			
			const newPlayer = {
				id: conn.peer,
				name: 'Joining...', // Will be updated by join message
				color: "gray",
				textColor: "gray",
				isSpectator: false,
				isAI: false,
				isDead: false,
			};
			//gameState.players.push(newPlayer);
			addPlayer(newPlayer);
			
			
			if (gameStarted()) {
				// Send full game state to new player (who will join as spec)
				conn.send({ 
					type: ACTION.full_state, 
					state: gameState,
				});
			} else {
				// Send lobby state
				conn.send({ 
					type: ACTION.lobby_update, 
					settings: gameState.settings, 
					players: gameState.players,
					map: gameState.map,
				});
			}
		}
	});
	
	
	conn.on('data', (data) => {
		if (isHost()) {
			handleClientData(conn.peer, data);
		} else {
			handleHostData(data);
		}
	});
	
	conn.on('close', () => {
		console.log(`Connection closed with ${conn.peer}`);
		connections.delete(conn.peer);
		if (isHost()) {
			const player = getPlayer(conn.peer);
			if (player) {
				let specflag = player.isSpectator ? " (spectator)" : "";
				//addSystemChatMessage(`&gt; ${player.name}${specflag} has left.`, "#FFFF00");
				//gameState.players = gameState.players.filter(p => p.id !== conn.peer);
				
				if (gameStarted()) {
					
					addSystemChatMessage(`>>> ${player.name}${specflag} has left.`, "#FFFF00");
					if(!player.isSpectator){
						if(!gameState.settings.gameOver){
							playSound("quit"); // dont play annoying quit sound if game already was over.
						}else{
							playSound("message");
						}
					}else{
						playSound("message");
					}
					
					// set quitted player as AI:
					gameState.players = gameState.players.map(p =>
						//p.id === conn.peer ? { ...p, isSpectator: true, quitted: true } : p
						p.id === conn.peer ? { ...p, isSpectator: false, quitted: false, isAI: true } : p
					);
					// let others play if quitter was in turn:
					if(conn.peer == gameState.players[gameState.turn.currentPlayerIndex].id){
						addSystemChatMessage(`>>> ${player.name}${specflag} has been set as AI player.`, "#FFFF00");
						//advanceToNextPlayer();
						checkForAITurn(); // start AI turn if it is his turn.
					}else{
						updateGameUI();
					}
				} else {
					
					// set quitted player as spectator:
					gameState.players = gameState.players.map(p =>
						p.id === conn.peer ? { ...p, isSpectator: true, quitted: true } : p
					);
					broadcastLobbyState();
				}
			}
		} else {
			if(!localPlayer.hasBeenKicked){
				// We were disconnected from host
				//alert('Disconnected from host. Returning to start page.');
				console.warn('Disconnected from host. Returning to start page.');
				addSystemChatMessage(">>> Host has left the game. Game is now unplayable.", "#FFFF00");
				if(!gameState.settings.gameOver){
					playSound("quit"); // dont play annoying quit sound if game already was over.
				}else{
					playSound("message");
				}
			}else{
				playSound("quit");
			}

		}
	});
}


// todo: make without reloading the page but instead reset the gamestate to what it was at start of the game.
function restartGame(){
	location.reload();
}




let PING_INTERVAL = 5000; // 5 seconds
let TIMEOUT_TIME = 30000; // 30 seconds
let TIMEOUT_MSG_TIME = PING_INTERVAL+1000;

function checkPlayersTimeouts(){
	let batchActions = [];
	let killedCurrentTurnPlayer = false;
	
	for(let i = 0; i < gameState.players.length; i++){
		let player = gameState.players[i];
		if(!player.isAI && player.lastPong && !player.isDead){
			let timeDiff = Date.now()-player.lastPong;
			if(timeDiff > TIMEOUT_MSG_TIME){
				if(!player.timeoutMessaged){
					player.timeoutMessaged = true;
					broadcast({ type: ACTION.system_message, message: ">>> Player "+player.name+" has timed out, 30 seconds until disconnection." });
				}
			}else{
				player.timeoutMessaged = false;
			}
			if(timeDiff > TIMEOUT_TIME){
				broadcast({ type: ACTION.system_message, message: ">>> Player "+player.name+" has been disconnected and set as AI player.", quittedPlayerIndex: player.playerIndex });
				
				//console.warn("player "+player.name+" has timed out. setting player as dead.");
				// kill player and set player.isDead = true :
				// removed because it kinda sucks if the player units disappears... makes it too easy.
				//batchActions.push(...killPlayer(player.playerIndex));
				
				//player.isDead = true;
				player.isAI = true;
				//player.disconnected = true;
				if(gameState.turn.currentPlayerIndex === player.playerIndex){
					checkForAITurn();
				}
				

				// if player was in turn:
				//if(gameState.turn.currentPlayerIndex === player.playerIndex){
				//	killedCurrentTurnPlayer = true;
				//}
			}
		}
	}
	
	// if player was in turn:
	if(killedCurrentTurnPlayer){
		advanceToNextPlayer();
		//////////////////////////////////
		// Distribute final savings
		//distributePoolSavings(pools);
		//updatePlayerSavings(playerIndex); // Update savings *after* calcs
		
		batchActions.push({ 
			type: ACTION.turn_changed, 
			currentPlayerIndex: gameState.turn.currentPlayerIndex, 
			turnNumber: gameState.turn.turnNumber 
		});
	}
	
	if(batchActions.length > 0){
		broadcast({ 
			type: ACTION.multiple_actions, 
			actions: batchActions,
		});
	}
	

	// if player was in turn:
	if(killedCurrentTurnPlayer){
		// --- 6. Check for AI turn ---
		// NEW: This will now start the AI's sequential turn
		checkForAITurn(); // start AI turn if it is his turn.
	}
}



let pingIntervalId = null;

// host function to start pinging all connected clients.
function startPinging(){
	if (pingIntervalId !== null) return; // already running

	pingIntervalId = setInterval(() => {
		checkPlayersTimeouts();
		broadcast({
			type: ACTION.ping, // clients sends ACTION.pong in response.
			time: Date.now()
		}, false); // everyone = false = dont send to host too.
	}, PING_INTERVAL);
}

// not used yet since you cant quit other way than refreshing page.
function stopPinging(){
	if (pingIntervalId === null) return;

	clearInterval(pingIntervalId);
	pingIntervalId = null;
}


// Helper function for joinGame
function executeJoin(hostPeerId) {
	console.log(`Attempting to connect to host: ${hostPeerId}`);
	const conn = peer.connect(hostPeerId);
	
	conn.on('open', () => {
		console.log(`Connected to host: ${hostPeerId}`);
		setupConnection(conn);
		
		// Send our initial join info
		let colors = getNextFreeColors();
		conn.send({
			type: ACTION.join,
			name: localPlayer.name,
			color: colors.color,
			textColor: colors.textColor,
			isSpectator: localPlayer.isSpectator
		});
		
		// Go to lobby page
		lobbyPlayerNameInput.value = localPlayer.name.trim();
		lobbyRoomNameTitle.textContent = `Joined: ${hostPeerId}`; // Use the ID we joined
		
		pushLobbySystemChatMessage("--- Beginning of the chat ---", "#FF0");
		showPage('lobby');
	});
	
	conn.on('error', (err) => {
		console.error('Connection failed:', err);
		alert(`Failed to connect to room: ${hostPeerId}\nCheck the ID and try again.`);
	});
}

function joinGame(isSpectator) {
	localPlayer.isSpectator = isSpectator;
	localPlayer.name = playerNameInput.value;
	if (isSpectator) {
		localPlayer.color = SPECTATOR_COLOR;
		localPlayer.textColor = SPECTATOR_COLOR;
		spectatorUiMode();
		addSystemChatMessage("Joined as spectator");
	}
	
	hostPeerId = gameNameInput.value.trim();
	if (!hostPeerId) {
		alert('Please enter a Game Room Name (which is the Host\'s ID).');
		return;
	}
	
	if (!isValidName(playerNameInput.value)) {
		alert("Player name cannot be empty.");
		return;
	}
	
	if (!peer || peer.destroyed) {
		console.log("Peer is destroyed, re-initializing for join.");
		initPeerJS(); // Re-init
		// Need to wait for 'open'
		peer.on('open', () => {
			console.log("Re-initialized peer, now joining.");
			executeJoin(hostPeerId);
		});
		return;
	}
	
	executeJoin(hostPeerId);
}


function hostGame() {
	const gameName = gameNameInput.value.trim();
	if (!gameName) {
		alert("Please enter a Game Room Name.");
		return;
	}
	if (!isValidName(playerNameInput.value)) {
		alert("Player name cannot be empty.");
		return;
	}
	
	if (peer) {
		peer.destroy();
	}
	
	console.log(`Attempting to host with ID: ${gameName}`);
	try {
		//peer = new Peer(gameName, { debug: 2 });
		newPeer(gameName);

		peer.on('open', (id) => {
			// HOST only
			myPeerId = id;
			localPlayer.id = id;
			localPlayer.isHost = true;
			localPlayer.name = playerNameInput.value;
			
			let colors = getNextFreeColors();
			localPlayer.color = colors.color;
			localPlayer.textColor = colors.textColor;
			hostPeerId = myPeerId;
			
			// Use the desired ID, not the one from the 'open' event (which should be the same)
			gameState.settings.roomName = gameName;
			// This was the line overwriting your input, it's now correct.
			gameNameInput.value = gameName; 
			hostRoomPlayerNameInput.value = localPlayer.name;
			hostRoomNameTitle.textContent = `Hosting: ${gameName}`;
			
			// enable settings inputs for host:
			treePercentSlider.disabled = false;
			rockPercentSlider.disabled = false;
			minePercentSlider.disabled = false;

			// not possible to type on the percent inputs yet...
			treePercentText.disabled = true;
			rockPercentText.disabled = true;
			minePercentText.disabled = true;
			
			startMoneyPerHexInput.disabled = false;
			gameEndRuleList.disabled = false;
			mapThemeList.disabled = false;
	
			
			// Reset player list and add host
			gameState.players = []; 

			addPlayer(localPlayer);
			
			// make sure settings inputs match gameState.settings:
			updateSettingsInputs();
		
			let server = getSelectedServer();
			console.log(server);
			
			// todo: You could also send a DELETE /unregister-game request when the host manually closes the game.
			
			// only allow games list on servers that is possible:
			if(server.serverListEnabled){
				fetch(`${server.fetchUrl}/register-game`, {
				  method: 'POST',
				  headers: { 'Content-Type': 'application/json' },
				  body: JSON.stringify({
					peerId: localPlayer.id,
					name: gameName,
					appName: APP_NAME,
					hostName: localPlayer.name,
					maxPlayers: 400, // todo: allow changing this some day.
				  }),
				});
			}
			
			startPinging();

			pushLobbySystemChatMessage("--- Beginning of the chat ---", "#FF0");
			
			updateHostLobbyUI();
			showPage('host');
			connectionStatus.textContent = `Hosting at ${gameName}. Ready for players.`;
		});
		
		// Host MUST listen for connections
		peer.on('connection', (conn) => {
			console.log('Incoming connection from', conn.peer);
			setupConnection(conn);
		});
		
		peer.on('error', (err) => {
			console.error('PeerJS Error:', err);
			connectionStatus.textContent = `Error: ${err.message}`;
			if (err.type === 'unavailable-id') {
				alert(`Game Room "${gameName}" is already taken. Please choose another name.`);
				showPage('start');
				peer.destroy();
				initPeerJS(); // Re-init with a random client ID
			}
		});
		
	} catch (err) {
		console.error("Failed to initialize host PeerJS:", err);
		connectionStatus.textContent = "PeerJS failed to load. Use HTTPS.";
	}
}



// generates svg for hexagon with color.
function hexagonSVG(color, size = 35){
	let targetSize = size;
	let aspectRatio = 175/200;
	let targetWidth = targetSize;
	let targetHeight = targetSize*aspectRatio;
	let width = 200;
	let height = 175;
	let points = [[50,0],[150,0],[200,87],[150,174],[50,174],[0,87]];
	let pointsArr = [];
	for(let p = 0; p < points.length; p++){
		let x = points[p][0]/width*targetWidth;
		let y = points[p][1]/height*targetHeight;
		pointsArr.push(x+","+y);
	}
	let pointsStr = pointsArr.join(" ");
	
	return `<svg width="${targetWidth}" height="${targetHeight}" viewBox="0 0 ${targetWidth} ${targetHeight}" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Hexagon"><polygon points="${pointsStr}" fill="${color}"/></svg>
`;
}



hostPlayerList.addEventListener('click', (event) => {
	const item = event.target.closest('.ai-player-item');
	if (!item) return; // ignore clicks outside .ai-player-item

	const peerId = item.dataset.peer;
	
	const confirmed = confirm("Are you sure you want to kick this player?");
	if (!confirmed) return;

	kickPlayer(peerId);
});


playerUIList.addEventListener('click', (event) => {
	const item = event.target.closest('.ai-player-item');
	if (!item) return; // ignore clicks outside .ai-player-item

	const peerId = item.dataset.peer;
	
	const confirmed = confirm("Are you sure you want to kick this player?");
	if (!confirmed) return;

	kickPlayer(peerId);
});



function kickPlayer(peerId){
	if(!isHost()) return;
	
	const allPlayers = document.querySelectorAll('.player-list-item');
	allPlayers.forEach(playerElem => {
		if (playerElem.dataset.peer === peerId) {
			playerElem.remove(); // remove from DOM
		}
	});
	
	// send kick message and close connection, if the player has connection (is not AI):
	let conn = connections.get(peerId);
	if (conn){
		conn.send({ 
			type: ACTION.player_kicked, 
			playerId: peerId,
		});
		// disconnect player after one second,
		//   so the kick message will be delivered before closing connection:
		setTimeout(() => {
			conn.close();
			connections.delete(peerId);
		}, 1000);
	}

	if(gameState.settings.gameStarted){
		// if ingame, set as AI player when kicking.
		let player = getPlayer(peerId);
		let specflag = player.isSpectator ? " (spectator)" : "";
		if(!player.isSpectator && !player.isDead){
			player.isAI = true;
			
			addSystemChatMessage(`>>> ${player.name}${specflag} has been kicked and set as AI player.`, "#FFFF00");
			
			// let others play if quitter was in turn:
			if(peerId == gameState.players[gameState.turn.currentPlayerIndex].id){
				checkForAITurn(); // start AI turn if it is his turn.
			}else{
				updateGameUI();
			}
		}else if(player.isSpectator){
			addSystemChatMessage(`>>> ${player.name}${specflag} has been kicked from the game.`, "#FFFF00");
			updateGameUI();
		}
	}else{
		removePlayer(peerId);
	}

	
	broadcastLobbyState();
}


// =================================================================
// --- LOBBY UI & LOGIC
// =================================================================
function updateJoinedPlayersText(){
	document.querySelectorAll('.joined-players-text').forEach(el => {
		el.textContent = `Players (${gameState.players.length}):`;
	});
}

function updateHostLobbyUI() {
	updateJoinedPlayersText();
	
	updateHostPreviewTile(getMyPlayer().color);
	
	// for host player:
	hostPlayerList.innerHTML = '';
	const usedColors = [];
	gameState.players.forEach(p => {
		if(!p.quitted){
			const item = document.createElement('div');
			item.className = 'player-list-item';
			item.dataset.peer = p.id;
			//if(p.isAI){
			if(p.id	!== localPlayer.id){
				item.classList.add("ai-player-item");
			}
			//}
			let specTag = p.isSpectator ? ' (spec)' : '';
			item.style.color = p.isSpectator ? SPECTATOR_COLOR : p.textColor;
			item.textContent = `${p.name}${specTag}`;
			hostPlayerList.appendChild(item);
			if (p.color) usedColors.push(p.color);
		}
	});


	// update startplayer list:
	startPlayerList.innerHTML = '';

	const option1 = document.createElement("option");
	option1.value = -1; // random player
	option1.textContent = "(Random)";
	startPlayerList.appendChild(option1);

	// Add each player:
	gameState.players.forEach(player => {
		if(!player.quitted && !player.isSpectator){
			const option = document.createElement("option");
			option.value = player.id; // must use ID since playerIndex changes when kicking players.
			option.textContent = player.name;
			if(player.id === gameState.settings.startPlayerId){
				option.selected = true;
			}
			startPlayerList.appendChild(option);
		}
	});

	
	// Update color picker
	hostRoomColorPicker.innerHTML = '';
	if (localPlayer.isSpectator || loadedGameState) {
		hostRoomColorPicker.style.display = "none";
		hostRoomColorPickerMsg.style.display = "block";
		hostPreviewTile.style.display = "none";
		hostPreviewTileMsg.style.display = "block";
		hostTextureType.style.display = "none";
		hostTextureTypeMsg.style.display = "block";
	} else {
		hostRoomColorPicker.style.display = "flex";
		hostRoomColorPickerMsg.style.display = "none";
		hostPreviewTile.style.display = "block";
		hostPreviewTileMsg.style.display = "none";
		hostTextureType.style.display = "block";
		hostTextureTypeMsg.style.display = "none";
		
		//console.log("usedColors");
		//console.log(usedColors);
		PLAYER_COLORS.forEach(colorInfo => {
			const box = document.createElement('div');
			box.className = 'color-box';
			box.style.backgroundColor = colorInfo.color;
			
			if (localPlayer.color === colorInfo.color) {
				box.classList.add('selected');
			}
			if (usedColors.includes(colorInfo.color) && localPlayer.color !== colorInfo.color) {
				//console.log(usedColors);
				box.classList.add('disabled');
			} else {
				box.onclick = () => {
					//console.log("tried to change color");
					//hostCustomColorPicker.value = colorInfo.color;
					updateHostPreviewTile(colorInfo.color);
					
					updatePlayerColor(colorInfo.color, colorInfo.textColor);
				};
			}
			hostRoomColorPicker.appendChild(box);
		});
	}
}


function updatePlayerColor(color, textColor){
	localPlayer.color = color;
	localPlayer.textColor = textColor;

	sendToHost({
		type: ACTION.player_update,
		//name: localPlayer.name,
		color: localPlayer.color,
		textColor: localPlayer.textColor,
	});
	updateLobbyUI(); // Re-render
}



function updateLobbyUI() {
	updateJoinedPlayersText();
	
	updateLobbyPreviewTile(getMyPlayer().color);

	// Update settings info
	lobbyRoomNameTitle.textContent = `Joined: ${gameState.settings.roomName}`;
	lobbyMapSize.textContent = `${gameState.settings.mapWidth} x ${gameState.settings.mapHeight}`;
	lobbyStartMoney.textContent = `${gameState.settings.startingMoney} G`;
	lobbyMapScale.value = gameState.settings.mapScale;
	
	// Update player list for non-host players:
	lobbyPlayerList.innerHTML = '';
	const usedColors = [];
	gameState.players.forEach(p => {
		if(!p.quitted){
			const item = document.createElement('div');
			item.className = 'player-list-item';
			let specTag = p.isSpectator ? ' (spec)' : '';
			item.style.color = p.isSpectator ? SPECTATOR_COLOR : p.textColor;
			item.textContent = `${p.name}${specTag}`;
			lobbyPlayerList.appendChild(item);
			if (p.color) usedColors.push(p.color);
		}
	});
	
	
	
	// update startplayer list:
	lobbyStartPlayerList.innerHTML = '';

	const option1 = document.createElement("option");
	option1.value = -1; // random player
	option1.textContent = "(Random)";
	lobbyStartPlayerList.appendChild(option1);
	
	// Add each player:
	gameState.players.forEach(player => {
		if(!player.quitted && !player.isSpectator){
			const option = document.createElement("option");
			option.value = player.id; // must use ID since playerIndex changes when kicking players.
			option.textContent = player.name;
			if(player.id === gameState.settings.startPlayerId){
				option.selected = true;
			}
			lobbyStartPlayerList.appendChild(option);
		}
	});



	// Update color picker
	lobbyColorPicker.innerHTML = '';
	if (localPlayer.isSpectator) {
		lobbyColorPicker.style.display = "none";
		lobbyColorPickerMsg.style.display = "block";
		lobbyPreviewTile.style.display = "none";
		lobbyPreviewTileMsg.style.display = "block";
		lobbyTextureType.style.display = "none";
		lobbyTextureTypeMsg.style.display = "block";
	} else {
		lobbyColorPicker.style.display = "flex";
		lobbyColorPickerMsg.style.display = "none";
		lobbyPreviewTile.style.display = "block";
		lobbyPreviewTileMsg.style.display = "none";
		lobbyTextureType.style.display = "block";
		lobbyTextureTypeMsg.style.display = "none";
		
		//console.log("usedColors");
		//console.log(usedColors);
		PLAYER_COLORS.forEach(colorInfo => {
			const box = document.createElement('div');
			box.className = 'color-box';
			box.style.backgroundColor = colorInfo.color;
			
			if (localPlayer.color === colorInfo.color) {
				box.classList.add('selected');
			}
			if (usedColors.includes(colorInfo.color) && localPlayer.color !== colorInfo.color) {
				//console.log(usedColors);
				box.classList.add('disabled');
			} else {
				box.onclick = () => {
					//console.log("tried to change color");
					//lobbyCustomColorPicker.value = colorInfo.color;
					updateLobbyPreviewTile(colorInfo.color);
					
					updatePlayerColor(colorInfo.color, colorInfo.textColor);
				};
			}
			lobbyColorPicker.appendChild(box);
		});
	}
}


function broadcastSettings(){
	if (!isHost()) return;
	
	updateHostLobbyUI();
	// Send to all clients
	broadcast({
		type: ACTION.settings_update,
		settings: gameState.settings,
	});
}


function broadcastLobbyState(settings = gameState.settings, players = gameState.players, map = gameState.map) {
	if (!isHost()) return;
	// Update host's own UI
	updateHostLobbyUI();
	// Send to all clients
	broadcast({
		type: ACTION.lobby_update,
		settings: gameState.settings,
		players: gameState.players,
		map: gameState.map,
	});
}

function broadcastMapState() {
	if (!isHost()) return;
	// Update host's own UI
	updateHostLobbyUI();
	// Send to all clients
	broadcast({
		type: ACTION.map_update,
		map: gameState.map,
	});
}

// =================================================================
// --- INDEXEDDB
// =================================================================

// db to store games in roomName key
function initDB() {
	const request = indexedDB.open(DB_NAME, DB_VERSION_NUMBER);
	
	request.onerror = (e) => {
		console.error("IndexedDB saved games error:", e.target.errorCode);
	};
	
	request.onsuccess = (e) => {
		db = e.target.result;
		console.log("IndexedDB saved games initialized.");
		console.log(db);
	};
	
	request.onupgradeneeded = (e) => {
		let db = e.target.result;
		if (!db.objectStoreNames.contains(DB_STORE_NAME)) {
			db.createObjectStore(DB_STORE_NAME, { keyPath: 'roomName' });
		}
		if (!db.objectStoreNames.contains(DB_STORE_NAME_MAPS)) {
			db.createObjectStore(DB_STORE_NAME_MAPS, { keyPath: 'mapName' });
		}
	};
}




async function getAllSavedMaps() {
	return new Promise((resolve, reject) => {
		if (!db) {
			resolve(null); // no saves to be found
			return;
		}

		const transaction = db.transaction([DB_STORE_NAME_MAPS], 'readonly');
		const objectStore = transaction.objectStore(DB_STORE_NAME_MAPS);
		const getAllRequest = objectStore.getAll();

		getAllRequest.onsuccess = (event) => {
			const allSavedMaps = event.target.result;

			// Sort saves by saveDate (newest first)
			//allSaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
			allSavedMaps.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
			
			resolve(allSavedMaps); // return array of saved games.
		};

		getAllRequest.onerror = (e) => {
			console.error('Error loading map:', e.target.error);
			resolve(null); // no saves to be found
		};
	});
}



async function getAllSavedGames() {
	return new Promise((resolve, reject) => {
		if (!db) {
			resolve(null); // no saves to be found
			return;
		}

		const transaction = db.transaction([DB_STORE_NAME], 'readonly');
		const objectStore = transaction.objectStore(DB_STORE_NAME);
		const getAllRequest = objectStore.getAll();

		getAllRequest.onsuccess = (event) => {
			const allSaves = event.target.result;
			
			let allPlaySaves = getPlaySaves(allSaves);

			// Sort saves by saveDate (newest first)
			//allSaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
			allPlaySaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
			
			resolve(allPlaySaves); // return array of saved games.
		};

		getAllRequest.onerror = (e) => {
			console.error('Error loading game:', e.target.error);
			resolve(null); // no saves to be found
		};
	});
}

function getSaveType(roomName){
	let parts = roomName.split("-");
	return parts[0];
}
function getSaveRoomKey(roomName){
	let parts = roomName.split("-");
	return parts[1];
}

function getPlaySaves(allSaves){
	let allPlaySaves = [];
	for(let i = 0; i < allSaves.length; i++){
		let save = allSaves[i];
		if(getSaveType(save.roomName) === "play"){
			allPlaySaves.push(save);
		}
	}
	return allPlaySaves;
}

function pruneOldSaves(maxSaves = 10) {
	if (!db) return;

	const transaction = db.transaction([DB_STORE_NAME], 'readwrite');
	const objectStore = transaction.objectStore(DB_STORE_NAME);

	// Get all saved games
	const getAllRequest = objectStore.getAll();

	getAllRequest.onsuccess = (event) => {
		const allSaves = event.target.result;
		
		let allPlaySaves = getPlaySaves(allSaves);

		// Sort saves by saveDate (newest first)
		//allSaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));
		allPlaySaves.sort((a, b) => new Date(b.saveDate) - new Date(a.saveDate));

		// If there are more than maxSaves, delete the oldest ones
		if (allPlaySaves.length > maxSaves) {
			const savesToDelete = allPlaySaves.slice(maxSaves);

			savesToDelete.forEach((save) => {
				const deleteRequest1 = objectStore.delete("init-"+getSaveRoomKey(save.roomName));
				deleteRequest1.onsuccess = () => {
					console.warn('Deleted old save:', save.roomName);
				};
				const deleteRequest2 = objectStore.delete("play-"+getSaveRoomKey(save.roomName));
				deleteRequest2.onsuccess = () => {
					console.warn('Deleted old save:', save.roomName);
				};
			});
		}
	};
}


// get date like "12.11.2025 - 09:45:03" from saved new Date().toISOString() from db.
function formatReadableDate(isoString) {
	const date = new Date(isoString);
	const pad = (n) => n.toString().padStart(2, '0');

	const day = pad(date.getDate());
	const month = pad(date.getMonth() + 1);
	const year = date.getFullYear();
	const hours = pad(date.getHours());
	const minutes = pad(date.getMinutes());
	const seconds = pad(date.getSeconds());

	return `${day}.${month}.${year} - ${hours}:${minutes}:${seconds}`;
}



function formatDateForSave() {
	const now = new Date();

	const pad = (n) => n.toString().padStart(2, '0');

	const year = now.getFullYear();
	const month = pad(now.getMonth() + 1);
	const day = pad(now.getDate());
	const hours = pad(now.getHours());
	const minutes = pad(now.getMinutes());
	const seconds = pad(now.getSeconds());

	return `${year}${month}${day}_${hours}${minutes}${seconds}`;
}



//let currentFormattedDate = formatDateForSave(); // updated at startGame() to get precise date of start time.

// used to identify which window/user saved the game first. if duplicate entry, this is checked.
let SESSION_ID = getUID();



async function compressString(str) {
	const encoder = new TextEncoder();
	const data = encoder.encode(str);

	const cs = new CompressionStream("gzip");
	const writer = cs.writable.getWriter();
	writer.write(data);
	writer.close();

	const compressed = await new Response(cs.readable).arrayBuffer();
	
	return new Uint8Array(compressed);   // store this in IndexedDB
}


async function decompressToString(uint8) {
	const ds = new DecompressionStream("gzip");
	const writer = ds.writable.getWriter();
	writer.write(uint8);
	writer.close();

	const decompressed = await new Response(ds.readable).arrayBuffer();
	return new TextDecoder().decode(decompressed);
}


// prepare state for save, delete unnecessary keys and set animations finished.
function prepareSavedGameState(state){
	console.warn("prepareSavedGameState state:");
	console.warn(state);
	
	delete state.map.tiles;
	
	//for(let i = 0; i < state.map.tilesData.length; i++){
	for(let i = state.map.tilesData.length-1; i >= 0; i--){
		let tile = state.map.tilesData[i];
		if(tile.type === 'water'){
			// remove all water tiles:
			state.map.tilesData.splice(i, 1);
			continue;
		}else{
			delete tile.neighbours;
			delete tile.isProtected;
			delete tile.outline;
			// for object animations:
			delete tile.animationFinished;
			delete tile.animationStyle;
			delete tile.creationTime;
			// for hex dying animations:
			delete tile.isDying;
			delete tile.deadStartTime;
			delete tile.deadOwnerIndex;
			// for hex appearing animations:
			delete tile.isAppearing;
			delete tile.appearStartTime;
		}
	}
	
	for(let i = 0; i < state.units.length; i++){
		let unit = state.units[i];
		delete unit.animationFinished;
		delete unit.animationStyle;
		delete unit.creationTime;
		delete unit.wasSpawned;
	}

	return state;
}


// rebuilds all deleted keys
//////////////////////////////
// NOTE: savings arent updated for clients, so loading game wont work for them...
function prepareLoadedGameState(state){
	// set map.tiles (must be set before setTileAt() etc calls):
	state.map.tiles = {};
	for(let t = 0; t < state.map.tilesData.length; t++){
		let tile = state.map.tilesData[t];
		state.map.tiles[`${tile.q},${tile.r}`] = t;
	}
	// set neighbours:
	for(let t = 0; t < state.map.tilesData.length; t++){
		const tile = state.map.tilesData[t];
		// set tile.neighbours:
		if(tile.type === "land"){
			setTileNeighbours(tile, state);
		}
		// set tile.outline:
		updateTileOutlines(tile.q, tile.r, false, state);
	}
	return state;
}


async function saveGameToDB(gameState) {
	if(!db) return;
	if(REPLAY_ENABLED) return;
	if(getMyPlayer().isSpectator) return;
	
	let saveDate = new Date().toISOString();
	
	let initialStateToSave = {
		// initial state is never modified, so its safe to leave json parse out.
		initialState: prepareSavedGameState(deepClone(INITIAL_STATE)), 
		roomName: "init-"+gameState.settings.currentFormattedDate, 
		saveDate: saveDate,
		SESSION_ID: SESSION_ID,
	};
	

	let stateToSave = {
		// Create a deep clones to store, in case the objects gets modified while transaction:
		gameState: prepareSavedGameState(deepClone(gameState)),
		networkHistory: deepClone(NETWORK_HISTORY),
		
		// roomName key is used for db key:
		roomName: "play-"+gameState.settings.currentFormattedDate, // "20251112_170804", initialized at app launch only.
		saveDate: saveDate,
		RANDOM_SEED: RANDOM_SEED,
		SESSION_ID: SESSION_ID,
	};
	
	const transaction = db.transaction([DB_STORE_NAME], 'readwrite');
	const objectStore = transaction.objectStore(DB_STORE_NAME);
	//const request = objectStore.put(stateToSave);
	
	//const getReq = objectStore.get(stateToSave.roomName);
	const getReqInitial = objectStore.get(initialStateToSave.roomName);
	const getReqPlay = objectStore.get(stateToSave.roomName);

	// 1. Handle initial record save (only once)
	getReqInitial.onsuccess = () => {
		if (!getReqInitial.result) {
			objectStore.put(initialStateToSave);
			console.warn("Initial state saved: "+initialStateToSave.roomName);
		}
	};

	getReqPlay.onsuccess = () => {
		const existing = getReqPlay.result;

		if (existing) {
			// Entry exists. Compare SESSION_ID.
			if (existing.SESSION_ID !== stateToSave.SESSION_ID) {
				console.warn(
					`Refusing to save: entry with roomName=${stateToSave.roomName} already exists with a different SESSION_ID. Intended behaviour if testing with different windows.`
				);
				// Abort the transaction to avoid overwrite
				transaction.abort();
				return;
			}
			// Same SESSION_ID â†’ safe to overwrite
		}

		// No entry exists or SESSION_ID matches â†’ save
		objectStore.put(stateToSave);
		
		console.warn('Game saved: '+stateToSave.roomName);
		
		// remove old saved games:
		pruneOldSaves();
	};
	getReqPlay.onerror = (e) => {
		console.warn('Failed to read existing entry before saving.');
	};
}

// roomKey = roomName without "play-" or "init-"
function loadGameFromDB(roomKey, callback) {
	if (!db) return;
	if (!roomKey) {
		callback(null);
		return;
	}

	const tx = db.transaction([DB_STORE_NAME], 'readonly');
	const store = tx.objectStore(DB_STORE_NAME);

	let initialData = null;
	let playData = null;

	const tryReturn = () => {
		if (initialData !== null && playData !== null) {
			callback({ initialData: initialData, playData: playData });
		}
	};

	const getReqInitial = store.get("init-" + roomKey);
	const getReqPlay = store.get("play-" + roomKey);

	getReqInitial.onsuccess = (e) => {
		initialData = e.target.result;
		tryReturn();
	};

	getReqInitial.onerror = () => {
		console.error("Error loading initial data:", e.target.error);
		initialData = null;
		tryReturn();
	};

	getReqPlay.onsuccess = (e) => {
		playData = e.target.result;
		tryReturn();
	};

	getReqPlay.onerror = (e) => {
		console.error("Error loading play data:", e.target.error);
		playData = null;
		tryReturn();
	};
}





// =================================================================
// --- GAME INIT (HOST-SIDE)
// =================================================================



let loadedmap = null;

let customMaps = {
	/* example data:
	small: [
		{
			name: "mapname",
			width: 24,
			height: 24,
			data: null, // parsed map data ready to use ingame.
			preview: "path/to/image.jpg",
			imageData: null,
		},
	],
	normal: [
		{
			width: 24,
			height: 24,
			data: null, // parsed map data ready to use ingame.
			preview: "path/to/image.jpg",
			imageData: null,
		},
	],
	*/
};






//mapdata = {width: 0, height: 0, data: []};
// compact data: L/W/0 P/T/0 0-6 -> L00 = empty piece of land.
// only for compact data.
function getTileCountCompact(mapdata){
	let tileCount = 0;
	let data = mapdata.data;
	let height = data.length;
	let width = data[0].length;
	for(let y = 0; y < height; y++){
		for(let x = 0; x < width; x++){
			if(data[y][x][0] === "L"){
				tileCount++;
			}
		}
	}
	return tileCount;
}



function compressedToCompactInfo(coded){
	switch(coded){
		case 'a': return "L01";
		case 'b': return "L02";
		case 'c': return "L03";
		case 'd': return "L04";
		case 'e': return "L05";
		case 'f': return "L06";
		case 'A': return "LP1";
		case 'B': return "LP2";
		case 'C': return "LP3";
		case 'D': return "LP4";
		case 'E': return "LP5";
		case 'F': return "LP6";
		case 'o': return "L00";
		case 'O': return "LT0";
		case '_': return "W00";
	}
	return "W00";
}

function compactToCompressedInfo(td){
	let coded = "_"; // default to water in case not valid value found.
		
	let type = td[0];
	let object = td[1];
	let owner = parseInt(td[2], 10); // 0 = nobody, 1-6 = players.

	
	if(type === "L"){
		// if peasant:
		if(object === "P"){
			// = land with peasant of owner:
			switch(owner){
				// no case 0: non-owned lands cant have peasants.
				case 1: coded = "A"; break;
				case 2: coded = "B"; break;
				case 3: coded = "C"; break;
				case 4: coded = "D"; break;
				case 5: coded = "E"; break;
				case 6: coded = "F"; break;
			}
		}else if(object === "T"){
			coded = "O"; // land with tree.
		}else{
			// no object:
			// = empty land of owner:
			switch(owner){
				case 0: coded = "o"; break;
				case 1: coded = "a"; break;
				case 2: coded = "b"; break;
				case 3: coded = "c"; break;
				case 4: coded = "d"; break;
				case 5: coded = "e"; break;
				case 6: coded = "f"; break;
			}
		}
	}else{
		// water:
		coded = "_";
	}
	return coded;
}

// input: mapdata = "[W00", ...] etc.
// output:
// aA = Player 1 owned: (empty, peasant)
// bB = 2
// cC = 3
// dD = 4
// eE = 5
// fF = 6
// oO = no owner: (empty, tree)
// _ = water
function compressMap(mapdata){
	let compressed = [];
	
	let width = mapdata[0].length;
	let height = mapdata.length;
	for(let y = 0; y < height; y++){
		let row = "";
		for(let x = 0; x < width; x++){
			row += compactToCompressedInfo(mapdata[y][x]);
		}
		compressed.push(row);
	}
	
	return compressed;
}


async function buildMapList(mapSizeName, totalMaps) {
	const t = mapSizeName[0];

	const promises = Array.from({ length: totalMaps }, async (_, i) => {
		const n = i + 1;
		const name = `map${t}${n}`;
		const mapBasePath = `maps/${mapSizeName}/${name}`;
		const mapFile = `${mapBasePath}.dat`;
		const mapImageFile = `${mapBasePath}.png`;

		try {
			const mapdata = await parseMap(mapFile, true);
			if (!mapdata) return null;

			// Convert image to base64
			const imageResponse = await fetch(mapImageFile);
			if (!imageResponse.ok) throw new Error(`Image not found: ${mapImageFile}`);

			const blob = await imageResponse.blob();
			const imageData = await blobToBase64(blob); // convert blob â†’ base64

			mapdata.preview = mapImageFile; // original URL (optional)
			mapdata.name = name;
			mapdata.imageData = imageData; // base64 string ready for <img src="...">
			mapdata.tileCount = getTileCountCompact(mapdata);
			mapdata.format = 2; // 1 = ["W00", "W00", ...] format, 2 = "____oooOoo___" etc, one byte per tile.
			mapdata.data = compressMap(mapdata.data);
			return mapdata;

		} catch (err) {
			console.error(`Error loading map ${name}:`, err);
			return null;
		}
	});

	const results = await Promise.all(promises);
	customMaps[mapSizeName] = results.filter(Boolean);

	console.log(`Loaded ${customMaps[mapSizeName].length}/${totalMaps} maps successfully.`);
}

// Helper to convert Blob â†’ Base64 string
function blobToBase64(blob) {
	return new Promise((resolve, reject) => {
		const reader = new FileReader();
		reader.onloadend = () => resolve(reader.result); // returns a Data URL (base64)
		reader.onerror = reject;
		reader.readAsDataURL(blob);
	});
}


// only used when compiled-maps.json has to be updated.
// compile maps compilemaps
async function loadmaps(){
	// other way to load them:
	//await Promise.all([
	//  buildMapList("normal", 40),
	//  buildMapList("small", 41)
	//]);

	await buildMapList("normal", 40);
	console.log("buildMapList normal finished");
	await buildMapList("small", 41);
	console.log("buildMapList small finished");
	
	
	const jsonString = JSON.stringify(customMaps);
	console.log("customMaps");
	console.log(customMaps);
	console.warn("jsonString");
	console.warn(jsonString);
}
//loadmaps(); // used only to recompile maps again into one file.




async function loadMapsFromJSON() {
	try {
		const response = await fetch('maps/all-compiled.json');
		if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

		const allmaps = await response.json(); // parses JSON into JS object
		//console.log('Loaded maps:', allmaps);

		// now you can use allmaps normally
		return allmaps;

	} catch (err) {
		console.error('Failed to load JSON file:', err);
		return null;
	}
}


let loadedMapCategory = "all";
let loadedMapIndex = 0;

let currentCategory = "all";


// load map on start:
(async () => {
	customMaps = await loadMapsFromJSON();
	// sort maps by tileCount (land tiles)
	for (const key in customMaps) {
		customMaps[key].sort((a, b) => a.tileCount - b.tileCount);
	}
	customMaps.all = [...customMaps.small, ...customMaps.normal];
	customMaps.all.sort((a, b) => a.tileCount - b.tileCount);
	
	//console.warn("customMaps");
	//console.warn(customMaps);
	//console.warn(customMaps.normal[0]);

	// load default map, first in array:
	loadMap(loadedMapCategory, loadedMapIndex);
})();


function getCustomMap(category, index){
	return customMaps[category][index];
}

	
function loadMap(category, index) {
	// unload loaded game so it wont mess up new game:
	unloadGame();
	
	loadedMapCategory = category;
	loadedMapIndex = index;
	
	const map = getCustomMap(category, index);//customMaps[category][index];
	console.log('Loading map:', category, index, map.name);
	loadedMapImg.src = map.imageData;
	

	setLoadedMapAndApplyScale();

	
	
}


function setLoadedMapAndApplyScale(){
	//loadedmap = customMaps[loadedMapCategory][loadedMapIndex];
	
	loadedmap = deepClone(customMaps[loadedMapCategory][loadedMapIndex]);
	console.warn("loadedmap:");
	console.warn(loadedmap);
	

	scaleMap();
	
	cropMap();
	
	
	loadParsedMap(loadedmap);
	
	
	broadcastMapState();
}




// loadmap
async function parseMap(mapFilePath, compact = false){
	const response = await fetch(mapFilePath);
	if (!response.ok) {
		console.error("Failed to load file:", response.statusText);
		return;
	}

	const text = await response.text(); // read file as plain text
	const lines = text.split(/\r?\n/);  // split into lines

	let parsedMap = {
		width: 0,
		height: 0,
		data: [],
	};

	for(let p = 0; p < lines.length; p++){
		const trimmed = lines[p].trim();
		if (!trimmed) continue; // skip empty lines
		
		const lineValues = trimmed.split(/\s+/); // split by spaces
		
		// get width/height:
		if(p == 0){
			parsedMap.width = parseInt(lineValues[0], 10);
			parsedMap.height = parseInt(lineValues[1], 10);
			continue;
		}
		
		let parsedRowArr = [];
		
		// process cell values:
		for(let i = 0; i < lineValues.length; i++){
			//console.log(lineValues[i]);
			let info = getMapValueInfo(lineValues[i], compact);
			//console.log(info);
			parsedRowArr.push(info);
		}
		
		parsedMap.data.push(parsedRowArr);
		//console.log(lineValues);
	}
	
	console.log(parsedMap);
	
	loadedmap = parsedMap;
	return parsedMap;
}




// {type: land/water, object: null/tree/peasant, owner: 0-6}
// all game memory values (0-10 for player 1):
// not tested if the game will add these units if used in map format.
// -1 = water
// 0 = cross (dead)
// 1 = empty
// 2 = grass
// 3 = tree
// 4 = peasant
// 5 = hut
// 6 = knight
// 7 = castle
// 8 = horse
// 9 = fortress
// 10 = dragon
function getMapValueInfo(valueStr, compact = false){
	// set default type to land, so we dont need to modify it for player owned tiles.
	let info = {type: "land", object: null, owner: 0};
	let value = parseInt(valueStr, 10);
	switch(value){
		case -1:
			info.type = "water";
		break;
		case 241:
			info.owner = 0;
		break;
		case 243:
			info.owner = 0;
			info.object = "tree";
		break;
		case 1:
			info.owner = 1;
		break;
		case 4:
			info.owner = 1;
			info.object = "peasant";
		break;
		case 41:
			info.owner = 2;
		break;
		case 44:
			info.owner = 2;
			info.object = "peasant";
		break;
		case 81:
			info.owner = 3;
		break;
		case 84:
			info.owner = 3;
			info.object = "peasant";
		break;
		case 121:
			info.owner = 4;
		break;
		case 124:
			info.owner = 4;
			info.object = "peasant";
		break;
		case 161:
			info.owner = 5;
		break;
		case 164:
			info.owner = 5;
			info.object = "peasant";
		break;
		case 201:
			info.owner = 6;
		break;
		case 204:
			info.owner = 6;
			info.object = "peasant";
		break;
	}
	if(compact){
		//let info2 = {type: "land", object: null, owner: 0};
		let type = "L"; // L = land, W = water
		let obj = "0"; // T = tree, P = peasant, 0 = none
		let owner = info.owner; // 0 = nobody, 1-6 = players.
		if(info.type == "water"){
			type = "W";
		}
		if(info.object == "peasant"){
			obj = "P";
		}else if(info.object == "tree"){
			obj = "T";
		}
		return `${type}${obj}${owner}`; // "LT3" etc
	}else{
		return info;
	}
}



function compactToExpandedInfo(str){
	let type = "land"; // L = land, W = water
	let obj = null; // T = tree, P = peasant, 0 = none
	let owner = parseInt(str[2], 10); // 0 = nobody, 1-6 = players.
	
	if(str[0] === "W"){
		type = "water";
	}
	if(str[1] === "T"){
		obj = "tree";
	}else if(str[1] === "P"){
		obj = "peasant";
	}
	
	return {type: type, object: obj, owner: owner};
}


function setTileNeighbours(tile, state = null){
	let neigh = getHexNeighbors(tile.q,tile.r);
	let availableNeighbours = [];
	for(let i = 0; i < neigh.length; i++){
		let n = neigh[i];
		const nTile = getTileAt(n.q, n.r, state);
		if(!isTileWater(nTile)){
			//availableNeighbours.push({tileIndex: nTile.tileIndex, neighbourIndex: i, q: n.q, r: n.r});
			availableNeighbours.push(nTile.tileIndex);
		}else{
			//availableNeighbours.push({tileIndex: -1, neighbourIndex: i, q: n.q, r: n.r});
			availableNeighbours.push(-1);
		}
	}
	tile.neighbours = availableNeighbours;
}


function saveMap(){
	let bounds = gameState.map.bounds;
	let rows = [];
	for(let q = bounds.q.min; q <= bounds.q.max; q++){
		let row = "";
		for(let r = bounds.r.min; r <= bounds.r.max; r++){
			let tile = getTileAt(q,r);
			let chr;
			if(tile){
				if(tile.type === "land"){
					if(tile.object === "tree"){
						chr = "O";
					}else{
						chr = "o";
					}
				}
			}else{
				chr = "_";
			}
			row += chr;
		}
		rows.push(row);
	}
	console.warn("rows");
	console.warn(rows);
}


// NOTE: make sure map width/height is even.
function loadParsedMap(parsedMap, compact = true){
	
	// clear previous data:
	gameState.map.tiles = {}; // associative array where [key] = tilesData array index.
	gameState.map.tilesData = []; // actual data for tiles. {q,r, type, ownerId, object, savings} 
	
	let width = parsedMap.width;
	let height = parsedMap.height;
	gameState.map.width = parsedMap.width;
	gameState.map.height = parsedMap.height;
	gameState.map.imageData = parsedMap.imageData;
	gameState.map.name = parsedMap.name;
	
	//console.log("parsedMap");
	//console.log(parsedMap);
	console.warn("width, height");
	console.warn(width, height);
	

	//let qoff = Math.ceil(height/2); // prevents negative coordinates to be used.
	//let off = 0;//height % 2; // fixes odd heights making different shape for map.
	
	
	// calculate max for q and r, to make faster array search by q*w+r index:
	/*
	let max_q = 0;
	let max_r = 0;
	

	
	for (let q = 0, y = 0; q < width; q++, y++) {
		let roff = 0;
	
		for (let r = 0, x = 0; r < height; r++, x++) {
			if((x % 2) == 1){
				roff++;
			}
			let xx = x;
			let yy = y;
			let qq = q-roff;
			let rr = r;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info;
				if(compact){
					info = compactToExpandedInfo(parsedMap.data[yy][xx]);
				}else{
					info = parsedMap.data[yy][xx];
				}

				if(info.type !== 'water'){
					if(qq > max_q) max_q = qq;
					if(rr > max_r) max_r = rr;
				}
			}
		}
	}
	console.warn("max_q, max_r");
	console.warn(max_q, max_r);
	*/
	
	
	// TODO: check if width/height is used properly in the loops! not sure which is which...
	for (let q = 0, y = 0; q < height; q++, y++) {
		let roff = 0;
	
		for (let r = 0, x = 0; r < width; r++, x++) {
			if((x % 2) == 1){
				roff++;
			}
			let xx = x;
			let yy = y;
			//let qq = qoff+q-roff;
			let qq = q-roff;
			let rr = r;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info;
				if(compact){
					info = compactToExpandedInfo(compressedToCompactInfo(parsedMap.data[yy][xx]));
				}else{
					info = parsedMap.data[yy][xx];
				}
				let object = null;
				// original code to load trees from map file, too boring and non-random looking.
				//if(info.object == "tree"){
				//	tree = "tree";
				//}
				// add random trees 20% chance:
				//if(!info.owner && info.type !== 'water' && randomFunc() < 0.2){
					//object = "tree";
				//}
				// dont add water tiles into the tilesData, they are useless.
				if(info.type !== 'water'){
					setTileAt(qq, rr, { type: info.type, ownerIndex: -1, object: object, savings: 0 });
				}
			}
		}
	}
	
	
	// set tile.neighbours for rendering pools with continuous lines:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		if(tile.type === "land"){
			setTileNeighbours(tile);
		}
	}
	
	// find map actual bounds:
	let minQ = 9999999;
	let maxQ = -9999999;
	let minR = 9999999;
	let maxR = -9999999;
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		if(q < minQ) minQ = q;
		if(q > maxQ) maxQ = q;
		if(r < minR) minR = r;
		if(r > maxR) maxR = r;
	}
	gameState.map.bounds = {q: {min:minQ, max:maxQ}, r: {min:minR, max:maxR}};
	
}

function getMapScale(){
	let scale = getUint(mapScale.value);
	if(scale < 1) scale = 1;
	if(scale > 4) scale = 4;
	return scale;
}


function cropMap(){
	let width = loadedmap.data[0].length;
	let height = loadedmap.data.length;
	

	
	// find crop for left, right, top, bottom:
	let crop = {left: -1, right: -1, top: -1, bottom: -1};
	
	// find crop for left side:
	for(let y = 0; y < height; y++){
		for(let x = 0; x < width; x++){
			if(loadedmap.data[y][x] !== "W00"){
				if(x < crop.left || crop.left == -1) crop.left = x;
				break;
			}
		}
	}
	// find crop for right side:
	for(let y = 0; y < height; y++){
		for(let x = width-1, cx = 0; x >= 0; x--, cx++){
			if(loadedmap.data[y][x] !== "W00"){
				if(cx < crop.right || crop.right == -1) crop.right = cx;
				break;
			}
		}
	}
	
	// find crop for top side:
	for(let x = 0; x < width; x++){
		for(let y = 0; y < height; y++){
			if(loadedmap.data[y][x] !== "W00"){
				if(y < crop.top || crop.top == -1) crop.top = y;
				break;
			}
		}
	}
	
	// find crop for bottom side:
	for(let x = 0; x < width; x++){
		for(let y = height-1, cy = 0; y >= 0; y--, cy++){
			if(loadedmap.data[y][x] !== "W00"){
				if(cy < crop.bottom || crop.bottom == -1) crop.bottom = cy;
				break;
			}
		}
	}
	
	// keep cropping in even values, so the roff logic works as expected:
	if((crop.left % 2)   != 0 && crop.left-1   >= 0) crop.left--;
	if((crop.right % 2)  != 0 && crop.right-1  >= 0) crop.right--;
	if((crop.top % 2)    != 0 && crop.top-1    >= 0) crop.top--;
	if((crop.bottom % 2) != 0 && crop.bottom-1 >= 0) crop.bottom--;

	
	let cropRect = {
		x1: crop.left, 
		x2: width-crop.right, 
		y1: crop.top, 
		y2: height-crop.bottom,
	};

	//console.warn("crop");
	//console.warn(crop);
	//console.warn("cropRect");
	//console.log(cropRect);
	
	/*
	// add padding if odd height: (keeps consistent with original game logic)
	if(((cropRect.y2-cropRect.y1) % 2) != 0){
		let maprow = [];
		for(let x = cropRect.x1; x < cropRect.x2; x++){
			maprow.push("W00");
		}
		if((maprow.length % 2) != 0){
			// add padding if odd size: (keeps consistent with original game logic)
			maprow.push("W00");
		}
		croppedmap.push(maprow);
	}
	*/
	
	let croppedmap = [];
		
	for(let y = cropRect.y1; y < cropRect.y2; y++){
		let maprow = [];
		
		/*
		if(((cropRect.x2-cropRect.x1) % 2) != 0){
			// add padding if odd width: (keeps consistent with original game logic)
			maprow.push("W00");
		}
		*/
		for(let x = cropRect.x1; x < cropRect.x2; x++){
			maprow.push(loadedmap.data[y][x]);
		}

		croppedmap.push(maprow);
	}

	
	//console.warn("before crop:");
	//console.warn(loadedmap.data);
	
	//console.warn("cropped map:");
	//console.warn(croppedmap);
	//return;

	
	
	loadedmap.width = croppedmap[0].length;
	loadedmap.height = croppedmap.length;
	loadedmap.data = croppedmap;
	
	//console.warn("loadedmap:");
	//console.warn(loadedmap);
}



function scaleMap(){
	let scale = getMapScale();
	//console.log(loadedmap);
	
	if(scale == 1){
		return; // dont scale if nothing changes.
	}


	let width = loadedmap.data[0].length;
	let height = loadedmap.data.length;
	let newData = [];
	for(let y = 0; y < height; y++){
		let rowData = [];
		for(let x = 0; x < width; x++){
			let elem = loadedmap.data[y][x];
			for(let i = 0; i < scale; i++){
				rowData.push(elem);
			}
		}
		for(let i = 0; i < scale; i++){
			newData.push(rowData);
		}
	}
	
	loadedmap.width = loadedmap.width*scale;
	loadedmap.height = loadedmap.height*scale;
	loadedmap.tileCount = loadedmap.tileCount*(scale*scale);
	
	loadedmap.data = newData;
	
	
}


function updateTileAndNeighbourOutlines(q, r){
	updateTileOutlines(q, r, true);
	let tile = getTileAt(q,r);
	setTileNeighbours(tile);
	
	let neigh = getHexNeighbors(q, r);
	for(let i = 0; i < neigh.length; i++){
		let n = neigh[i];
		updateTileOutlines(n.q, n.r, false);
		let tile2 = getTileAt(n.q, n.r);
		if(!isTileWater(tile2)){
			// must update neighbours for neighbour tiles as well, or the pool highlighting wont work correctly.
			setTileNeighbours(tile2);
		}
	}
	updateShoreTiles(q, r);
}


function updateShoreTiles(q, r){
	let tile = getTileAt(q,r);
	if(isTileWater(tile)){
		updateShoreTileOutlines(q,r, true, null);			
	}
	if(tile){
		let neigh = getHexNeighbors(tile.q, tile.r);
		for(let i = 0; i < neigh.length; i++){
			let n = neigh[i];
			const nTile = getTileAt(n.q, n.r);
			if(isTileWater(nTile)){
				updateShoreTileOutlines(n.q, n.r, true, null);			
			}
		}
	}
}


function clearWaterEdgeTiles(){
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
	}
}

// water edge tiles edge water tiles water edges water edge shading water edges shading
// generatelandshading generateshoreshading generate land generate shore
function generateWaterEdgeTiles(){
	//return;
	let edges = {};
	// find water edges:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		
		let neigh = getHexNeighbors(tile.q, tile.r);
		for(let i = 0; i < neigh.length; i++){
			let n = neigh[i];
			const nTile = getTileAt(n.q, n.r);
			if(isTileWater(nTile)){
				edges[`${n.q},${n.r}`] = 1;				
			}
		}
	}
	// create water tiles for water edge shading:
	for(const [key, value] of Object.entries(edges)){
		let hex = key.split(',');
		let q = Number(hex[0]);
		let r = Number(hex[1]);
		//let tile = {type: "water", ownerIndex: -1, object: null, savings: 0};
		//setTileAt(q, r, tile);
		updateShoreTileOutlines(q, r, true, null);
	}
	
}


function updateShoreTileOutlines(q, r, allowCreation = true, state = null){
	//return;
	//console.warn("updateTileOutlines"+q+","+r);
	let lines = [];
	let neigh = getHexNeighbors(q, r);
	for(let i = 0; i < neigh.length; i++){
		let n = neigh[i];
		const nTile = getTileAt(n.q, n.r, state);
		let addline = 0;
		if (getTileType(nTile) === "land") {
			addline = 1;
		}
	
		if(addline){
			lines.push(i);
		}
	}

	setOutlineAt(q, r, lines, allowCreation, state);
}


function updateTileOutlines(q, r, allowCreation = true, state = null){
	//console.warn("updateTileOutlines"+q+","+r);
	let lines = [];
	let neigh = getHexNeighbors(q, r);
	for(let i = 0; i < neigh.length; i++){
		let n = neigh[i];
		const nTile = getTileAt(n.q, n.r, state);
		let addline = 0;
		
		if (getTileType(nTile) === "water") {
			addline = 1;
		}
		
		
		
		/*
		if (nTile && nTile.type === 'water') {
			addline = 1;
		}
		// if out of bounds, add outlines also:
		if (!nTile){
			addline = 1;
		}
		*/
		
		
		if(addline){
			lines.push(i);
		}
	}

	setOutlineAt(q, r, lines, allowCreation, state);
}



// generate_map
function generateMap(width, height) {
	// NOTE: map is loaded before this generateMaps call, so any changes here for the map wont be visible for playes.
	// go to loadParsedMap
	
	width = loadedmap.width;
	height = loadedmap.height;
	

	// NOTE: map is loaded before this generateMaps call, so any changes here for the map wont be visible for playes.
	gameState.settings.mapWidth = width;
	gameState.settings.mapHeight = height;
	
	//loadParsedMap(loadedmap);
	
	console.log("generating map outlines");
	

	// generate outlines for all land pieces in the map:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		updateTileOutlines(tile.q, tile.r);
	}
	//generateWaterEdgeTiles();
	
}


function shuffle(array) {
	for (let i = array.length - 1; i > 0; i--) {
		const j = Math.floor(randomFunc() * (i + 1)); // random index from 0 to i
		[array[i], array[j]] = [array[j], array[i]];   // swap elements
	}
	return array;
}

function spawnMines(){
	// spawn random mines:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		// if land, no object yet, no owner:
		if(isTileLand(tile) && !tile.object && tile.ownerIndex === -1 && randomFunc() < gameState.settings.minePercent ){
			tile.object = "mine1";
		}
	}
}

function spawnRocks(){
	// spawn random rocks:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		// if land, no object yet, no owner:
		if(isTileLand(tile) && !tile.object && tile.ownerIndex === -1 && randomFunc() < gameState.settings.rockPercent ){
			tile.object = "rock2";
		}
	}
}

function spawnTrees(test1 = 1){
	
	let bounds = gameState.map.bounds;

	let width = gameState.map.width;//bounds.q.max + bounds.q.min;
	let height = gameState.map.height;//bounds.r.max + bounds.r.min;

	// spawn random trees:
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		// if land, no object yet, no owner:
		if(isTileLand(tile) && !tile.object && tile.ownerIndex === -1 && randomFunc() < gameState.settings.treePercent ){
			tile.object = "tree";
		}
	}
	

	/*
	// poissonDiskSampler version, makes too evenly spaced to my taste...
	let treePlaces = [];

	if(test1 == 1){
		treePlaces = poissonDiskSampler(width, height, [2,3,4,5], randomFunc);
	}else{
		treePlaces = []; 
		treePlaces = [...treePlaces, ...poissonDiskSampler1(width, height, 2, randomFunc)]; 
		treePlaces = [...treePlaces, ...poissonDiskSampler1(width, height, 3, randomFunc)]; 
		treePlaces = [...treePlaces, ...poissonDiskSampler1(width, height, 4, randomFunc)]; 
		treePlaces = [...treePlaces, ...poissonDiskSampler1(width, height, 5, randomFunc)];
	}
	
	console.log("treePlaces");
	console.log(treePlaces);
	
	for(let i = 0; i < treePlaces.length; i++){
		let treePos = treePlaces[i];
		
		let x = Math.round(treePos.x);
		let y = Math.round(treePos.y);
		
		let roff = Math.round(treePos.x/2); // fixes the original map format tile offsets.
		let q = x + bounds.q.min + roff;
		let r = y + bounds.r.min;
		
		let tile = getTileAt(q, r);
		if(tile && tile.type === 'land' && tile.ownerIndex === -1){
			tile.object = "tree";
		}
	}
	*/
}


// spawns players on loaded original maps which already has spawn points, just add peasants and claim random player hexes.
function spawnPlayers(){
	let compact = true; // always compact when using original game maps format in loadedmap
	
	let parsedMap = loadedmap;
	
	let width = parsedMap.width;
	let height = parsedMap.height;
	

	let mapOwnerNumbers = {};
	
	// find all possible owners from tiles:
	for (let q = 0, y = 0; q < height; q++, y++) {
		for (let r = 0, x = 0; r < width; r++, x++) {
			let xx = x;
			let yy = y;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info; // {type, object, owner}
				if(compact){
					info = compactToExpandedInfo(compressedToCompactInfo(parsedMap.data[yy][xx]));
				}else{
					info = parsedMap.data[yy][xx];
				}
				// if owned tile by some player:
				if(info.owner > 0){
					mapOwnerNumbers[info.owner] = info.owner;
				}
			}
		}
	}
	let mapOwners = [];
	for (let owner in mapOwnerNumbers) {
		mapOwners.push(owner);
	}
	
	// randomize and choose a player for each mapOwner:
	mapOwners = shuffle(mapOwners);
	
	const playingPlayers = gameState.players.filter(p => !p.isSpectator);
	


	// set player id's to map owner numbers:
	let mapPlayerToPlayerIndex = {};
	let extraPlayers = [];
	for(let p = 0, i = 0; p < playingPlayers.length; p++, i++){
		let player = playingPlayers[p];
		if(i < mapOwners.length){
			mapPlayerToPlayerIndex[mapOwners[i]] = player.playerIndex;
		}else{
			extraPlayers.push(player);
		}
	}
	
	console.warn("mapOwners");
	console.warn(mapOwners);
	console.warn("mapPlayerToPlayerIndex");
	console.warn(mapPlayerToPlayerIndex);
	
	console.warn("width, height");
	console.warn(width, height);
	
	//let qoff = Math.ceil(height/2);
	//let off = 0;//height % 2; // fixes odd heights making different shape for map.
	
	// spawn players and claim hexes for them:
	for (let q = 0, y = 0; q < height; q++, y++) {
		let roff = 0;
	
		for (let r = 0, x = 0; r < width; r++, x++) {
			if((x % 2) == 1){
				roff++;
			}
			let xx = x;
			let yy = y;
			//let qq = qoff+q-roff;
			let qq = q-roff;
			let rr = r;
			
			if(parsedMap.data[yy] && parsedMap.data[yy][xx]){
				let info; // {type, object, owner}
				if(compact){
					info = compactToExpandedInfo(compressedToCompactInfo(parsedMap.data[yy][xx]));
				}else{
					info = parsedMap.data[yy][xx];
				}
				
				if(info.owner){
					let playerIndex = mapPlayerToPlayerIndex[info.owner];
					if(playerIndex !== undefined){
						let tile = getTileAt(qq, rr);

						setTileOwnerByIndex(tile, playerIndex);
						
						if(info.object == "peasant"){
							// unit found
							// no need to remove object, since map format doesnt have object here.
							spawnSoldier(qq, rr, playerIndex, 'peasant');
							
						}
					}
				}
				
				
			}
		}
	}
	
	// spawn extra players:
	if(extraPlayers.length > 0){
		let tiles = gameState.map.tilesData;
		for(let i = 0; i < extraPlayers.length; i++){
			// find free tile:
			let randomTileIndex;
			let counter = 0;
			do {
				randomTileIndex = random(0, tiles.length-1);
				counter++;
			} while ((tiles[randomTileIndex].ownerIndex !== -1 || !isTileLand(tiles[randomTileIndex])) && counter < 1000);
			
			let tile = gameState.map.tilesData[randomTileIndex];
			let qq = tile.q;
			let rr = tile.r;
			
			let playerIndex = extraPlayers[i].playerIndex;
			setTileOwnerByIndex(tile, playerIndex);
			setTileAt(qq, rr, {object:null}); // remove object if any.
			spawnSoldier(qq, rr, playerIndex, 'peasant');
			// TODO: try to claim hex neighbour:
			
		}
	}
	
	
}


function spawnPlayersRandom() {
	const playersToSpawn = gameState.players.filter(p => !p.isSpectator); // && !p.isAI
	let landHexes = [];
	
	// Get all available land hexes
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		
		if (getTileType(tile) === 'land') {
			landHexes.push({q, r});
		}
	}

	// Shuffle
	landHexes.sort(() => randomFunc() - 0.5);
	
	for (const player of playersToSpawn) {
		let spawnHex = null;
		let neighbors = [];

		// Find a spawn point with at least 4 land neighbors
		let found = false;
		while (!found && landHexes.length > 0) {
			spawnHex = landHexes.pop();
			neighbors = getHexNeighbors(spawnHex.q, spawnHex.r)
				.map(h => ({ ...h, tile: getTileAt(h.q, h.r) }))
				.filter(h => getTileType(h.tile) === 'land');
			
			if (neighbors.length >= 4) {
				found = true;
			}
		}
		
		if (!found) {
			console.warn(`Could not find ideal spawn for ${player.name}`);
			// Just use the last one we tried
			if (!spawnHex) continue; // No land hexes left?
		}
		
		// Claim center hex
		const centerTile = getTileAt(spawnHex.q, spawnHex.r);

		setTileOwnerByIndex(centerTile, getPlayerIndex(player.id));
		centerTile.object = null;
		centerTile.savings = gameState.settings.startingMoney / 5; // Split money
		
		// Claim 4 neighbors
		let claimedHexes = [];
		for (let i = 0; i < 4; i++) {
			const n = neighbors[i];

			setTileOwnerByIndex(n.tile, getPlayerIndex(player.id));
			n.tile.object = null;
			n.tile.savings = gameState.settings.startingMoney / 5;
			claimedHexes.push(n);
		}
		
		// Add Peasants
		let total_start_units = 2;
		if(claimedHexes.length < total_start_units){
			total_start_units = claimedHexes.length;
		}

		for(let i = 0; i < total_start_units; i++){
			const soldierHex = claimedHexes[i];
			spawnSoldier(soldierHex.q, soldierHex.r, player.id, 'peasant');
		}
	}
	
	console.warn("gameState.units ");
	console.warn(gameState.units);
}

////////////////////
// create unique ID for units without making messy hashes for them.
let UNIT_ID_COUNTER = 1; // start from 1, as 0 could be used to check if it was set at all.
function newUnitID(){
	let id = UNIT_ID_COUNTER;
	UNIT_ID_COUNTER++;
	return id;
}


// type = Peasant, Knight, Horse, Dragon
function spawnSoldier(q, r, playerIndex, type){
	const soldier = {
		// rearranged keys for easier debugging
		id: newUnitID(),
		ownerIndex: playerIndex,
		q: q,
		r: r,
		hasMoved: 0,
		type: type,
		level: getUnitLevel(type),
		internalType: getUnitInfo(type).type,
		wasSpawned: 1, // ensure no animation triggered.
	};
	
	//gameState.units.push(soldier);
	addUnit(soldier);
}

function spawnCastle(q, r, playerIndex, type){
	const castle = {
		// rearranged keys for easier debugging
		id: newUnitID(),
		ownerIndex: playerIndex,
		q: q,
		r: r,
		hasMoved: 0,
		type: type,
		level: getUnitLevel(type),
		internalType: getUnitInfo(type).type,
		wasSpawned: 1, // ensure no animation triggered.
	};

	//gameState.units.push(castle);
	addUnit(castle);
}


let DELAY_MULTI = 1;
let DELAY_MULTI_STEP = 1.5;


function replaySpeedUp(){
	if(REPLAY_ENABLED){
		DELAY_MULTI /= DELAY_MULTI_STEP;
		addSystemChatMessage(`Replay delay multiplier: ${DELAY_MULTI.toFixed(4)}`);
	}
}
function replaySpeedDown(){
	if(REPLAY_ENABLED){
		DELAY_MULTI *= DELAY_MULTI_STEP;
		addSystemChatMessage(`Replay delay multiplier: ${DELAY_MULTI.toFixed(4)}`);
	}
}


async function replayHistory(history) {
	if (!history || history.length === 0) return;
	
	// broadcast message for start of replay:
	broadcast({ type: ACTION.system_message, message: "--- Replay has started ---" });

	// Broadcast the first message immediately
	broadcast(deCompressAction(history[0]));

	for (let i = 1; i < history.length; i++) {
		const prev = deCompressAction(history[i - 1]);
		const curr = deCompressAction(history[i]);

		let delay = (curr._T - prev._T) * DELAY_MULTI;
		if (delay < 0) delay = 0; // in case of bugged time values...
		if(delay > 1000) delay = 1000; // limit delay to one second.
		
		await new Promise(res => setTimeout(res, delay));

		broadcast(curr);
	}
	
	// broadcast message for end of replay:
	broadcast({ type: ACTION.system_message, message: "--- Replay has ended ---" });
}


function deepClone(obj) {
	if (typeof structuredClone === "function") {
		return structuredClone(obj);
	}
	return JSON.parse(JSON.stringify(obj)); // fallback (with JSON limitations)
}



async function startReplay(){
	
	if (!isHost()) return;
	
	
	console.log("Starting replay...");
	
	if (loadedGameStateInitial) {
		
		console.warn("Starting from loaded state.");
		
		// remember players before loading replay:
		let lobbyPlayers = deepClone(gameState.players);
		
		gameState = loadedGameStateInitial;
		console.warn("gameState.settings");
		console.warn(gameState);
		gameState.settings.gameStarted = true;
		
		// NETWORK_HISTORY is set on replay_start.
		
		// todo: remove ownerId completely from use, rely on indexes instead.
		
		// assign new ids to players and remember the old one:
		// so they wont conflict with players watching the replay (especially "default-room" id).
	
		for(let i = 0; i < gameState.players.length; i++){
			let player = gameState.players[i];
			let newID = getUID();
			let oldID = player.id;
			player.id = newID;
			player.oldID = oldID;
		}
		let loadedPlayersTotal = gameState.players.length;
		
		// add lobby players so they can chat:
		// set as spectators so they cant play.
		for(let i = 0; i < lobbyPlayers.length; i++){
			lobbyPlayers[i].isSpectator = true;
			// update playerindex in case needed:
			lobbyPlayers[i].playerIndex += loadedPlayersTotal;
			
			gameState.players.push(lobbyPlayers[i]);
		}



		setProtectedTiles();
		
		// Clear undo stack
		currentTurnActions = [];
		

		//////////////////////////
		// find max id for units so new units will get correct new ID:
		let maxid = -1;
		for(let i = 0; i < gameState.units.length; i++){
			if(gameState.units[i].id > maxid){
				maxid = gameState.units[i].id;
			}
		}
		UNIT_ID_COUNTER = maxid+1;
		
		// Broadcast start
		// At the very end of the function, AFTER broadcast(game_start):
		broadcast({ type: ACTION.replay_start, state: gameState });
	
	}
}



// if player is kicked, the indexes must be rebuilt.
function rebuildPlayerIndexes(){
	for(let i = 0; i < gameState.players.length; i++){
		gameState.players[i].playerIndex = i;
	}
}


function startGameCheck(){
	// broadcast for everyone to ask for confirmation to start game with current settings:
	broadcast({type: ACTION.start_game_check});
}


// makes sure map.tiles links properly to map.tilesData and tile.neighbours also links to proper tiles.
function rebuildTileLinks(){
	gameState.map.tiles = {};
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		tile.tileIndex = t;
		gameState.map.tiles[`${tile.q},${tile.r}`] = t;
	}
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		let tile = gameState.map.tilesData[t];
		let neigh = getHexNeighbors(tile.q, tile.r);
		let negs = [];
		for(let n = 0; n < neigh.length; n++){
			let nn = neigh[n];
			let nTile = getTileAt(nn.q, nn.r);
			if(isTileWater(nTile)){
				negs.push(-1);
			}else{
				negs.push(nTile.tileIndex);
			}
		}
		tile.neighbours = negs;
	}
}


function startGame() {
	

	if (!isHost()) return;
	
	// clear network history.
	NETWORK_HISTORY = [];

	console.warn("Starting game...");
	
	if (loadedGameState) {
		console.warn("Starting from loaded state.");
		
		// remember players before loading game and replaceing gameState.players with loaded game players:
		let oldPlayers = deepClone(gameState.players);
		//console.warn(oldPlayers);
		
		gameState = loadedGameState;
		gameState.settings.gameStarted = true;
		gameState.settings.editorEnabled = false;
		
		// set loaded game players to current players in the same order:
		for(let i = 0; i < gameState.players.length; i++){
			if(i < oldPlayers.length){
				gameState.players[i].id = oldPlayers[i].id;
			}else{
				// set the remaining players as AIs:
				gameState.players[i].isAI = true;
			}
		}
		
		// clear all animations to be finished:
		// NOTE: the timers are based on the client performance.now(), so they wont match anymore,
		//       and will make weirdly big sprites appear for negative time differences...
		for(let i = 0; i < gameState.units.length; i++){
			gameState.units[i].animationFinished = 1;
		}
		for(let i = 0; i < gameState.map.tilesData.length; i++){
			gameState.map.tilesData[i].animationFinished = 1;
			// clear appear animation info:
			delete gameState.map.tilesData[i].isAppearing;
			delete gameState.map.tilesData[i].appearStartTime;
		}

		generateWaterEdgeTiles();
		
		rebuildTileLinks(); // todo: remove...
		
		/*
		// Match current players to loaded players
		const newPlayerList = [];
		const loadedPlayers = gameState.players.filter(p => !p.isSpectator);
		
		
		// Add all current spectators
		for (const p of connections.keys()) {
			const player = getPlayer(p);
			if (player && player.isSpectator){
				newPlayerList.push(player);
			}
		}
		if (localPlayer.isSpectator){
			newPlayerList.push(localPlayer);
		}
		
		// continue at: set player as taken from loaded players list.
		// loadedGameState.players[i].takenBy = null; 
		
		// Match players
		for (const loadedP of loadedPlayers) {
			// Find a current player who 'took' this name
			const matchingCurrentPlayer = [...gameState.players, localPlayer].find(
				p => p.name === loadedP.name && p.color === loadedP.color && !p.isSpectator
			);
			
			if (matchingCurrentPlayer) {
				// This player takes the slot
				loadedP.id = matchingCurrentPlayer.id; // Assign new PeerID
				// TODO: should not change the id since its the peerId...
				// just rewrite the units ownerId's with the actual playing player id.
				newPlayerList.push(loadedP);
			} else {
				// No one took this slot. Mark as AI or disconnected?
				// For now, let's just keep them.
				loadedP.isAI = true; // Mark as AI for now
				newPlayerList.push(loadedP);
			}
		}
		gameState.players = newPlayerList;
		*/
		
	} else {
		
		// update gameRoom key for the db, so the game room name will match the start time.
		//currentFormattedDate = formatDateForSave();
	
		console.log("Starting new game.");
		// Set settings from inputs
		gameState.settings.mapWidth = parseInt(mapWidthInput.value, 10);
		gameState.settings.mapHeight = parseInt(mapHeightInput.value, 10);
		gameState.settings.startingMoney = parseInt(startMoneyInput.value, 10);
		gameState.settings.currentFormattedDate = formatDateForSave();
		
		
		
		// Filter out players without connection from play (unless they are host or ai):
		gameState.players = gameState.players.filter(p => p.id === localPlayer.id || connections.has(p.id) || p.isAI);
		// update all players indexes, might be messed up after kicking players before start:
		for(let i = 0; i < gameState.players.length; i++){
			gameState.players[i].playerIndex = i;
		}
		
		// set up player mines/boats amounts:
		for(let i = 0; i < gameState.players.length; i++){
			let player = gameState.players[i];
			
			if(!player.isSpectator){
				player.totalMines = gameState.settings.initialMines;
				player.totalBoats = gameState.settings.initialBoats;
			}
		}
		
		// set boats/mines cost:
		OTHER_UNITS_DATA.sailboat.cost = gameState.settings.boatCost;
		OTHER_UNITS_DATA.landmine.cost = gameState.settings.mineCost;

		

		// list playing players for colors: (not sure what is this for)
		const playingPlayers = gameState.players.filter(p => !p.isSpectator);
		
		// dont allow starting game without players (crash).
		if(playingPlayers.length == 0){
			return;
		}
		
		// Assign first colors to any uncolored players
		let colorIdx = 0;
		const usedColors = gameState.players.map(p => p.color);
		for (const p of playingPlayers) {
			if (!p.color) {
				while(colorIdx < PLAYER_COLORS.length && usedColors.includes(PLAYER_COLORS[colorIdx].color)) {
					colorIdx++;
				}
				// handle "no colors left":
				if (colorIdx >= PLAYER_COLORS.length) {
					colorIdx = 0;
				}
				p.color = PLAYER_COLORS[colorIdx].color;
				p.textColor = PLAYER_COLORS[colorIdx].textColor;
				usedColors.push(p.color);
			}
		}
		
		gameState.settings.gameStarted = true;
		
		generateMap(gameState.settings.mapWidth, gameState.settings.mapHeight);
		generateWaterEdgeTiles();
		
		spawnPlayers();
		spawnTrees();
		spawnRocks();
		
		spawnMines();
		

		// add money per tile:
		for(let i = 0; i < gameState.map.tilesData.length; i++){
			let tile = gameState.map.tilesData[i];
			if(tile.ownerIndex !== -1){
				tile.savings += gameState.settings.startMoneyPerHex;
			}
		}
		
		let myPlayer = getMyPlayer();
		if(myPlayer.isSpectator){
			spectatorUiMode();
		}
		
		// Set initial turn (skips spectators)
		if(gameState.settings.startPlayerId === -1){
			gameState.turn.currentPlayerIndex = getNextPlayerIndex(random(0, gameState.players.length-1));
			console.warn("set random starting player index = "+gameState.turn.currentPlayerIndex);
		}else{
			gameState.turn.currentPlayerIndex = getPlayerIndex(gameState.settings.startPlayerId);
			console.warn("set custom starting player: "+gameState.settings.startPlayerId+", index = "+gameState.turn.currentPlayerIndex);
		}
		gameState.turn.startPlayerIndex = gameState.turn.currentPlayerIndex;
		gameState.turn.turnNumber = 1;
		console.warn("currentPlayerIndex: "+gameState.turn.currentPlayerIndex);
		console.warn("startPlayerIndex: "+gameState.turn.startPlayerIndex);
		//advanceToNextPlayer(); // not sure why this was here, probably because of bugged currentPlayerIndex calculations
	}
	

	setProtectedTiles();
	
	// Clear undo stack
	currentTurnActions = [];
	
	// save initial gameState for replaying the games later.
	//INITIAL_STATE = deepClone(gameState);

	//////////////////////////
	// find max id for units so new units will get correct new ID:
	let maxid = -1;
	for(let i = 0; i < gameState.units.length; i++){
		if(gameState.units[i].id > maxid){
			maxid = gameState.units[i].id;
		}
	}
	UNIT_ID_COUNTER = maxid+1;
	


	
	
	// Broadcast start
	// At the very end of the function, AFTER broadcast(game_start):
	broadcast({ 
		type: ACTION.game_start, 
		state: gameState,
	});
	checkForAITurn(); // start AI turn if it is his turn.
	
	// Send initial savings to all players
	gameState.players.forEach(p => {
		if (!p.isSpectator) {
			updatePlayerSavings(p.playerIndex);
		}
	});
	
	
}



// checks all tiles if they are protected or not.
// only used in drawMapTiles() function.
function setProtectedTiles(){
	return; // not used anymore.
	
	for(let t = 0; t < gameState.map.tilesData.length; t++){
		const tile = gameState.map.tilesData[t];
		const q = tile.q;
		const r = tile.r;
		if(getTileType(tile) === 'land'){
			if(getUnitAt(q,r)){
				// if unit on tile, set protected
				tile.isProtected = 1; // use short value to make json smaller when saving.
			}else{
				// check if this tile is protected
				tile.isProtected = getShieldLevelFromTile(tile, -1) ? 1 : 0;
			}
		}
	}
}

// safer parseInt so it wont allow any text to cause extreme large values.
function getInt(str) {
	let parsed = str.replace(/[^0-9-]/g, '');
	return (parsed.length > 0) ? parseInt(parsed, 10) : 0;
}

// same but force to unsigned.
function getUint(str) {
	let parsed = str.replace(/[^0-9]/g, '');
	return (parsed.length > 0) ? parseInt(parsed, 10) : 0;
}


// prevent contextmenu from appearing. oncontextmenu
document.addEventListener('contextmenu', function(event) {
	event.preventDefault();
}, false);


document.addEventListener('keydown', (event) => {
	// dont handle key presses if it came from chat input.
	if(event.target.id !== 'chat-input'){
		const key = event.key;
		const code = event.code;

		if(gameStarted()){
			if (key === 'Enter') { // event.key matches enter and numpad enter.
				toggleUiTopLeft();
			}else if(code === 'KeyQ') { // q "q" 'q'
				if(!event.shiftKey){
					rotateLeftSnapped();
				}else{
					rotateAroundScreenCenter(-0.03);
				}
			}else if(code === 'KeyE') {
				if(!event.shiftKey){
					rotateRightSnapped();
				}else{
					rotateAroundScreenCenter(0.03);
				}
			}else if(code === 'KeyW') {
				rotateAroundScreenCenter(-viewport.rotation);
			}else if(code === 'Space'){
				lastMovesTriggerTime = performance.now();
			}
		}
	}
});



document.addEventListener('keyup', (event) => {
	// dont handle enter if it came from chat input.
	if(event.target.id !== 'chat-input'){
		const key = event.key;
		
		if (key === '+' || key === 'Add') {
			replaySpeedUp();
		}
		if (key === '-' || key === 'Subtract') {
			replaySpeedDown();
		}
	}
});


// for simple settings checkboxes:
// id = html element id, key = gameSettings key, elem = document.getElementById(id)
// later maybe allow adding listenerType : "change" etc.
let settingsElems = {
	'game-settings-gfx-shading-land':		{key: 'drawLandShading', type: 'checkbox'},
	'game-settings-gfx-shading-land3d':		{key: 'drawWaterShading', type: 'checkbox'},
	'game-settings-gfx-shading-shore':		{key: 'drawShoresShading', type: 'checkbox'},
	'game-settings-gfx-shading-pooledges':	{key: 'drawPoolEdges', type: 'checkbox'},
	'game-settings-gfx-pointers':			{key: 'drawPointers', type: 'checkbox'},
	'game-settings-gfx-particles':			{key: 'drawParticles', type: 'checkbox'},
	'game-settings-gfx-water':				{key: 'drawWater', type: 'checkbox'},

	'game-settings-autosave':				{key: 'autosave', type: 'checkbox'},

	// gamestate settings:
	'game-settings-editor':					{gameStateKey: 'editorEnabled', type: 'checkbox', allowIngame: true},
	
	'game-settings-use-boats':				{gameStateKey: 'useBoats', type: 'checkbox'},
	'game-settings-use-landmines':			{gameStateKey: 'useLandmines', type: 'checkbox'},
	
	'game-settings-boat-cost': 				{gameStateKey: 'boatCost', type: 'number'},
	'game-settings-initial-boats': 			{gameStateKey: 'initialBoats', type: 'number'},
	'game-settings-boats-add': 				{gameStateKey: 'boatsPerWeek', type: 'number'},
	'game-settings-max-boats': 				{gameStateKey: 'maxBoats', type: 'number'},

	'game-settings-mine-cost': 				{gameStateKey: 'mineCost', type: 'number'},
	'game-settings-initial-mines': 			{gameStateKey: 'initialMines', type: 'number'},
	'game-settings-mines-add': 				{gameStateKey: 'minesPerWeek', type: 'number'},
	'game-settings-max-mines': 				{gameStateKey: 'maxMines', type: 'number'},
};




Object.keys(settingsElems).forEach(id => {
	let setting = settingsElems[id];
	setting.elem = document.getElementById(id);
	// prevent errors if no element found:
	if (!setting.elem){
		console.warn("Element id '"+id+"' of settingsElems does not exist!");
		return;
	}
	
	if(setting.key !== undefined){
		setting.elem.addEventListener("change", () => {
			gameSettings[setting.key] = setting.elem.checked;
		});
	}
	if(setting.gameStateKey !== undefined){
		setting.elem.addEventListener("change", () => {
			// dont allow changing setting when game has already started:
			// only allow host to change gameState settings.
			let allowChange = setting.allowIngame || !gameStarted();
			if(allowChange && isHost()){
				if(setting.type === 'checkbox'){
					gameState.settings[setting.gameStateKey] = setting.elem.checked;
				}else if(setting.type === 'number'){
					gameState.settings[setting.gameStateKey] = Number(setting.elem.value);
				}else{
					gameState.settings[setting.gameStateKey] = setting.elem.value;
				}
				if(setting.gameStateKey === 'editorEnabled'){
					if(setting.elem.checked){
						openEditor();
					}else{
						closeEditor();
					}
				}
				broadcastSettings();
			}
		});
	}
});



function openEditor(){
	uiEditor.style.display = "block";
}
function closeEditor(){
	uiEditor.style.display = "none";
}


let mouseDownInsidePopup = false;

// handlePointer bugged, if x or y is zero, causes error.
function handleOutside(e) {
	if (e.target.classList.contains("tab-game-settings")){
		const tabClass = e.target.dataset.tabclass;
		

		// make settings popup transparent if on graphics tab and game started:
		if(tabClass === 'tab-graphics' && gameStarted()){
			document.querySelectorAll(".settings-panel").forEach(el => {
				el.classList.add("trans");
			});
		}else{
			document.querySelectorAll(".settings-panel").forEach(el => {
				el.classList.remove("trans");
			});
		}
		
		// remove active buttons from all tab-buttons:
		document.querySelectorAll(".tab-button").forEach(el => {
			el.classList.remove("active");
		});
		
		
		e.target.classList.add("active");
		
		// Hide all tabs
		document.querySelectorAll(".tab").forEach(el => {
			el.classList.remove("active");
		});

		// Show selected tab
		const activeTab = document.querySelector(".tab." + tabClass);
		if (activeTab) {
			activeTab.classList.add("active");
		}
	}
	
	
	// If the click started inside, do nothing
	if (mouseDownInsidePopup) {
		mouseDownInsidePopup = false;
		return;
	}

	// Picker popup
	if (!pickerWrapper.contains(e.target)) {
		closeColorPicker();
	}

	// Game settings
	if (!gameSettingsUiWrapper2.contains(e.target)) {
		gameSettingsUi.style.display = "none";
	}
	
	// endgame popup
	//if (!endgamePopupUiWrapper2.contains(e.target)) {
	//	endgamePopupUi.style.display = "none";
	//}
	
	// move undo confirmation:
	if (!moveConfirmationWrapper2.contains(e.target)) {
		//moveConfirmationPopup.style.display = "none";
	}
	
	// Build popup
	if (
		!buildPopup.contains(e.target) &&
		!buildOtherBtn.contains(e.target) &&
		!buildSoldierBtn.contains(e.target) &&
		!buildCastleBtn.contains(e.target)
	) {
		if (isBuildPopupOpen()) {
			cancelBuildPopup();
		}
	}

}



document.addEventListener('mousedown', (e) => {
	mouseDownInsidePopup =
		pickerWrapper.contains(e.target) ||
		gameSettingsUiWrapper2.contains(e.target) ||
		//endgamePopupUiWrapper2.contains(e.target) || // dont allow closing endgame popup by clicking outside.
		//moveConfirmationWrapper2.contains(e.target) || // not used, popup must be closen by ok button.
		buildPopup.contains(e.target) ||
		buildOtherBtn.contains(e.target) ||
		buildSoldierBtn.contains(e.target) ||
		buildCastleBtn.contains(e.target);
});

document.addEventListener('click', handleOutside);
//document.addEventListener('touchstart', handleOutside, { passive: true });


const dirtyInput = document.getElementById('dirty-flag');

// Whenever you want the page to be â€œdirtyâ€ (e.g., game started)
function markDirty() {
	dirtyInput.value = Date.now(); // any change will make the browser consider it modified
}

// When the game ends, you can reset it
function clearDirty() {
	dirtyInput.value = '';
}



window.addEventListener('beforeunload', (e) => {
	if (dirtyInput.value) {
		e.preventDefault();
		e.returnValue = 'Quit game?';
	}
});

/*
// doesnt seem to be working on server side, maybe need to fix server.
window.addEventListener('unload', () => {
	if (peer && !peer.destroyed) {
		peer.destroy();
		navigator.sendBeacon('/peer-disconnect', JSON.stringify({ peerId: peer.id }));
	}
});
*/


/*
// Prevent accidental back navigation
function preventBackNavigation() {
	history.pushState(null, '', location.href);

	window.addEventListener('popstate', function (event) {
		const leave = confirm('Are you sure you want to quit the game?');

		if (leave) {
			// Let them go back by removing the listener
			window.removeEventListener('popstate', arguments.callee);
			//history.back();
			restartGame();
		} else {
			// Re-add the state so back button keeps working
			history.pushState(null, '', location.href);
		}
	});
}*/

// Prevent accidental back navigation and handle settings popup
function preventBackNavigation() {

	// Base state
	history.pushState(null, '', location.href);
	//history.replaceState({ state: 'game' }, '', location.href);

	window.addEventListener('popstate', function handler() {

		if (popupOpen) {
			closeGameSettings();
			closeSavedGamesPopup();
			closePopup();
			closeColorPicker();
			closeMapPreviewPopup();
			//toggleSettings(0); // cant close chatbox since you might have game settings open.
			popupOpen = false;
			history.replaceState({ state: 'game' }, '', location.href);
			return;
		}
		


		const leave = confirm('Are you sure you want to quit the game?');

		if (leave) {
			window.removeEventListener('popstate', handler);
			restartGame();
		} else {
			history.replaceState({ state: 'game' }, '', location.href);
		}
	});
}


preventBackNavigation();


function addPopupState(elem){
	//console.warn("addPopupState");
	if (popupOpen){
		console.warn("addPopupState: popup was already open");
		return;
	}
	popupOpen = true;
	//elem.classList.add('open');
	history.pushState({ screen: 'popup' }, '', location.href);
}

function removePopupState(elem, screen){
	//console.warn("removePopupState");
	//popupOpen = false; // cant set it here or every close call would remove it so the addpopupstate wont work.
	//elem.classList.remove('open');
}




function unloadGame(){
	// Unload
	if(loadedGameState){
		loadedGameState = null;
		loadedGameStateInitial = null;
		NETWORK_HISTORY = [];
		loadGameBtn.textContent = "Load Game";
		loadedGameInfoContainer.style.display = "none";
		startReplayBtn.style.display = "none";
		
		loadedMapMode(false);
		
		updateHostLobbyUI();
	}
}


function loadSavedGame(roomKey){
	if (loadedGameState) {
		unloadGame();
	} else {
		// Load
		
		// update so it will not create new savegame for this game. uses same date key for db.
		//currentFormattedDate = roomName;
		
		loadGameFromDB(roomKey, (state) => {
			if (state) {
				
				loadedMapMode(true);
				
				//console.log("JSON.stringify(state.playData.gameState).length");
				//console.log(JSON.stringify(state.playData.gameState).length);
				//console.log("JSON.stringify(state.initialData.initialState).length");
				//console.log(JSON.stringify(state.initialData.initialState).length);
				
				// state = { initialData: initialData, playData: playData }
				
				loadedGameState = deepClone(state.playData.gameState);
				loadedGameState = prepareLoadedGameState(loadedGameState); // rebuilds deleted stuff.
				
				loadedGameStateInitial = deepClone(state.initialData.initialState);
				loadedGameStateInitial = prepareLoadedGameState(loadedGameStateInitial); // rebuilds deleted stuff.
				
				//console.log("JSON.stringify(loadedGameState).length");
				//console.log(JSON.stringify(loadedGameState).length);
				//console.log("JSON.stringify(loadedGameStateInitial).length");
				//console.log(JSON.stringify(loadedGameStateInitial).length);
				
				NETWORK_HISTORY = deepClone(state.playData.networkHistory);
				console.warn("old sessionid = "+SESSION_ID+", new sessionid = "+state.playData.SESSION_ID);
				SESSION_ID = state.playData.SESSION_ID; // copy the id so you can overwrite the save.
				
				startReplayBtn.style.display = "block";
				
				console.log("loaded random seed = "+state.playData.RANDOM_SEED);
				randomFunc = mulberry32(state.playData.RANDOM_SEED);
				
				// mark all loaded players as "not taken yet":
				// later the players will take a spot themselves.
				
				// NOT USED (YET?)
				//for(let i = 0; i < loadedGameState.players.length; i++){
				//	loadedGameState.players[i].takenBy = null; // peerId/playerId who took this player.
				//}
				console.warn("loadedGameState:");
				console.warn(loadedGameState);
				
				
				//console.log(lobbyLoadedMapImg);
				gameState.settings = loadedGameState.settings;
				gameState.settings.gameStarted = false;

				//gameState.players = loadedGameState.players;
				gameState.map = loadedGameState.map;
				
				// update minimap for host:
				loadedMapImg.src = loadedGameState.map.imageData;
				updateHostLobbyUI();

				//console.log(lobbyLoadedMapImg);

				// update state to all players so they see the map loaded etc.
				//broadcastLobbyState(loadedGameState.settings, loadedGameState.players, loadedGameState.map);
				broadcastLobbyState(gameState.settings, gameState.players, gameState.map);
				
				
				loadGameBtn.textContent = 'Unload Game';
				loadGameDate.textContent = new Date(state.playData.saveDate).toLocaleString();
				loadGamePlayersList.innerHTML = '';
				
				//state.gameState.players.filter(p => !p.isSpectator).forEach(p => {
				loadedGameState.players.filter(p => !p.isSpectator).forEach(p => {
					const li = document.createElement('li');
					li.textContent = `${p.name}`;
					li.style.color = p.textColor;
					li.className = 'loaded-player';
					
					/*
					// todo: show this list to clients too, and allow clicking the player from list
					//       to take that player as your own.
					li.onclick = () => {
						
						if (li.classList.contains('taken')){
							return;
						}
						
						// Mark others as not taken
						loadGamePlayersList.querySelectorAll('li').forEach(item => {
							if (item.textContent.endsWith(' (taken)')) {
								const originalName = item.dataset.name;
								const pData = loadedGameState.players.find(lp => lp.name === originalName);
								if (pData){
									pData.isTaken = false;
								}
								item.textContent = originalName;
								item.classList.remove('taken');
							}
						});
						
						// Take this one
						localPlayer.name = p.name;
						localPlayer.color = p.color;
						localPlayer.textColor = p.textColor;
						localPlayer.isSpectator = false;
						
						playerNameInput.value = p.name;
						
						spectateHostBtn.classList.remove('active');
						p.isTaken = true; // Mark in loaded state
						li.textContent = `${p.name} (taken)`;
						li.dataset.name = p.name;
						li.classList.add('taken');
						
						broadcastLobbyState(); // Update others
					};
					*/
					loadGamePlayersList.appendChild(li);
				});
				loadedGameInfoContainer.style.display = 'block';
			} else {
				alert('No saved game found for this room name: '+roomKey);
			}
		});
	}
}




// cancels building an unit and closes the popup
function cancelBuildPopup(){
	hideBuildPopup();
	placingUnit = null;
	// hide cancel texts:
	buildOtherBtn.classList.remove("cancel");
	buildSoldierBtn.classList.remove("cancel");
	buildCastleBtn.classList.remove("cancel");
}

function hideBuildPopup(){
	buildPopup.style.display = 'none';
}
function showBuildPopup(){
	buildPopup.style.display = 'block';
}




const LOOKUP = { 
	gameState, 
};

function getByPath(obj, path) {
	return path.split('.').reduce((acc, key) => {
		if (acc == null) return undefined;
		return acc[key];
	}, obj);
}
/*
// same as writing:
function getByPath(obj, path) {
	const keys = path.split('.');
	let current = obj;

	for (const key of keys) {
		if (current == null) {
			return undefined;
		}
		current = current[key];
	}

	return current;
}
*/


function parseOutCommand(cmd) {
	// Expect format: "/out someName"
	const parts = cmd.trim().split(/\s+/);

	if (parts.length !== 2 || parts[0] !== "/out") {
		return null;
	}

	// Look up global variable
	//const varName = parts[1];
	//const value = gameState[varName];
	const path = parts[1];
	const value = getByPath(gameState, path);

	if (value === undefined) {
		console.error("path '"+path+"' not found");
		return null;
	}else{
		console.warn("parseOutCommand: ");
		console.warn(value);
		//console.log(window);
	}
	
	return JSON.stringify(value);
}


// radians to degrees
function deg2rad(degrees){
	return degrees * Math.PI / 180;
}

// degrees to radians
function rad2deg(radians){
	return radians * 180 / Math.PI;
}


function rotateAroundScreenCenter(theta) {
	const cx = canvas.width / 2;
	const cy = canvas.height / 2;
	
	// camera vector relative to center
	let dx = viewport.x - cx;
	let dy = viewport.y - cy;

	// rotate
	let cos = Math.cos(theta);
	let sin = Math.sin(theta);
	viewport.x = cx + dx * cos - dy * sin;
	viewport.y = cy + dx * sin + dy * cos;

	// update rotation
	viewport.rotation += theta;
}


function rotateLeftSnapped(){
	// snap at 30 degree rotations even when current rotation was not 30 degree step:
	let snappedDeg = Math.round(rad2deg(viewport.rotation-deg2rad(30)) / 30) * 30;
	rotateAroundScreenCenter(deg2rad(snappedDeg) - viewport.rotation);
}
function rotateRightSnapped(){
	// snap at 30 degree rotations even when current rotation was not 30 degree step:
	let snappedDeg = Math.round(rad2deg(viewport.rotation+deg2rad(30)) / 30) * 30;
	rotateAroundScreenCenter(deg2rad(snappedDeg) - viewport.rotation);
}


function pauseMusicButtonsHandle(){
	musicPauseBtn2.style.display = "none";
	musicPlayBtn2.style.display = "block";
}

function pauseMusicClick(){
	pauseMusicButtonsHandle();
	pauseMusic();
}
function playMusicClick(){
	musicPauseBtn2.style.display = "block";
	musicPlayBtn2.style.display = "none";
	playMusic();
	
	unmuteMusicButtonsHandle();
	musicMuted = false;
	setLocalStorageItem("musicMuted", musicMuted);
}
function nextMusicClick(){
	musicPauseBtn2.style.display = "block";
	musicPlayBtn2.style.display = "none";
	playNextTrack();
}
function prevMusicClick(){
	musicPauseBtn2.style.display = "block";
	musicPlayBtn2.style.display = "none";
	playPreviousTrack();
}



if(musicMuted){
	muteMusicButtonsHandle();
	pauseMusicButtonsHandle();
}else{
	unmuteMusicButtonsHandle();
}


function muteMusicClick(){
	muteMusicButtonsHandle();
	musicMuted = true;
	pauseMusicClick();
	setLocalStorageItem("musicMuted", musicMuted);
}

function unmuteMusicClick(){
	unmuteMusicButtonsHandle();
	musicMuted = false;
	playMusicClick();
	setLocalStorageItem("musicMuted", musicMuted);
}

function muteMusicButtonsHandle(){
	musicMuteBtn2.style.display = "none";
	musicUnmuteBtn2.style.display = "block";
}
function unmuteMusicButtonsHandle(){
	musicMuteBtn2.style.display = "block";
	musicUnmuteBtn2.style.display = "none";
}


// =================================================================
// --- EVENT LISTENERS
// =================================================================
window.addEventListener('DOMContentLoaded', async () => {

	initDB();

	await loadImages();

	
	//hostCustomColorPicker.value = "#FF00FF";
	//lobbyCustomColorPicker.value = "#FF00FF";

	//hostBtn.disabled = true;
	hostBtn.disabled = false; // allow hosting while connecting to peerjs.
	joinBtn.disabled = true;
	spectateBtn.disabled = true;
	
	// --- Start Page ---
	hostBtn.onclick = hostGame;
	joinBtn.onclick = () => joinGame(false);
	spectateBtn.onclick = () => joinGame(true);
	randomNameBtn.onclick = () => giveRandomName();
	//playerNameInput.onchange = (e) => localPlayer.name = e.target.value;
	
	playerNameInput.onchange = () => {
		if(isValidName(playerNameInput.value)){
			playerNameInput.value = playerNameInput.value.trim();
			localPlayer.name = playerNameInput.value;
		}
	}

	// --- Host Page ---
	hostRoomPlayerNameInput.onchange = () => {
		if(isValidName(hostRoomPlayerNameInput.value)){
			hostRoomPlayerNameInput.value = hostRoomPlayerNameInput.value.trim();
			localPlayer.name = hostRoomPlayerNameInput.value;
			broadcastLobbyState();
		}
	}
	
	mapWidthInput.onchange = () => {
		gameState.settings.mapWidth = getUint(mapWidthInput.value);
		mapWidthInput.value = gameState.settings.mapWidth;
		broadcastLobbyState();
	}
	mapHeightInput.onchange = () => {
		gameState.settings.mapHeight = getUint(mapHeightInput.value);
		mapHeightInput.value = gameState.settings.mapHeight;
		broadcastLobbyState();
	}

	startMoneyInput.onchange = () => {
		if(!gameStarted() && isHost()){
			gameState.settings.startingMoney = getUint(startMoneyInput.value);
			startMoneyInput.value = gameState.settings.startingMoney;
			broadcastSettings();
		}
	};

	mapScale.onchange = () => {
		if(!gameStarted() && isHost()){
			gameState.settings.mapScale = getMapScale();
			mapScale.value = gameState.settings.mapScale;
			broadcastLobbyState();
			setLoadedMapAndApplyScale();
		}
	}
	
	spectateHostBtn.onclick = () => {
		if(!gameStarted() && isHost()){
			localPlayer.isSpectator = !localPlayer.isSpectator;
			let colors = getNextFreeColors();
			localPlayer.color = localPlayer.isSpectator ? SPECTATOR_COLOR : colors.color;
			localPlayer.textColor = localPlayer.isSpectator ? SPECTATOR_COLOR : colors.textColor;
			spectateHostBtn.classList.toggle('active', localPlayer.isSpectator);
			broadcastLobbyState();
		}
	};

	startGameBtn.onclick = startGame;
	startReplayBtn.onclick = startReplay;
	
	// --- Lobby Page ---
	lobbyPlayerNameInput.onchange = (e) => {
		if(isValidName(e.target.value)){
			lobbyPlayerNameInput.value = e.target.value.trim();
			localPlayer.name = lobbyPlayerNameInput.value;
			sendToHost({
				type: ACTION.player_update,
				name: localPlayer.name,
			});
		}
	};
	
	lobbyTextureType.onchange = (e) => {
		localPlayer.textureType = parseInt(e.target.value, 10);
		sendToHost({
			type: ACTION.player_update,
			textureType: localPlayer.textureType,
		});
	};
	
	// --- Game Page ---
	window.onresize = resizeCanvas;
	canvas.addEventListener('wheel', handleWheel, { passive: false });
	canvas.addEventListener('mousedown', handleCanvasMouseDown);
	canvas.addEventListener('mousemove', handleCanvasMouseMove);
	canvas.addEventListener('mouseup', handleCanvasMouseUp);
	canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
	canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
	
	canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
	canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
	
	
	// moved to own /refresh command.
	//refreshCanvasBtn.onclick = () => {
	//	addSystemChatMessage(`resizeCanvas(): old = ${canvas.width}x${canvas.height}, new = ${window.innerWidth}x${window.innerHeight}`);
	//	resizeCanvas();
	//};
	


	rotateLeftBtn.onclick = () => {
		rotateLeftSnapped();
	};
	rotateResetBtn.onclick = () => {
		rotateAroundScreenCenter(-viewport.rotation);
	};
	rotateRightBtn.onclick = () => {
		rotateRightSnapped();
	};
	


	saveGameBtn.onclick = () => {
		saveGameToDB(gameState);
		addSystemChatMessage("Game saved.", '#FFF');
	};
	saveGameBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	saveGameBtn.tabIndex = -1; //remove it from the tab order
	
	
	quitGameBtn.onclick = () => {
		restartGame();
	};
	quitGameBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	quitGameBtn.tabIndex = -1; //remove it from the tab order
	
	
	

	musicPauseBtn2.onclick = () => {pauseMusicClick();};
	musicPauseBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	musicPauseBtn2.tabIndex = -1; //remove it from the tab order
	
	musicPlayBtn2.onclick = () => {playMusicClick();};
	musicPlayBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	musicPlayBtn2.tabIndex = -1; //remove it from the tab order

	musicNextBtn2.onclick = () => {nextMusicClick();};
	musicNextBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	musicNextBtn2.tabIndex = -1; //remove it from the tab order
	
	musicPreviousBtn2.onclick = () => {prevMusicClick();};
	musicPreviousBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	musicPreviousBtn2.tabIndex = -1; //remove it from the tab order
	
	musicMuteBtn2.onclick = () => {muteMusicClick();};
	musicMuteBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	musicMuteBtn2.tabIndex = -1; //remove it from the tab order
	
	musicUnmuteBtn2.onclick = () => {unmuteMusicClick();};
	musicUnmuteBtn2.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	musicUnmuteBtn2.tabIndex = -1; //remove it from the tab order
	
	

	
	toggleUiBtn.onclick = () => {
		toggleUiTopLeft();
		if(settingsUi.style.display === 'flex'){
			toggleSettings();
		}
	};
	toggleUiBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	toggleUiBtn.tabIndex = -1; //remove it from the tab order
	
	

	lobbyChatInput.onkeydown = (e) => {
		// enter key "enter"
		if (e.key === 'Enter') {
			
			let message = lobbyChatInput.value.trim();
			message = message.slice(0, MAX_LOBBY_MESSAGE_LEN);
			lobbyChatInput.value = message; // avoid leaving empty message if pressed space in accident.
			
			if(lobbyChatInput.value !== ''){
				// send only the needed info, host handles adding colors etc.
				sendToHost({
					type: ACTION.lobby_chat, 
					message: message,
				});
				lobbyChatInput.value = '';
			}
		}
	};
	

	clientLobbyChatInput.onkeydown = (e) => {
		// enter key "enter"
		if (e.key === 'Enter') {
			
			let message = clientLobbyChatInput.value.trim();
			message = message.slice(0, MAX_LOBBY_MESSAGE_LEN);
			clientLobbyChatInput.value = message; // avoid leaving empty message if pressed space in accident.
			
			if(clientLobbyChatInput.value !== ''){
				// send only the needed info, host handles adding colors etc.
				sendToHost({
					type: ACTION.lobby_chat, 
					message: message,
				});
				clientLobbyChatInput.value = '';
			}
		}
	};
	
	chatInput.onkeydown = (e) => {
		// enter key "enter"
		if (e.key === 'Enter') {
			toggleUiTopLeft(false);
			let message = chatInput.value.trim();
			message = message.slice(0, MAX_MESSAGE_LEN);
			chatInput.value = message; // avoid leaving empty message if pressed space in accident.
			
			if(chatInput.value !== ''){
				// send only the needed info, host handles adding colors etc.
				sendToHost({
					type: ACTION.chat, 
					message: message,
				});
				chatInput.value = '';
				
				// process local commands:
				switch(message.toLowerCase()){
					case "/debug":
						drawDebugText = !drawDebugText;
						drawRanges = drawDebugText;
					break;
					case "/refresh":
						refreshCanvas();
					break;
					case "/editor":
						if(isHost()){
							//EDITOR_ENABLED = !EDITOR_ENABLED;
							gameState.settings.editorEnabled = !gameState.settings.editorEnabled;
							broadcastSettings();
						}
					break;
					case "/givemoney":
						givemoney(1000);
					break;
					case "/givemoneyall":
						givemoneyall(1000);
					break;
					case "/drawranges":
						drawRanges = !drawRanges;
					break;
					case "/previewdraw":
						previewdraw = !previewdraw;
					break;
					case "/f":
						replaySpeedUp();
					break;
					case "/s":
						replaySpeedDown();
					break;
					case "/restart":
						DELAY_MULTI = 1;
						// restart replay
					break;
					case "/reverse":
						reverse = !reverse;
					break;
					case "/drawtextures":
						drawtextures = !drawtextures;
					break;
					
					
				}

				
				// process "/out gameState" command:
				let output = parseOutCommand(message);
				if(output){
					addSystemChatMessage(output, '#FFF');
				}
			}
			
		}
	};
	
	buildOtherBtn.onclick = () => {
		if(!REPLAY_ENABLED){
			if (buildOtherBtn.classList.contains("cancel")) {
				buildOtherBtn.classList.remove("cancel");
				cancelBuildPopup();
			}else{
				openBuildPopup('other');
			}
		}
	};
	buildOtherBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	buildOtherBtn.tabIndex = -1; //remove it from the tab order
	
	
	buildSoldierBtn.onclick = () => {
		if(!REPLAY_ENABLED){
			if (buildSoldierBtn.classList.contains("cancel")) {
				buildSoldierBtn.classList.remove("cancel");
				cancelBuildPopup();
			}else{
				openBuildPopup('soldier');
			}
		}
	};
	buildSoldierBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	buildSoldierBtn.tabIndex = -1; //remove it from the tab order
	
	buildCastleBtn.onclick = () => {
		if(!REPLAY_ENABLED){
			if (buildCastleBtn.classList.contains("cancel")) {
				buildCastleBtn.classList.remove("cancel");
				cancelBuildPopup();
			}else{
				openBuildPopup('castle');
			}
		}
	};
	buildCastleBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	buildCastleBtn.tabIndex = -1; //remove it from the tab order
	
	
	buildPopupClose.onclick = () => {
		cancelBuildPopup();
	};
	buildPopupClose.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	buildPopupClose.tabIndex = -1; //remove it from the tab order
	
	
	nextUnitBtn.onclick = () => {
		let player = getMyPlayer();
		
		if(!REPLAY_ENABLED && player && isMyTurn()){
			let startIndex = 0;
			
			if(selectedUnit){
				for(let i = 0; i < gameState.units.length; i++){
					let unit = gameState.units[i];
					if(unit.id === selectedUnit.id){
						startIndex = i+1;
						if(startIndex > gameState.units.length-1){
							startIndex = 0; // start from beginning again.
						}
						break;
					}
				}
			}
			
			// search forward starting at selected index, wrapping around
			for (let offset = 0; offset < gameState.units.length; offset++) {
				const i = (startIndex + offset) % gameState.units.length;
				let unit = gameState.units[i];

				if(unitTypeCanMove(unit.type) && unit.ownerIndex === player.playerIndex && !unit.hasMoved){
				//if(unit.internalType === 'soldier' && unit.ownerIndex === player.playerIndex && !unit.hasMoved){
					centerAndSelectUnit(unit);
					playSound('startmove');
					break;
				}
			}
			
			// disable next button if no next unit can be found:
			previousUnitBtn.disabled = !hasUnmovedUnits();
			nextUnitBtn.disabled = !hasUnmovedUnits();
		}
	};
	nextUnitBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	nextUnitBtn.tabIndex = -1; //remove it from the tab order
	
	
	previousUnitBtn.onclick = () => {
		//refreshCanvas(); // test if this fixes the black bar issue.
		
		let player = getMyPlayer();
		
		if(!REPLAY_ENABLED && player && isMyTurn()){
			let startIndex = 0;
			
			if(selectedUnit){
				// search backwards the startIndex:
				for(let i = gameState.units.length-1; i >= 0; i--){
					let unit = gameState.units[i];
					if(unit.id === selectedUnit.id){
						startIndex = i-1;
						if(startIndex < 0){
							startIndex = gameState.units.length-1; // start from end again.
						}
						break;
					}
				}
			}
			
			// search backwards starting at selected index, wrapping around
			for (let offset = 0; offset < gameState.units.length; offset++) {
				// +gameState.units.length to ensure no negative values given:
				const i = (startIndex - offset + gameState.units.length) % gameState.units.length;
				let unit = gameState.units[i];

				if(unitTypeCanMove(unit.type) && unit.ownerIndex === player.playerIndex && !unit.hasMoved){
				//if(unit.internalType === 'soldier' && unit.ownerIndex === player.playerIndex && !unit.hasMoved){
					centerAndSelectUnit(unit);
					playSound('startmove');
					break;
				}
			}
			
			// disable next button if no next unit can be found:
			previousUnitBtn.disabled = !hasUnmovedUnits();
			nextUnitBtn.disabled = !hasUnmovedUnits();
		}
	};
	previousUnitBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	previousUnitBtn.tabIndex = -1; //remove it from the tab order
	
	
	endTurnBtn.onclick = () => {
		if (!REPLAY_ENABLED && !endTurnBtn.disabled && isMyTurn()) {
			// end turn, and clear shielding units tips ("stop" image display)
			clearShieldingUnitsTips();
			sendToHost({ type: ACTION.action_end_turn });
		}
	};
	endTurnBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	endTurnBtn.tabIndex = -1; //remove it from the tab order
	
	undoBtn.onclick = () => {
		if (!REPLAY_ENABLED && isMyTurn()) {
			sendToHost({ type: ACTION.action_undo });
			updateGameUI();
		}
	};
	undoBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	undoBtn.tabIndex = -1; //remove it from the tab order
	
	sellUnitBtn.onclick = () => {
		if (!REPLAY_ENABLED && isMyTurn()) {
			console.log("action_sell");
			console.log(selectedUnit);
			if(selectedUnit){
				sendToHost({
					type: ACTION.action_sell, 
					unitId: selectedUnit.id,
					poolHex: getSelectedPoolHex(), // maybe should get this automatically from the unit position...
				});
				deselectUnit(); // Deselect
				//deselectHex();
				console.log("Deselected unit");
			}
		}
	};
	sellUnitBtn.addEventListener("mousedown", e => e.preventDefault()); // Prevent the button from ever receiving focus
	sellUnitBtn.tabIndex = -1; //remove it from the tab order
	
	
	initPeerJS();
	
	

	console.log("DOMContentLoaded finished");
});






</script>



</body>
</html>
